%; whizzy paragraph -pdf xpdf -latex ./whizzypdfptex.sh
%; whizzy-paragraph "^\\\\begin{frame}\\|\\\\emtext"
% latex beamer presentation.
% platex, latex-beamer でコンパイルすることを想定。 

%     Tokyo Debian Meeting resources
%     Copyright (C) 2012 Junichi Uekawa

%     This program is free software; you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation; either version 2 of the License, or
%     (at your option) any later version.

%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warreanty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.

%     You should have received a copy of the GNU General Public License
%     along with this program; if not, write to the Free Software
%     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

\documentclass[cjk,dvipdfmx,12pt]{beamer}
\usetheme{Tokyo}
\usepackage{monthlypresentation}

%  preview (shell-command (concat "evince " (replace-regexp-in-string "tex$" "pdf"(buffer-file-name)) "&")) 
%  presentation (shell-command (concat "xpdf -fullscreen " (replace-regexp-in-string "tex$" "pdf"(buffer-file-name)) "&"))
%  presentation (shell-command (concat "evince " (replace-regexp-in-string "tex$" "pdf"(buffer-file-name)) "&"))

%http://www.naney.org/diki/dk/hyperref.html
%日本語EUC系環境の時
\AtBeginDvi{\special{pdf:tounicode EUC-UCS2}}
%シフトJIS系環境の時
%\AtBeginDvi{\special{pdf:tounicode 90ms-RKSJ-UCS2}}

\newenvironment{commandlinesmall}%
{\VerbatimEnvironment
  \begin{Sbox}\begin{minipage}{1.0\hsize}\begin{fontsize}{8}{8} \begin{BVerbatim}}%
{\end{BVerbatim}\end{fontsize}\end{minipage}\end{Sbox}
  \setlength{\fboxsep}{8pt}
% start on a new paragraph

\vspace{6pt}% skip before
\fcolorbox{dancerdarkblue}{dancerlightblue}{\TheSbox}

\vspace{6pt}% skip after
}
%end of commandlinesmall

\title{東京エリアDebian勉強会}
\subtitle{第135回 2016年1月度}
\author{野島貴英}
\date{2016年1月23日}
\logo{\includegraphics[width=8cm]{image200607/openlogo-light.eps}}

\begin{document}

\begin{frame}
\titlepage{}
\end{frame}

\begin{frame}{Agenda}
 \begin{minipage}[t]{0.45\hsize}
  \begin{itemize}
   \item 事前課題発表
   \item 最近あったDebian関連のイベント報告
	 \begin{itemize}
	 \item 第134回東京エリアDebian勉強会
	 \end{itemize}
  \end{itemize}
 \end{minipage} 
 \begin{minipage}[t]{0.45\hsize}
  \begin{itemize}
   \item Debian Trivia Quiz
   \item 2016/6末までの皆さんのDebianプロジェクト
   \item Debianで、Linux ftraceまわりをいじってみた
   \item 今日の宴会場所
  \end{itemize}
 \end{minipage}
\end{frame}

\section{事前課題}
\emtext{事前課題}
{\footnotesize
 \input{image201601/prework.tex}
}

\section{イベント報告}
\emtext{イベント報告}

\begin{frame}{第134回東京エリアDebian勉強会 }

\begin{itemize}
\item 場所はdotsさんをお借りしての開催でした。
\item 参加者は9名でした。
\item セミナ内容は、2本建てで、
  \begin{enumerate}
  \item 参加者皆さんによる「 Debian おすすめのパッケージを参加者に聞いてみた 」
  \item 野島さんによる「 Debian モバイル wifi ルータ化 」
  \end{enumerate}
でした。
\item 残りの時間でhack timeを行い、成果発表をしました。
\end{itemize} 
\end{frame}

\begin{frame}{第134回東京エリアDebian勉強会(つづき)}

  「Debian おすすめのパッケージを参加者に聞いてみた」は、参加登録する際のアンケートにて、おすすめのパッケージとおすすめポイントを記入してもらったものを、皆さんに発表頂きました。10個のパッケージと１つのお勧めソフトウェアが紹介されました。

\end{frame}

\begin{frame}{第134回東京エリアDebian勉強会(つづき)}

  「Debian モバイル wifi ルータ化」は、Debian sidをモバイルwifiルータにしてしまう方法についての発表でした。pppd,bridge,dnsmasqによるdhcpサーバ、hostapdを一気に紹介し、はまりどころについて語られました。また、wifiのハードウェアにlinuxからアクセスする時に利用される、今時のフレームワークについても説明が行われました。

\end{frame}

\begin{frame}{第133回東京エリアDebian勉強会(つづき)}

　Debianは、デスクトップに、組み込み機材に、様々に自由に使うことができます。様々なパッケージを組み合わせると、民生品と同等の機能を持つものを簡単に作ることができてしまいます。もし、民生品で気に入らないところがあれば、自分で直すこともできるようになります。どこまでも自由なDebianを使って、自分の思い通りの機材を作る方が益々増えるとよいですね。
  
\end{frame}

\if0
\section{Debian Trivia Quiz}
\emtext{Debian Trivia Quiz}
\begin{frame}{Debian Trivia Quiz}

  Debian の常識、もちろん知ってますよね?
知らないなんて恥ずかしくて、知らないとは言えないあんなことやこんなこと、
みんなで確認してみましょう。

今回の出題範囲は\url{debian-devel-announce@lists.debian.org},
\url{debian-news@lists.debian.org} に投稿された
内容などからです。

\end{frame}

\subsection{問題}

\input{image201601/quiz.tex}
\fi

\section{2016/6末までの皆さんのDebianプロジェクト}
\emtext{2016/6末までの皆さんのDebianプロジェクト}

\begin{frame}{はじめに}

  2016年も始まりました。参加登録時の事前アンケート機能を用いて、2016/6末までに、皆さんはDebianについて何をするのか？について予定を立てていただきました。今回はこちらを皆さんに発表いただきます。
  
\end{frame}

\begin{frame}{mkouhei}

 長女(3月で4歳）にDebian をインストールしたPCでキーボード操作を習得させる。

\end{frame}

\begin{frame}{henrich}

 ウェブサイトの再構築提案したい。

\end{frame}

\begin{frame}{kenhys}

 Debian勉強会にできるだけ参加したい。

\end{frame}

\begin{frame}{wskoka}

 portsにエントリーしたい

\end{frame}

\begin{frame}{rosh}

\begin{itemize}
\item Linkstation の kernel DTS をメンテする
\item Linkstation の d-i (installer) を対応する
\end{itemize}

\end{frame}

\begin{frame}{dictoss}

kfreebsdを使ってバグ出しする。
  
\end{frame}

\begin{frame}{y.y}

 たまっている、未処理key signing を処理する。
  
\end{frame}

\begin{frame}{yy\_y\_ja\_jp}

\begin{itemize}
\item パッケージ更新
\item ITP
\end{itemize}
  
\end{frame}

\begin{frame}{野島}

\begin{itemize}
\item 毎月１回は東京エリアDebian勉強会を開催する
\item 手元のNook HD+にてカスタムKernelをネイティブで動かし、Debianのrootファイルシステムを認識させる。
\end{itemize}
  
\end{frame}

\begin{frame}{おわりに}

　様々な目標を立てていただきました。2016/7にて進捗を確認してみようと思いますので、目標達成に向けて、みなさん頑張りましょう。
  
\end{frame}

\section{Debianで、Linux ftraceまわりをいじってみた}
\emtext{Debianで、Linux ftraceまわりをいじってみた}

\begin{frame}{はじめに}

 Linuxカーネルのデバッグ支援機能で人気のあるものに、ftraceという仕組みがあります。今回はDebian unstableで提供されているlinux-4.3.3を利用して、ftraceを使ってみます。
  
\end{frame}

\begin{frame}{ftraceとは}

  Linuxカーネル内部の実行トレースを効率的に取れるようにしたデバッグ支援機構となります。カーネル内部のCの関数単位でトレースが取れたりします。

  人気があるせいか、機能拡張がどんどん続いています。最近では、ユーザプロセスのトレースも取れる機能が追加される、kprobeとの連携などが追加されています。

\end{frame}

\begin{frame}{ftraceとは（つづき）}

　Debianのバグ潰しに、是非活用してみてはいかがでしょう！
  
\end{frame}

\begin{frame}{ftrace注意点}

  評価中に何度か経験したのですが、一部のftraceの機能(uevent,kprobe)にて、プローブの手続きを書き間違えたりすると、カーネル全体が突然ハングアップしたり、マシンが突然リブートすることがありました。

　利用にあたっては、必ず十分に事前に動作を検証してから、重要なサーバ上などで実行する事をおすすめします。もちろん、重要でないサーバ上なら、いくらでも試行錯誤くださいませ（笑）
  
\end{frame}

\begin{frame}[containsverbatim]{よく知られている使い方について}

 カーネル内部の関数の実行トレースを取ってみます。なお、実行にあたってはroot権限が必要。
  
 \begin{commandline}
 # cd /sys/kernel/debug/tracing
 # echo function > current_tracer
 # head -15 trace　
   もしくは、
 # cat trace_pipe
 \end{commandline}   
 
\end{frame}

\begin{frame}[containsverbatim]{よく知られている使い方について（つづき）}

結果：
 \begin{commandlinesmall}
# tracer: function
#
# entries-in-buffer/entries-written: 205013/84652723   #P:4
#
#                              _-----=> irqs-off
#                             / _----=> need-resched
#                            | / _---=> hardirq/softirq
#                            || / _--=> preempt-depth
#                            ||| /     delay
#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
#              | |       |   ||||       |         |
     ksoftirqd/2-18    [002] ..s. 34273.981969: _raw_read_lock_bh
                                                     <-ppp_input
     ksoftirqd/2-18    [002] ..s. 34273.981969: _raw_spin_lock_bh
                                                     <-ppp_input
     ksoftirqd/2-18    [002] ..s. 34273.981969: ppp_receive_frame
                                                     <-ppp_input
     ksoftirqd/2-18    [002] ..s. 34273.981969: ppp_receive_nonmp_frame
                                                      <-ppp_input
※紙面の都合で、一部改行を入れています。 また、<-XXXはXXXが呼び出し元。
 \end{commandlinesmall}   

\end{frame}

\begin{frame}[containsverbatim]{よく知られている使い方について（つづき）}

 カーネル内部の特定の関数の呼び出しをトレースしてみます。以下のコマンドラインは先程の続きの操作からとなります。
 \begin{commandline}
 一旦、トレースを止める。
 # echo nop > current_tracer
 schedule関数の呼び出しのみ取る。
 # echo schedule > set_ftrace_filter
　再開してみる
 # echo function > current_tracer
 # head -15 trace　
   もしくは、
 # cat trace_pipe
 \end{commandline}   
※ トレースを止めるには、tracing\_onファイルに0や1を書き込んで止めるのが本式らしいのですが、今回は簡易にnopを指定して止めています。
\end{frame}

\begin{frame}[containsverbatim]{よく知られている使い方について（つづき）}

結果：
 \begin{commandlinesmall}
# tracer: function
#
# entries-in-buffer/entries-written: 205173/1017318   #P:4
#
#                              _-----=> irqs-off
#                             / _----=> need-resched
#                            | / _---=> hardirq/softirq
#                            || / _--=> preempt-depth
#                            ||| /     delay
#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
#              | |       |   ||||       |         |
   　　　　<idle>-0     [001] .N.. 35985.931338: schedule
   　　　　　　　　　　　　　　　　　　　　<-schedule_preempt_disabled
   　    threaded-ml-30937 [001] .... 35985.931365: schedule
   　　　　　　　　　　　　　　<-schedule_hrtimeout_range_clock.part.23
　　　　   <idle>-0     [001] .N.. 35985.935088: schedule
   　　　　　　　　　　　　　　<-schedule_preempt_disabled
　   kworker/1:1-30635 [001] .... 35985.935118: schedule
   　　　　　　　　　　　　　　<-worker_thread
 　　　　  <idle>-0    [001] .N.. 35985.937301: schedule
   　　　　　　　　　　　　　　<-schedule_preempt_disabled
※紙面の都合で、一部改行を入れています。 また、<-XXXはXXXが呼び出し元。
 \end{commandlinesmall}   
\end{frame}

\begin{frame}[containsverbatim]{よく知られている使い方について（つづき)}

 カーネル内部の特定の関数の呼び出しをトレースしてみます。以下のコマンドラインは先程の続きの操作からとなります。
 \begin{commandline}
 一旦、トレースを止める。
 # echo nop > current_tracer
 schedule関数の呼び出しのみ取る。
 # echo schedule > set_ftrace_filter
　再開してみる
 # echo function > current_tracer
 # head -15 trace　
   もしくは、
 # cat trace_pipe
 \end{commandline}   
\end{frame}

\begin{frame}[containsverbatim]{よく知られている使い方について（つづき)}
 補足:
\begin{itemize}
 \item set\_ftrace\_filterには、*のワイルドカードが利用でき、例えば、
   \begin{itemize}
   \item \verb+echo '*lock*' > set_ftrace_filter+
   \item \verb+echo 'ppp*' > set_ftrace_filter+     
   \end{itemize}
   という指定が可能です。\verb+*lock*+はlockを名前に含む関数がトレースされるようになります。\verb+ppp*+は行頭がpppで始まる関数がトレースされるようになります。
 \item トレースから除外する関数を指定する場合は、\verb+set_ftrace_notrace+に指定すると合致したものがトレースから除外されます。
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]{よく知られている使い方について（つづき)}

 参考：set\_ftrace\_filterに指定可能な関数一覧
 \begin{commandline}
#  lv available_filter_functions
run_init_process
try_to_run_init_process
do_one_initcall
match_dev_by_uuid
name_to_dev_t
rootfs_mount
...中略(相当量ある）...  
 \end{commandline}   
\end{frame}
    

\begin{frame}[containsverbatim]{よく知られている使い方について（つづき）}

 コールツリーをとってみます。以下のコマンドラインは先程の続きの操作からとなります。
  
 \begin{commandline}

 # echo nop > current_tracer
 フィルタを一旦クリア
 # echo > set_ftrace_filter
 # echo do_sys_open > set_graph_function
 # echo  function_graph > current_tracer
 # head -15 trace　
   もしくは、
 # tail -f trace   
 \end{commandline}   
 
\end{frame}

\begin{frame}[containsverbatim]{よく知られている使い方について（つづき）}

結果：
 \begin{commandlinesmall}
# tracer: function_graph
#
# CPU  DURATION                  FUNCTION CALLS
# |     |   |                     |   |   |   |
 2)               |  do_sys_open() {
 2)               |    getname() {
 2)               |      getname_flags() {
 2)               |        kmem_cache_alloc() {
 2)   0.151 us    |          _cond_resched();
 2)   1.725 us    |        }
 2)               |        __do_page_fault() {
 2)   0.194 us    |          down_read_trylock();
 2)   0.090 us    |          _cond_resched();
 2)               |          find_vma() {
 2)   0.191 us    |            vmacache_find();
 \end{commandlinesmall}   
\end{frame}

\begin{frame}[containsverbatim]{よく知られている使い方について（つづき）}

  \begin{itemize}
    \item  他にも、割り込みが長時間止められた関数のトレース(irqsoff)がありますが、
      Debianの標準のlinux-imageパッケージでは有効にはなっていません。\verb+lv /boot/config-`uname -r`+で現在稼働中のlinuxカーネルのビルド時の設定が確認できます。\verb+# CONFIG_IRQSOFF_TRACER is not set+や、\verb+# CONFIG_SCHED_TRACER is not set+とあるかと思います。
    \item 他に利用できるトレースは、\verb+available_tracers+ファイルを確認するとよいと思います。
　\end{itemize}
  
\end{frame}

\begin{frame}[containsverbatim]{よく知られている使い方について（つづき）}

  今回紹介した以上のよく知られている使い方のチュートリアルは、LWNの記事が良いです。\\

\begin{itemize}
\item Ftrace: The hidden light switch\\
\url{https://lwn.net/Articles/608497/}
\item Debugging the kernel using Ftrace\\
\url{https://lwn.net/Articles/365835/}\\
\url{https://lwn.net/Articles/366796/}
\item Secrets of the Ftrace function tracer\\
\url{https://lwn.net/Articles/370423/}
\end{itemize}  
  
\end{frame}  

\begin{frame}[containsverbatim]{ユーザプロセスのトレースをやってみる}

  最近のカーネルのftraceは、''use user-level statically defined tracing (USDT) probe''というユーザプロセス側のトレースを取れる機能があります。まずはこちらを紹介します。

  実際には、\verb+uprobe_events+ファイルを操作するのですが、関数のエントリポイントのメモリアドレスを指定しなければならないなどの使い勝手の問題があるため、perf-toolというツール経由で操作する方法について述べます。

\end{frame}  

\begin{frame}{ユーザプロセスのトレースをやってみる（つづき）}

 ところで、Debian unstableには、このperf-toolがパッケージ化されているのですが、残念ながら2015年1月時点のupstreamのソースであるため、USDT probeに対応したコマンドが入っていません\footnote{bug report上げておきます。}。仕方が無いので、upstreamからソースを引っ張ってくることにします。なお、シェルスクリプトですので、手元に持ってくるだけで使えます。
  
\end{frame}  

\begin{frame}[containsverbatim]{ユーザプロセスのトレースをやってみる（つづき）}

 ソースの入手と準備
 \begin{commandline}
   $ git clone https://github.com/brendangregg/perf-tools.git
   $ cd perf-tools/bin
   $ su root
   #
　\end{commandline}
 \end{frame}  

\begin{frame}[containsverbatim]{ユーザプロセスのトレースをやってみる（つづき）}

　試しに、Debian unstable全体のプロセスを対象に、libc中のopen関数を呼び出しをファイル名も含めてトレースしてみます。

 \begin{commandline}
   # ./uprobe 'p:/lib/x86_64-linux-gnu/libc-2.21.so:open
   +0(%di):string'
   gkrellm-2283  [001] d... 32718.873326: open:
   　　　　　　　　　　　(0x7f5543ecf640) arg1="/proc/loadavg"
   gkrellm-2283  [001] d... 32718.969105: open:
   　　　　　　　　　　　(0x7f5543ecf640) arg1="/proc/loadavg"
   gkrellm-2283  [001] d... 32719.064968: open:
   　　　　　　　　　　　(0x7f5543ecf640) arg1="/proc/loadavg"
	 ....中略...
　※紙面の都合で改行を入れています。
 \end{commandline}
\end{frame}  

\begin{frame}[containsverbatim]{ユーザプロセスのトレースをやってみる（つづき）}

 uprobeの引数の文言についての説明は、linuxソースの\verb+Documentation/trace/uprobetracer.txt+にその説明があります。

 先のページの例は、\verb+/lib/x86_64-linux-gnu/libc-2.21.so+に含まれるopen関数について、関数の第一引数の文字列が格納されている場所の指定（CPUのdiレジスタが指し示す先のオフセット0番地を文字列データという指定で）\footnote{AMD64アーキテクチャでは正確には、ediレジスタですが、現状ではdiと指定するようです。}を表示せよという意味となります。
 
\end{frame}  

\begin{frame}[containsverbatim]{ユーザプロセスのトレースをやってみる（つづき）}

 uprobeはトレース条件も指定でき、例えば、/var/log/以下のファイルをopenしたプロセスのみをトレース表示せよという指定は、
\begin{commandline}
  # ./uprobe 'p:/lib/x86_64-linux-gnu/libc-2.21.so:open
  　 file=+0(%di):string' 'file ~ /var/log/*'
\end{commandline}

となります。

\end{frame}  

\begin{frame}[containsverbatim]{kprobe経由のftraceを使ってみる}

  linux 3系列のカーネルであれば、ftraceはkprobe機能を活用したトレースを取ることが出来ます。
トレース条件にkprobeで指定できるような条件を指定できるので、kprobeに造形が深い場合は、こちらがよいかもしれません。

  ここでは、先ほど入手したperf-toolに梱包されているkprobeを利用してみます。
  
\end{frame}  

\begin{frame}[containsverbatim]{kprobe経由のftraceを使ってみる}

  使ってみる：
\begin{commandlinesmall}
  # ./kprobe 'p:myopen do_sys_open
  　　　　filename=+0(%si):string'  
  gkrellm-2283  [000] d...   511.849329: myopen:
  　(do_sys_open+0x0/0x220) filename="/proc/loadavg"
  gkrellm-2283  [000] d...   511.945166: myopen:
  　(do_sys_open+0x0/0x220) filename="/proc/loadavg"
  gkrellm-2283  [000] d...   512.040938: myopen:
  　(do_sys_open+0x0/0x220) filename="/proc/loadavg"
  ...中略...
　※紙面の都合で改行を入れています。
\end{commandlinesmall}  

\end{frame}  

\begin{frame}[containsverbatim]{ftraceについてさらに詳しく知る}

 他にも最新カーネルにはいくつもここでは語られない機能がftraceに実装されています。さらに詳しく知りたい方は\verb+Documentation/trace/+以下のファイルを読むとよいと思います。
  
\end{frame}  

\begin{frame}{おわりに}

 Linuxカーネルのftrace機能はいろいろと強力です。今回紹介出来なかった、機能もまだまだ存在します。将来、Linuxカーネルの挙動を追いかける必要が出てきた時に、ftraceで出来ることをささっと調査できるようになっていると、何かと便利かと思います。
  
\end{frame}

\section{Hack time}
\emtext{Hack time}

\begin{frame}{成果を記入下さい!}

  今回、Hack time時の成果を記録に残してみます。

\url{https://debianmeeting.titanpad.com/7}

に皆さんアクセス頂き（認証不要です）、各自成果を18:20までに記録するようにおねがいします。

\end{frame}
  
\section{今後のイベント}
\emtext{今後のイベント}
\begin{frame}{今後のイベント}
\begin{itemize}
\item 関西エリアDebian勉強会。
\item 2/13 (土) 第136回東京エリアDebian勉強会\\
  場所はmkoheiさんにてご紹介いただいた場所にて！
\end{itemize}
\end{frame}

\section{今日の宴会場所}
\emtext{今日の宴会場所}
\begin{frame}{今日の宴会場所}
未定
\end{frame}

\end{document}

;;; Local Variables: ***
;;; outline-regexp: "\\([ 	]*\\\\\\(documentstyle\\|documentclass\\|emtext\\|section\\|begin{frame}\\)\\*?[ 	]*[[{]\\|[]+\\)" ***
;;; End: ***
