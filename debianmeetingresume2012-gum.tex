%; whizzy chapter
% -initex iniptex -latex platex -format platex -bibtex jbibtex -fmt fmt
% 以上 whizzytex を使用する場合の設定。

%     Tokyo Debian Meeting resources
%     Copyright (C) 2011 Junichi Uekawa
%     Copyright (C) 2011 Nobuhiro Iwamatsu

%     Copyright (C) 2012 Koichi Akabe

%     This program is free software; you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation; either version 2 of the License, or
%     (at your option) any later version.

%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.

%     You should have received a copy of the GNU General Public License
%     along with this program; if not, write to the Free Software
%     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

%  preview (shell-command (concat "evince " (replace-regexp-in-string "tex$" "pdf"(buffer-file-name)) "&"))
% 画像ファイルを処理するためにはebbを利用してboundingboxを作成。
%(shell-command "cd image201201; ebb *.png")

%%ここからヘッダ開始。

\documentclass[mingoth,a4paper]{jsarticle}
\usepackage{monthlyreport}

% 日付を定義する、毎月変わります。
\newcommand{\debmtgyear}{2012}
\newcommand{\debmtgmonth}{6}
\newcommand{\debmtgdate}{23}
% (+ (* (- 2012 2005) 12) 12 -1) started from zero
\newcommand{\debmtgnumber}{95}


\begin{document}

\dancersection{Gentoo/Prefix on Debian}{青田直大}
\label{sec:your-label}

\subsection{はじめに}

いきなりGentooが出てきて驚かれたかもしれません.ここではDebian下で
Gentoo Prefixをインストールする方法について解説します.

\subsection{Gentoo Prefix}
\subsubsection{Gentooとは}
GentooはDebianやRPMと違ったソースベースのディストリビューションです.
ebuildというパッケージビルド方法や,パッケージの依存関係などを記述した
bashスクリプト風のファイルが"カテゴリー/パッケージ名/パッケージ名-パッ
ケージバージョン.ebuild"というファイル名で保管されています. emergeとい
うコマンドは, この 「Portageツリー」というパッケージ情報ファイルツリー
を読んで指定されたパッケージをビルド・インストールするパッケージ管理ソフ
トになっています.

\subsubsection{Prefixサポート}

Gentooも基本的にはLinux上のディストリビューションですが, Debianの
Debian GNU/kFreeBSDと同様にFreeBSD上でのパッケージ管理を目的とした
Gentoo/FreeBSDなどの開発も行なわれています. そういったLinux以外での
Gentooのサポートを総称して, Gentoo/Altと呼んでいます.
\footnote{http://www.gentoo.org/proj/en/gentoo-alt/} そのGentoo/Altの中
にGentoo Prefixというものがあります.
\footnote{http://www.gentoo.org/proj/en/gentoo-alt/prefix/index.xml} こ
れはGentooのシステムを使って(基本的には)他のOS上で, 任意のディレクトリ
にパッケージのインストールを行なえるようにするものです. たとえば, Mac
OS X上で動かして, MacPortsやhomebrewの代わりに使ったり, あるいは
FreeBSD上で使ったり, はたまたLinux上で使うことももちろんできます.

\subsection{Gentoo/Prefix on Debian}

さてここからが本題で, このGentoo/PrefixをDebianで使ってみます. おそらく
なんでそんなことを…? と思われるかもしれません. 以下のような点があげら
れるかと思います.

\begin{itemize}
\item 非rootユーザでも好きなところにインストールできる
\item Debianにないパッケージをインストールする時に楽できる
\item 技術的に楽しい?
\end{itemize}

Prefixインストールでは好きなディレクトリにインストールできるため, たと
えば自分のホームディレクトリの中などにインストールするようにしてしまえ
ばroot権限がなくともパッケージをインストールすることができます. また,
(もし万が一) Debianにないパッケージがあったとして, それがGentooの方にあ
れば, 自分でビルド方法や依存を調べることなく, Gentooのパッケージシステ
ムにおまかせしてしまうことができる, というわけです.

\subsubsection{インストール}

では, さっそくDebian上にインストールしてみましょう. まずはビルドに必要
なパッケージをインストールしておきます. 

\begin{commandline}
% apt-get install bzip2 build-essential bison libreadline-dev libncurses-dev autoconf xz-utils
\end{commandline}

つぎに, Prefixをインストールする場所を決めて,  変数EPREFIXに設定し, PATHも通しておきます.

\begin{commandline}
% export EPREFIX="$HOME/gentoo"
% export PATH="$EPREFIX/usr/bin:$EPREFIX/bin:$EPREFIX/tmp/usr/bin:$EPREFIX/tmp/bin:/usr/bin:/bin:$PATH"
\end{commandline}

Prefixをインストールするためのスクリプトを取得し, そのスクリプトを使っ
てパッケージ管理ソフトPortageと, パッケージ情報のPortageツリーをインス
トールしていきます. 

\begin{commandline}
% wget http://overlays.gentoo.org/proj/alt/browser/trunk/prefix-overlay/scripts/bootstrap-prefix.sh?format=txt \
  -O bootstrap-prefix.sh
% chmod 755 bootstrap-prefix.sh
% ./bootstrap-prefix.sh $EPREFIX tree
% ./bootstrap-prefix.sh $EPREFIX portage
\end{commandline}

この時点でemergeコマンドが使えるようになります. ここからはemergeを使っ
て, Prefix環境を整えていきます. このあたりはあまり今回の主題ではないの
で残りはPrefixのドキュメン
ト\footnote{http://www.gentoo.org/proj/en/gentoo-alt/prefix/bootstrap-solaris.xml}
を参考にしてください. \footnote{いまのDebianだとmultiarchの影響でうまく
  動かないところもあるかもしれません…}

\begin{commandline}

\end{commandline}

\subsection{apt-emerge}

ここまでで, Gentoo/Prefixを解説してきました. しかし, これではあまりに
Gentooすぎますね. Gentoo/Prefixの中にもDebian側で入っているはずのプログ
ラム・ライブラリがインストールされてしまってなんだか無駄なような気がし
てしまいます. 特にDebianだとさくさくとバイナリパッケージからインストー
ルされてしまうのに, Gentooだとソースからビルドされて待つのもなかなか大
変なものです. なんとかDebianにあるものはDebianのものを使いつつ, Gentoo
ではどうしても必要なものだけをインストールすることはできないでしょうか.

Gentooではetc/portage/profile/package.providedファイルに以下のように書
くことで, そのパッケージがインストールされていると「見做す」ことができます. 

\begin{commandline}
sys-power/acpi-1.6
sys-power/acpid-2.0.16
sys-process/at-3.1.13
sys-devel/autoconf-2.69
sys-devel/automake-1.11.3
app-shells/bash-4.2
\end{commandline}

Debian側にあるパッケージをこうやってGentoo側のパッケージ名にマップして,
package.providedファイルに書くことで, Gentoo側で依存としてパッケージが
ビルド・インストールされることがなくなります. こうして

\begin{enumerate}
\item Gentooのemergeでの依存パッケージを把握
\item Gentooでの依存パッケージ名をDebianのパッケージ名にマップ
\item インストールされたDebianのパッケージ名をGentooのパッケージ名にマップ
\item マップされたパッケージ名をpacakge.providedに追記
\item 再度依存関係を計算しなおして2に戻る
\item これ以上Debianからインストールできなければemergeを開始
\end{enumerate}

といったプロセスを行ない, 最小限のパッケージだけで目的のGentooのパッケー
ジをインストールすることができます. この時に肝となるのが, 「Gentooでの
  依存パッケージの把握」と「GentooとDebianとのパッケージの相互マップを
  どうするのか」の二点です.

\subsubsection{Gentooでの依存パッケージ}

emergeに対して以下のオプションをつけて出力を解析します.

\begin{itemize}
\item -p (--pretend): インストールを実行せずインストールパッケージ一覧だけを出力します
\item -q (--quiet): 無駄な情報を出力しないようにします
\item -t (--tree): インストールするパッケージを依存関係のツリー状に出力します
\end{itemize}

-tが一番重要なところです. これを指定することでこのようにツリー状に出力されます

\begin{commandline}
%  emerge -pqt --quiet-repo-display chromium
[ebuild  N    ] www-client/chromium-20.0.1132.21 
...
[nomerge      ] www-client/chromium-20.0.1132.21 
[ebuild  N    ]  dev-libs/nss-3.13.4 
[ebuild  N    ]   dev-libs/nspr-4.9 
[ebuild  N    ]    sys-devel/autoconf-2.13 
[ebuild  N    ]     sys-devel/autoconf-wrapper-12 
[ebuild  N    ]   dev-db/sqlite-3.7.12.1 
...
\end{commandline}

このツリーの浅いところからDebianのパッケージへとマップしていきます. 浅
いところからマップしていくことで, できるだけ多くの依存解決をDebian側に
おまかせします. つまり, たとえばここで dev-libs/nsprをDebian側でインス
トールすることに成功すればこのツリーを

\begin{commandline}
[ebuild  N    ] www-client/chromium-20.0.1132.21 
...
[nomerge      ] www-client/chromium-20.0.1132.21 
[ebuild  N    ]  dev-libs/nss-3.13.4 
[ebuild  N    ]   dev-db/sqlite-3.7.12.1 
...
\end{commandline}

ここまで一気に縮小することができるというわけです. 

\subsubsection{GentooからDebianへのマップ}

Gentooのパッケージ名からDebianのパッケージ名へのマッピングを行ないます.
Gentooのパッケージ名にはカテゴリがついていますが, Debianの方にはそれが
ないので, とりあえず外してしまいます. そして, 以下の順番で探索をかけます. 

\begin{itemize}
\item libパッケージ名-dev
\item パッケージ名-dev
\item パッケージ名
\end{itemize}

Gentooのパッケージでは一般にDebianの*-devに入るようなものがインストール
されているので, *-devを優先してインストールするようにしています. 

また, dev-rubyカテゴリのものにはruby-をパッケージ名につけるなどの工夫を
したり, どうしてもこれでマップできないものは明示的にマッピングを書くな
どの対処もしています.

\subsubsection{DebianからGentooへのマップ}

こうしてDebianへとパッケージをインストールできたら, インストールできた
パッケージのバージョンを取得してGentooのパッケージ名へのマップをしてい
きます. これは単純にdpkg -l ...の結果を使うだけですね. 現状Debianの仮想
パッケージから選択される実際のパッケージのバージョンをとれず, うまくマッ
プできていません….

\subsubsection{実行サンプル}

これらのアイデアを実装したのがapt-emergeスクリプトになります. このスク
リプトは基本的に上記のemergeが使えるようになった段階で使えるようになっ
ていますが, 一部のパッケージはGentooのコア部分に大きく食いこんでいるの
でそれらはGentooで入れておかないといけません. また, Debianのmultiarchに
対応するようにCFLAGS/LDFLAGSを調整します.
 
\begin{commandline}
% vi $EPREFIX/etc/make.conf
CFLAGS="-O2 -I/usr/include/x86_64-linux-gnu"
LDFLAGS="${LDFLAGS} -L/usr/lib/x86_64-linux-gnu"
% FEATURES="-collision-protect" emerge -avg1 --nodeps bash eselect eselect-python python portage libffi
\end{commandline}

これでapt-emergeが動くようになるはずです. apt-emergeを動かすと自動的に必要なパッケージをapt-getに渡し, 可能な限りの依存を解決してから, emergeに処理を渡します.

例としてTwitterクライアント
mikutter\footnote{http://mikutter.hachune.net}をapt-emergeでインストー
ルしてみましょう. これはRubyとRuby/Gtk2などを使ったパッケージなので, 普
通にemergeするだけであれば, gtkなど大量にビルドされるはずです
が……apt-emerge mikutter後にGentoo側になにがインストールされているかを
リストアップしてみましょう(仮想パッケージは除いてあります)

\begin{commandline}
% eix -I -c |grep -v virtual
[I] app-admin/eselect (1.3.1@06/03/2012): Gentoo's multi-purpose configuration and management tool
[I] app-admin/eselect-python (20111108@06/03/2012): Eselect module for management of multiple Python versions
[I] app-admin/python-updater (0.10-r2@06/04/2012): Script used to reinstall Python packages after changing of active Python versions
[U] app-shells/bash (4.2_p28@06/03/2012 -> 4.2_p29): The standard GNU Bourne again shell
[I] app-shells/push (1.5@06/04/2012): A POSIX shell function to treat a variable like an array, quoting args.
[I] dev-lang/python (2.7.3-r2(2.7)@06/04/2012): Python is an interpreted, interactive, object-oriented programming language.
[I] dev-libs/libffi (3.0.11@06/04/2012): a portable, high level programming interface to various calling conventions.
[I] net-misc/mikutter (9999@06/04/2012): mikutter is simple, powerful and moeful twitter client
[I] sys-apps/baselayout-prefix (1.12.14@06/04/2012): Baselayout for Gentoo Prefix installs
[I] sys-apps/portage (2.2.01.20430@06/04/2012): Prefix branch of the Portage Package Manager, used in Gentoo Prefix
[I] sys-apps/tcp-wrappers (7.6.22@06/04/2012): TCP Wrappers
[I] sys-devel/gnuconfig (20120116@06/04/2012): Updated config.sub and config.guess file from GNU
\end{commandline}

ご覧のように10個程度しかGentoo側にはインストールされていませんが,
mikutter-9999 (SVN trunkのバージョン)がしっかりとインストールされています.

\subsection{これから}

apt-emergeのスクリプトはまだコンセプトが実装されただけで, いろんな部分
がad-hocになっています. よりDebianのパッケージ名とGentooのパッケージ名
とのマッピングの推測を賢くしたり, 必要な固定マップデータを拡充し,
Debianのvirtualパッケージをうまく処理したりするなど, より使いやすいビル
ドシステムを作れればと思います. 自分自身Debianに深く知識を持っているわ
けではないので, もしかするともっと効率のよい実装もあるかもしれません….
もし興味を持っていただければ, 開発参加・アドバイスしていただけましたら
幸いです. 

\dancersection{IPython notebookとその周辺}{本庄弘典}
\label{sec:ipython-notebook}

\subsection{はじめに}

最近ipythonのqtconsoleでコンソール上にグラフを描画しているスクリーンショットを見る機会があり、
ちょっとかっこいいかなとロクに使ったことがないPythonを使い始めました。
今回はipython qtconsoleを使用したグラフの描画から、
Mathmatica notebooksのようなWebベースの数式処理システムipython notebookをPython初心者の視点で紹介してみたいと思います。

\subsection{IPython}

ipythonはFernando Perez氏によって作成されたPythonのインタラクティブシェルで、
現在の最新リリースバージョンは0.12.1です。
Pythonはそれ自体でインタラクティブシェルの機能を持っていますが、
ipythonはPythonシェルと比較して次の特徴を持っています。

\begin{itemize}
 \item terminalでの使用に加えQt等を用いたグラフィカルなコンソールが使用可能
 \item コード補完
 \item シンタックスハイライト
 \item 並列コンピューティングが可能
 \item Webベースのnotebook(ipython 0.12から)
\end{itemize}

Pythonシェルとipythonは次の図のように、
プロンプト等に違いがあります。

\begin{figure*}[b]
  \begin{tabular}{cc}
    \begin{minipage}[b]{0.5\textwidth}
      \includegraphics[width=1.0\hsize]{images/ipython-pythonshell.png}
      \label{pythonshell}
    \end{minipage}
    \begin{minipage}[b]{0.5\textwidth}
      \includegraphics[width=1.0\hsize]{images/ipython-terminal.png}
      \label{ipython}
    \end{minipage}
  \end{tabular}
  \caption{pythonシェルとipythonの違い}
\end{figure*}

\subsection{IPython qtconsole}

ipythopnにqtconsoleオプションを指定して実行することにより、
GUI環境でのipythonが起動します。
またこの環境で--pylab inlineを指定して起動することで、
コンソール内にグラフを表示させることが可能となります。

\begin{commandline}
$ ipython qtconsole --pylab matplotlib
\end{commandline}

この環境では前述のグラフ表示に加え、
複数行をまとめて扱うコマンドの履歴などが使用できます。
グラフを描画すると次のように表示されます。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.6\hsize]{images/ipython-mandelbrotset.png}
  \end{center}
  \caption{qtconsoleでマンデルブロ集合}
  \label{fig:ipython-qtconsole}
\end{figure}

testingでのipython qtconsoleおよびmatplotlibは次のコマンドでインストール出来ます。

\begin{commandline}
$ sudo aptitude install ipython-qtconsole python-matplotlib
\end{commandline}

またsqueezeはbackportsを使用してインストールを行いました。
まず/etc/apt/sources.listに次の行を追加し、

\begin{commandline}
deb http://backports.debian.org/debian-backports squeeze-backports main
\end{commandline}

aptitude update \&\& aptitude upgradeを実行した後、
次のコマンドでインストールします。

\begin{commandline}
$ sudo aptitude install python-setuptools python2.6-dev ncurses-dev libzmq-dev python-pygments python-matplotlib pyqt4-dev-tools
\end{commandline}

パッケージのインストール後、
pythonのeasy\_installコマンドを使用してipythonをインストールします。

\begin{commandline}
$ sudo easy_install readline pyzmq ipython
\end{commandline}

\subsection{IPython notebook}

ipython notebookはWebベースの数式処理システムで、
次の機能を備えています。

\begin{itemize}
 \item Pythonコードの実行と結果の表示
 \item Markdownによるマークアップ可能なノート
 \item MathJaxによる \TeX 形式での数式の記述
\end{itemize}

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.80\hsize]{images/ipython-gacha.png}
  \end{center}
  \caption{ipython notebookの使用例}
  \label{fig:ipython-gacha}
\end{figure}

testingには次のコマンドでインストール可能です。

\begin{commandline}
$ sudo aptitude install ipython-notebook python-matplotlib python-tornado
\end{commandline}

squeezeはqtconsoleと同様にbackportsを使用します。
ここではsqueezeのiceweaselが古いためこちらもapt lineに追加しています。

\begin{commandline}
deb http://backports.debian.org/debian-backports squeeze-backports main
deb http://mozilla.debian.net/ squeeze-backports iceweasel-release
\end{commandline}

aptitude update \&\& aptitude upgradeを実行した後、
インストールは次のコマンドで行いました。

\begin{commandline}
$ sudo aptitude install python-setuptools python2.6-dev ncurses-dev libzmq-dev python-pygments python-matplotlib
\end{commandline}

パッケージをインストールした後、
pythonのeasy\_installコマンドを使用してipythonをインストールします。

\begin{commandline}
$ sudo easy_install readline pyzmq ipython tornado
\end{commandline}

またこのままではMathJaxがCDNを指しているので、
pythonを管理者権限で実行しローカルにインストールします。

\begin{commandline}
from IPython.external.mathjax import install_mathjax
install_mathjax()
\end{commandline}

squeezeのウェブブラウザはどれも古く、
Web Socketの問題からnotebookでは使えません。
そこで最新版のiceweaselを導入します。
ipython notebookは起動時にデフォルトブラウザを起動するため、
導入後はiceweaselをデフォルトブラウザに指定してください。

\begin{commandline}
$ sudo aptitude install -t squeeze-backports iceweasel
\end{commandline}

ipython notebookは次のコマンドで起動します。

\begin{commandline}
$ ipython notebook --pylab inline
\end{commandline}

他のマシンから接続を行う場合、
ブラウザを起動させないためオプション''--no-browser''を、
アクセス許可を与えるためnotebookを起動させるマシンのipアドレスをオプション''--ip''で指定します。

\begin{commandline}
$ ipython notebook --pylab inline --no-browser --ip 192.168.1.40
\end{commandline}

初回起動時には次のような画面が表示されます。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.67\hsize]{images/ipython-notebook.png}
  \end{center}
  \caption{ipython notebookを起動した直後}
  \label{fig:ipython-notebook}
\end{figure}

「New Notebook」ボタンをクリックすることで新規ノートブックが作成され、
空のノートブックがブラウザに表示されます。
MarkdownとPythonのCellはCtrl-m mおよびCtrl-m cで切り替えることができ、
その他コマンドの詳細はCtrl-m hで表示されます。

作成されたノートブックは表示されているディレクトリ(ここでは/home/hiro/)に''$<$ ノートブックのタイトル$>$.ipynb''というファイル名で保存されます。
このファイルの中身はJSON形式となっています。

\subsection{最後に}

今回はipython qtconsoleおよびnotebookをDebianで使用する方法を紹介しました。
Ubuntu 12.04ではどちらもパッケージとして提供されているため、
wheezyではインストール作業が簡単になると思われます。
これを機会にipythonを活用していただければ幸いです。

\dancersection{Linux-PAMの設定について}{西山和広}
\label{sec-1}
\subsection{Introduction}
\label{sec-1-1}
\subsubsection{PAM とは何か?}
\label{sec-1-1-1}

Linux-PAM (Pluggable Authentication Modules for Linux) とは、アプリケーションがユーザーをどう認証するかをローカルシステムの管理者が設定できるようにするための共有ライブラリ一式です。

PAM のおかげで、アプリケーションをコンパイルしなおさなくても、認証方法を変更したり、権限の付与の仕方を変更したりできるようになっています。
\subsubsection{NSS とは何か?}
\label{sec-1-1-2}

PAM と関係の深いライブラリとして NSS (Name Service Switch) があります。
NSS はユーザー名とユーザー ID との変換をしたり、ホスト名と IP アドレスとの変換をしたりするときに使われます。
\subsubsection{PAM と NSS との違い}
\label{sec-1-1-3}

PAM は認証部分のみなので、基本的にはログインやログアウトのときとパスワード変更に関係します。 (厳密にはアプリケーション次第です。)

ログイン中に \verb~id~ コマンドで表示されるユーザーIDとユーザー名の対応 \footnote{グループIDとグループ名も同様です。 } や \verb~ls -l~ でファイルシステムに記録されているユーザーIDからユーザー名への変換 \footnote{ファイルシステムには所有者はユーザーIDで記録されています。そのため、たとえばユーザーを削除して存在しないユーザーのファイルがある場合には、ユーザー名への変換が出来ないので数字で表示されます。 } などは \verb~/etc/nsswitch.conf~ で設定する NSS の機能になります。
\subsubsection{PAM の設定}
\label{sec-1-1-4}

PAM は設定ファイルに実行したいモジュールを並べておいて、それを順番に実行していくようなものだと思えば良いでしょう。

たとえば
\begin{itemize}
\item \verb~/etc/passwd~ などのローカルファイルでの認証
\begin{itemize}
\item 成功すれば認証成功をアプリケーションに返す
\item 失敗すれば次へ
\end{itemize}
\item LDAP での認証
\begin{itemize}
\item 成功すれば認証成功をアプリケーションに返す
\item 失敗すれば次へ
\end{itemize}
\item 次がないので認証失敗をアプリケーションに返す
\end{itemize}
という動作をします。
\subsection{ファイル配置}
\label{sec-1-2}
\subsubsection{設定ファイル}
\label{sec-1-2-1}

\verb~/etc/pam.d/~ の下にアプリケーションごとの設定ファイルがあります。
以下はその例です。


\begin{commandline}
% ls /etc/pam.d
atd       chsh            common-password                cron      other   su
chfn      common-account  common-session                 login     passwd  sudo
chpasswd  common-auth     common-session-noninteractive  newusers  sshd
\end{commandline}

\begin{itemize}
\item どの設定ファイルがどのアプリケーションのものなのかはファイル名から推測できます。
\item ない場合は \verb~other~ が使われます。
\item それぞれの中から \verb~@include~ で \verb~common-*~ で共通の設定を使うようになっています。
\end{itemize}

\verb~/etc/pam.d/~ がない場合は \verb~/etc/pam.conf~ が使われると \verb~/etc/pam.conf~ の中のコメントに書いてありますが、歴史的なもので最近の Linux では使われていません。
\subsubsection{モジュール}
\label{sec-1-2-2}

以下は PAM モジュールの例です。


\begin{commandline}
% ls /lib/x86_64-linux-gnu/security
pam_access.so     pam_keyinit.so    pam_nologin.so     pam_tally.so
pam_debug.so      pam_lastlog.so    pam_permit.so      pam_tally2.so
pam_deny.so       pam_ldap.so       pam_pwhistory.so   pam_time.so
pam_echo.so       pam_limits.so     pam_rhosts.so      pam_timestamp.so
pam_env.so        pam_listfile.so   pam_rootok.so      pam_umask.so
pam_exec.so       pam_localuser.so  pam_securetty.so   pam_unix.so
pam_faildelay.so  pam_loginuid.so   pam_selinux.so     pam_userdb.so
pam_filter.so     pam_mail.so       pam_sepermit.so    pam_warn.so
pam_ftp.so        pam_mkhomedir.so  pam_shells.so      pam_wheel.so
pam_group.so      pam_motd.so       pam_stress.so      pam_xauth.so
pam_issue.so      pam_namespace.so  pam_succeed_if.so
\end{commandline}

\begin{itemize}
\item 設定ファイルに書かれる \verb~pam_unix.so~ などは \verb~dlopen(3)~ で動的に読み込まれます。
\item そのため PAM の認証を使っているプログラムを入れた chroot 環境を作るときには気をつける必要があります。
\item \verb~squeeze~ までは \verb~/lib/security/~ や \verb~/lib64/security/~ にあります。
\item \verb~multiarch~ 対応で最近は \verb~/lib/x86_64-linux-gnu/security/~ などの \verb~/lib/<triplet>/security/~ にあります。
  上記の例は wheezy (testing) なので \verb~/lib/security/~ ではなく
  \verb~/lib/x86_64-linux-gnu/security/~ になっています。
\end{itemize}
\subsection{設定ファイルの書式}
\label{sec-1-3}

設定ファイルの例を載せておきます。(一部省略)

\begin{commandline}
% egrep '^[^#]' /etc/pam.d/cron
@include common-auth
session       required   pam_env.so
session       required   pam_env.so envfile=/etc/default/locale
@include common-account
@include common-session-noninteractive
session    required   pam_limits.so
\end{commandline}

\begin{itemize}
\item 設定ファイルには以下の項目を指定します。詳細は後述します。
\begin{description}
\item[\verb~service~] アプリケーションに対応する名前
\item[\verb~type~] PAM の分類
\item[\verb~control~] 動作指定
\item[\verb~modules-path~] PAM モジュールへのパス
\item[\verb~module-arguments~] PAM モジュールの引数
\end{description}
\item \verb~#~ から行末まではコメントになります。
\item \verb~\~ が改行 (\verb~<LF>~) の直前にあると継続行になります。
\item \verb~/etc/pam.conf~ では「 \verb~service type control module-path module-arguments~ 」という書式で設定します。( \verb~service~, \verb~type~, \verb~control~ の大文字小文字は無視されます。)
\item \verb~/etc/pam.d/~ では \verb~service~ がファイル名 (必ず小文字) になります。
\item 残りの「 \verb~type control module-path module-arguments~ 」がファイルの内容になります。
\end{itemize}
\subsubsection{service}
\label{sec-1-3-1}

\begin{itemize}
\item \verb~service~ は具体的には \verb~login~ や \verb~su~ になります。
\item \verb~other~ という \verb~service~ 名はデフォルト設定用として予約されています。
\item Debian では \verb~common-~ で始まる名前のファイルが共通設定用のファイルになっていて、他の設定ファイルから \verb~@include~ で読み込まれています。
\end{itemize}
\subsubsection{type}
\label{sec-1-3-2}

\begin{description}
\item[account] 認証以外のアカウント管理に使われます。たとえば昼間だけログインできるようにしたり、 \verb~nologin~ ファイルがあるときは一般ユーザーにログインさせないようにしたりできます。
\item[auth] アプリケーションにパスワード入力を要求するなどの方法でユーザー認証をします。グループ権限の付与などの機能もあります。
\item[password] パスワード変更などの認証トークン変更機能を提供します。
\item[session] サービス利用の前後に何かをするモジュールタイプです。ログを取ったり、ディレクトリをマウントしたり、 \verb~/etc/motd~ を表示したり、環境変数を設定したりできます。
\item[\verb~@include~] Debian ではここに \verb~@include~ を指定することで別のファイルを読み込めるようになっています。
\end{description}
\subsubsection{control}
\label{sec-1-3-3}

PAM モジュールを実行してその結果、どうするのかの設定です。
詳細については後述します。
\subsubsection{module-path}
\label{sec-1-3-4}

PAM モジュールのファイルへのパスを絶対パスかデフォルトのモジュールの置き場所である \verb~/lib/security/~ などからの相対パスで指定します。
\subsubsection{module-arguments}
\label{sec-1-3-5}

スペース区切りでモジュールへの引数を指定します。
スペースを含む引数を指定する場合は以下の例のように \verb~[]~ でくくります。


\begin{commandline}
squid auth required pam_mysql.so user=passwd_query passwd=mada \
      db=eminence [query=select user_name from internet_service \
      where user_name='%u' and password=PASSWORD('%p') and \
      service='web_proxy']
\end{commandline}

\verb~]~ を含めたい場合は \verb~\]~ と指定します。
つまり以下のようになります。


\begin{commandline}
[..[..\]..]    -->   ..[..]..
\end{commandline}
\subsection{control の設定について}
\label{sec-1-4}
\subsubsection{PAM の内部状態}
\label{sec-1-4-1}

PAM はモジュールを実行していくときに内部的に
\begin{itemize}
\item 初期状態
\item 成功状態
\item 失敗状態
\end{itemize}
の3つの状態があり、最終的に成功状態なら成功をアプリケーションに返し、そうでなければ失敗をアプリケーションに返します。
(初期状態のままのときも失敗を返します。)
\subsubsection{control の省略形式}
\label{sec-1-4-2}

control の指定には、省略した形式として以下のものがあります。

\begin{description}
\item[required] 成功しても失敗しても続きを実行してから結果を返します。失敗状態以外で成功した場合は成功状態にします。失敗した場合は失敗状態にします。
\item[requisite] 失敗した場合は失敗状態にして、すぐにアプリケーションに失敗を返します。失敗状態以外で成功した場合は成功状態にします。
\item[sufficient] 失敗状態以外で成功した場合は、すぐにアプリケーションに成功を返します。失敗は無視して続きを実行します。
\item[optional] 成功か失敗かは気にせず実行したいモジュールに使います。成功か失敗かは他のモジュールがないときだけ影響します。
\item[include, substack] 省略形式ではありませんが、このような指定も出来ます。しかし Debian では上述の \verb~@include~ が使われていて、これらは普通は使われていないのと、内部状態の説明が複雑になるため省略します。
\end{description}
\subsubsection{control の省略しない形式}
\label{sec-1-4-3}

もっと複雑な形式として以下のものがあります。


\begin{commandline}
[value1=action1 value2=action2 ...]
\end{commandline}
\subsubsection{control の value}
\label{sec-1-4-4}

\verb~valueN~ は PAM モジュールからの返値で \verb~actionN~ はその返値のときにどうするかという設定です。

\verb~valueN~ には \verb~success~, \verb~open_err~, \verb~symbol_err~, \verb~service_err~, \verb~system_err~, \verb~buf_err~, \verb~perm_denied~, \verb~auth_err~, \verb~cred_insufficient~, \verb~authinfo_unavail~, \verb~user_unknown~, \verb~maxtries~, \verb~new_authtok_reqd~, \verb~acct_expired~, \verb~session_err~, \verb~cred_unavail~, \verb~cred_expired~, \verb~cred_err~, \verb~no_module_data~, \verb~conv_err~, \verb~authtok_err~, \verb~authtok_recover_err~, \verb~authtok_lock_busy~, \verb~authtok_disable_aging~, \verb~try_again~, \verb~ignore~, \verb~abort~, \verb~authtok_expired~, \verb~module_unknown~, \verb~bad_item~, \verb~conv_again~, \verb~incomplete~, \verb~default~ が指定できます。
\verb~default~ は名前からわかる通り明示的に \verb~valueN~ に指定されなかったときのデフォルト指定です。

\verb~valueN~ に指定できる値の完全なリストは \verb~libpam0g-dev~ パッケージをインストールして
\begin{itemize}
\item \verb~/usr/include/security/_pam_types.h~
\end{itemize}
を参照してください。
\subsubsection{control の action}
\label{sec-1-4-5}

\verb~actionN~ に指定できるものは以下の通りです。

\begin{description}
\item[ignore] 無視します。モジュールの返値はアプリケーションに返す値には影響しません。
\item[bad] 失敗状態にします。
\item[die] 失敗します。失敗状態にして、すぐにアプリケーションに失敗を返します。
\item[ok] 失敗状態以外なら成功状態にします。すでに失敗状態のときは失敗状態のままです。
\item[done] 失敗状態以外なら成功状態にして、すぐにアプリケーションに成功を返します。すでに失敗状態のときは失敗状態のままです。
\item[N (1以上の整数)] 次の N 個のモジュールを実行せずに飛ばします。
\item[reset] 内部状態を初期状態に戻します。
\end{description}
\subsubsection{省略形の展開}
\label{sec-1-4-6}

省略形は \verb~[...]~ の書式で書くと以下のようになります。

\begin{description}
\item[required] \verb~[success=ok new_authtok_reqd=ok ignore=ignore default=bad]~
\item[requisite] \verb~[success=ok new_authtok_reqd=ok ignore=ignore default=die]~
\item[sufficient] \verb~[success=done new_authtok_reqd=done default=ignore]~
\item[optional] \verb~[success=ok new_authtok_reqd=ok default=ignore]~
\end{description}
\subsection{PAM 設定フレームワーク}
\label{sec-1-5}

Redhat 系 Linux には以前から PAM や NSS の自動設定用のコマンドとして \verb~authconfig~ があります。
しかし、昔の Debian にはそういうフレームワークはありませんでした。

Ubuntu では、そのようなフレームワークとして \verb~auth-client-config~ が使われるようになりました。
その後 \verb~pam-auth-update~ が使われるように変わりました。
そして Debian にも \verb~pam-auth-update~ が入って今は Debian でも Ubuntu でも \verb~pam-auth-update~ が標準の PAM の設定用フレームワークとして使われています。\footnote{Debian にはありませんが、 Ubuntu には \verb~auth-client-config~ パッケージはまだ存在しています。 \verb~pam-auth-update~ は PAM の設定のみなので、もしかすると NSS の設定には使われているのかもしれません。(使っていないので詳細は不明です。) }
\subsubsection{pam-auth-update}
\label{sec-1-5-1}

\verb~pam-auth-update~ コマンドは \verb~libpam-runtime~ パッケージに入っています。
PAM モジュールパッケージで \verb~/usr/share/pam-configs~ の中にプロファイルがインストールされます。
\verb~pam-auth-update~ コマンドは、そのプロファイルを元に \verb~/etc/pam.d/common-*~ ファイルを更新します。
\subsection{設定ファイルの例}
\label{sec-1-6}

\begin{itemize}
\item \verb~pam-auth-update~ で生成された設定ファイルの一部と sshd の設定を例として説明をします。
\end{itemize}
\subsubsection{/etc/pam.d/common-auth}
\label{sec-1-6-1}

common-auth は認証の共通処理の設定ファイルです。
\begin{enumerate}
\item まず最初に ``Primary'' block のモジュールを \verb~pam_unix.so~, \verb~pam_ldap.so~ と順番に試して、どこかで成功したら \verb~pam_permit.so~ まで飛ばして成功状態にします。
\item すべて失敗した場合は fallback の \verb~pam_deny.so~ の行で必ず失敗して、そのままアプリケーションに認証失敗を返します。
\item 途中で成功して \verb~pam_permit.so~ の行に飛んできた場合は、そのまま続きの行を実行していきます。
\item \verb~@include~ 元のファイルで続きの処理を用意していることもあるので \verb~sufficient~ で成功をすぐに返してしまうことは避けて \verb~success=N~ で飛ばして \verb~pam_permit.so~ で成功状態にするという手間をかけているようです。
\item \verb~pam_ldap.so~ の \verb~use_first_pass~ は \verb~pam_unix.so~ の認証のときに入力されたパスワードを使って \verb~pam_ldap.so~ の認証も試すという意味です。 \verb~use_first_pass~ がないと \verb~pam_unix.so~ でパスワード入力が要求されて、さらに \verb~pam_ldap.so~ でもパスワード入力を要求されるということになります。(プロファイルで Auth-Initial と Auth にわかれているのはそういう設定を使いわけられるようにするためのようです。)
\end{enumerate}

\begin{commandline}
# here are the per-package modules (the "Primary" block)
auth    [success=2 default=ignore]      pam_unix.so nullok_secure
auth    [success=1 default=ignore]      pam_ldap.so minimum_uid=1000 use_first_pass
# here's the fallback if no module succeeds
auth    requisite                       pam_deny.so
# prime the stack with a positive return value if there isn't one already;
# this avoids us returning an error just because nothing sets a success code
# since the modules above will each just jump around
auth    required                        pam_permit.so
# and here are more per-package modules (the "Additional" block)
auth    optional                        pam_cap.so
# end of pam-auth-update config
\end{commandline}
\subsubsection{/etc/pam.d/common-session}
\label{sec-1-6-2}

\begin{itemize}
\item この例の common-session では ``Primary'' block にモジュールがないために \verb~pam_permit.so~ でいきなり \verb~pam_deny.so~ を飛びこえるようになっています。
\item その後 \verb~pam_unix.so~ と \verb~pam_ldap.so~ でも何か追加の処理をして \verb~pam_tmpdir.so~ で環境変数 TMPDIR などを設定しています。
\end{itemize}

\begin{commandline}
# here are the per-package modules (the "Primary" block)
session [default=1]                     pam_permit.so
# here's the fallback if no module succeeds
session requisite                       pam_deny.so
# prime the stack with a positive return value if there isn't one already;
# this avoids us returning an error just because nothing sets a success code
# since the modules above will each just jump around
session required                        pam_permit.so
# and here are more per-package modules (the "Additional" block)
session required        pam_unix.so
session [success=ok default=ignore]     pam_ldap.so minimum_uid=1000
session optional pam_tmpdir.so
# end of pam-auth-update config
\end{commandline}
\subsubsection{/etc/pam.d/sshd}
\label{sec-1-6-3}

\begin{enumerate}
\item まず \verb~pam_env.so~ で環境変数を設定しています。
\item \verb~#~ で始まる行だけでなく、行の途中の \verb~#~ 以降もコメントです。
\item 2個目の \verb~pam_env.so~ で \verb~/etc/default/locale~ を読み込んでいます。 \footnote{余談ですが、昔の Debian では \verb~/etc/default/locale~ は存在しなくて、アップグレードでも自動で作成はされず、ログをみるとエラーが出ていたということがあり、そのときは自分で \verb~/etc/default/locale~ を作成しました。今は \verb~update-locale~ というコマンドで更新するとチェックもしてくれて良い感じになるようです。 }
\item \verb~pam_nologin.so~ では \verb~nologin~ ファイルがあるときにログインを認可しないようにしています。
\item session では \verb~pam_motd.so~ で \verb~/etc/motd~ の表示をしています。最近の Debian や Ubuntu の \verb~pam_motd.so~ では \verb~/etc/update-motd.d~ があれば表示前に内容が更新されるようになっています。 Ubuntu のサーバーに ssh でログインしたときにいろいろな情報がでるのはそのためです。 Ubuntu の場合は update-notifier-common を入れておくとパッケージの更新や再起動が必要かどうかが ssh などでのログイン時に出るようになるのでおすすめです。 Debian では \verb~/etc/update-motd.d~ のファイルが入らない ( \href{http://bugs.debian.org/580286}{http://bugs.debian.org/580286} ) ため、自動では出ません。
\item 他にはメールボックスの状態を表示したり、リソース制限を反映したりしているようです。
\end{enumerate}

\begin{commandline}
# PAM configuration for the Secure Shell service

# Read environment variables from /etc/environment and
# /etc/security/pam_env.conf.
auth       required     pam_env.so # [1]
# In Debian 4.0 (etch), locale-related environment variables were moved to
# /etc/default/locale, so read that as well.
auth       required     pam_env.so envfile=/etc/default/locale

# Standard Un*x authentication.
@include common-auth

# Disallow non-root logins when /etc/nologin exists.
account    required     pam_nologin.so

# Uncomment and edit /etc/security/access.conf if you need to set complex
# access limits that are hard to express in sshd_config.
# account  required     pam_access.so

# Standard Un*x authorization.
@include common-account

# Standard Un*x session setup and teardown.
@include common-session

# Print the message of the day upon successful login.
session    optional     pam_motd.so # [1]

# Print the status of the user's mailbox upon successful login.
session    optional     pam_mail.so standard noenv # [1]

# Set up user limits from /etc/security/limits.conf.
session    required     pam_limits.so

# Set up SELinux capabilities (need modified pam)
# session  required     pam_selinux.so multiple

# Standard Un*x password updating.
@include common-password
\end{commandline}
\subsection{設定変更時の注意事項}
\label{sec-1-7}

設定を変更するときは root 権限のシェルを開いたままにしておくことをお勧めします。
もし設定を間違えてしまうと sudo も su もコンソールからの root でのログインも出来なくなって困ることになります。

ただし \verb~pam-auth-update~ を使ってパッケージでインストールされた設定の有効無効を切り替えるだけの場合は問題が起きる可能性は低いので、そこまでしなくても普通は大丈夫だと思います。
\subsection{参考文献}
\label{sec-1-8}

\begin{itemize}
\item \href{http://linux-pam.org/Linux-PAM-html/Linux-PAM_SAG.html}{http://linux-pam.org/Linux-PAM-html/Linux-PAM\_SAG.html} The Linux-PAM System Administrators' Guide Version 1.1.2, 31. August 2010
\item \href{http://archive.linux.or.jp/JF/JFdocs/User-Authentication-HOWTO/}{http://archive.linux.or.jp/JF/JFdocs/User-Authentication-HOWTO/} User Authentication HOWTO 2000/05/02
\item \href{https://wiki.ubuntu.com/PAMConfigFrameworkSpec}{https://wiki.ubuntu.com/PAMConfigFrameworkSpec} PAMConfigFrameworkSpec - Ubuntu Wiki
\item \href{https://wiki.ubuntu.com/AuthClientConfig}{https://wiki.ubuntu.com/AuthClientConfig} AuthClientConfig - Ubuntu Wiki
\end{itemize}


\dancersection{Debianでもマルチタッチデバイスを使う}{赤部 晃一}
\label{sec:your-label}

\subsection{はじめに}

近年、スマートフォンやタブレット端末などのマルチタッチスクリーンを搭載したデバイスが、あらゆる場面で注目を集めています。この社会情勢を受け、派生ディストリビューションのUbuntuでは、バージョン10.10以降でタッチデバイス向けのアプリケーションの開発をサポートするuTouchが提供されるようになりました。今年の4月には、Debianにおいてもタッチデバイスのサポートが強化されたGTK+3.4やX server 1.12が提供されるようになり、今後Linuxデスクトップにおいてもマルチタッチ操作対応のアプリケーションが増えることが期待されます。\footnote{とは言っても、デスクトップ環境では未だにマウス操作が主流であり、タッチアプリの普及にはまだまだ時間がかかりそうです。ちなみに筆者はマウスをほとんど使わずに、ペンタブレットを常用しています。}

ここでは、まずUbuntuのuTouchを紹介し、DebianにuTouchを導入します。次に、Toucheggというソフトウェアを用いることで、タッチジェスチャーを使って様々な操作ができるようにします。

\subsection{uTouchの概要}

\subsubsection{uTouchの目的}

uTouchは、アプリケーションにおけるタッチ入力処理をサポートするためのフレームワークです。例えば、GTK+で開発中のアプリケーションを、2本の指を使った回転操作に対応させる場合を考えます。GTK+3.4に搭載されたタッチイベントを使って実装させる場合、タッチしている指の本数や、それぞれの指の動きなどを全てトレースし、指同士の位置関係や相対速度を計算した上で、それが2本指による回転操作である事を判定させる処理を記述する必要があります。しかしそれは言葉通り労力のかかる作業であり、複数のジェスチャー（タップ、スワイプ、ピンチ、回転など）について一つずつ記述していてはキリがありません。

そこで登場するライブラリーがuTouchです。uTouchはいくつかのタッチジェスチャーを自動的に認識し、それぞれのジェスチャーについてイベントを発生させるため、マルチタッチ操作対応のアプリケーションを作成するときの工数を大幅に減らすことができます。

Ubuntu標準のデスクトップインターフェイスであるUnityでは、3本指ドラッグでウィンドウの移動、4本指タップでメインメニューの表示ができます。\footnote{対応しているジェスチャーはUbuntu Wikiで調べられます。\url{https://wiki.ubuntu.com/Multitouch\#Supported_Gestures}}

\subsubsection{uTouch周りの依存関係}

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.3\hsize]{images/utouch-depends.eps}
  \end{center}
  \caption{uTouch周りの依存関係}
  \label{fig:image01}
\end{figure}
図\ref{fig:image01}にuTouch周りの依存関係を示します。上のパッケージが下のパッケージに依存しており、色付きの部分がuTouchの基幹のパッケージです。まずutouch-evemuによって、デバイス毎に異なるフォーマットのタッチデータを一つの決まったフォーマットに変換し、イベントデバイスをエミュレートすることで変換結果を出力します。次にutouch-frameによってutouch-evemuが出力する情報を扱いやすい形に変換します。このタッチデータを元にutouch-grailがジェスチャーを認識します。最後にXサーバーの拡張機能として動作するutouch-geisによって、ジェスチャー情報がイベントなどの形でアプリケーションに提供されます。

GTK+やQtを使ったアプリケーションでタッチジェスチャーを利用する場合、通常はutouch-geisをそのまま使うのではなく、GUIツールキット向けのライブラリーを用います。GTK+の場合はlibgrip、Qtの場合はutouch-qmlです。今回扱うToucheggは、タッチジェスチャーがサポートされていないソフトウェアでタッチ操作ができるようにするためのソフトウェアです。

\subsection{uTouchをDebianに取り込む}

\subsubsection{dgetを使ったソースパッケージのダウンロード}

では早速、uTouchをDebianに取り込んでみましょう。まず、dgetコマンドを使ってlaunchpadからUbuntuのソースパッケージをダウンロードします。私の場合はuTouchのメンテナーへのtrust pathが無いので、dgetに-uオプションを付け、サインの確認を省略します。以下のURLはlaunchpadのサイトで取得できます。\footnote{例えばutouch-evemuのdscファイルの場所は次で調べられます: \url{https://launchpad.net/ubuntu/+source/utouch-evemu}}

\begin{commandline}
% dget -u https://launchpad.net/ubuntu/+archive/primary/+files/utouch-evemu_1.0.9-0ubuntu1.dsc
% dget -u https://launchpad.net/ubuntu/+archive/primary/+files/utouch-frame_2.2.3-0ubuntu1.dsc
% dget -u https://launchpad.net/ubuntu/+archive/primary/+files/utouch-grail_3.0.5-0ubuntu1.dsc
% dget -u https://launchpad.net/ubuntu/+archive/primary/+files/utouch-geis_2.2.9-0ubuntu2.dsc
% dget -u https://launchpad.net/ubuntu/+archive/primary/+files/libgrip_0.3.4-0ubuntu1.dsc
\end{commandline}

\subsubsection{パッケージの修正・ビルド}

まず、前節でダウンロードしたソースパッケージのうち、utouch-geisはそのままではビルドできないため、変更を加える必要があります。まず、utouch-geis-2.2.9/configure.acの次の箇所を変更します。

\begin{commandline}
PKG_CHECK_MODULES([XI2], [x11 xext xi >= 1.3], ,
		  AC_MSG_ERROR([XI2 development libraries not found]))
PKG_CHECK_MODULES([PYTHON], [python >= 2.7]) # ←この行

AX_ENABLE_XI2
\end{commandline}

Debianでは、python.pcではなくpython-2.7.pcを参照する必要があるため、次のように変更します。

\begin{commandline}
PKG_CHECK_MODULES([PYTHON], [python-2.7])
\end{commandline}

パッチを作成する方法はいくつかありますが、ここではdpkg-sourceコマンドを利用します。ファイルを修正後、次のコマンドを実行するとパッチが作成されます。

\begin{commandline}
% cd utouch-geis-2.2.9
% dpkg-source --commit
dpkg-source: info: local changes detected, the modified files are:
 utouch-geis-2.2.9/configure.ac
Enter the desired patch name: 01_fix-pkg-config-path.patch
\end{commandline}

パッチ名を入力して確定すると、パッチ編集画面に移ります。パッチの説明等を入力して保存してください。

それでは、パッケージのビルドです。依存関係上、図\ref{fig:image01}の下のパッケージから順にビルド・インストールしていきます。

ダウンロードしたパッケージに含まれているdebian/controlのMaintainerフィールドを自分の名前に変更し、dchコマンドでバージョン番号を修正し、debuildコマンドを実行してバイナリパッケージを作成します。例えばutouch-evemuの場合は次のコマンドを実行します。

\begin{commandline}
% cd utouch-evemu-1.0.9
% dch -v 1.0.9-1~dgm1 -D unstable # Debianリビジョンを若干上げておく (abbrev of Debian Grand Meeting)
% debuild -uc -us # サイン省略
\end{commandline}

いくつかのパッケージでは、ビルド後にLintianの警告が表示されます。本来は警告が消えるまで修正したいところですが、ここでは割愛します。

\subsection{「Touchegg」を使ってジェスチャーを試す}

\subsubsection{2本指・3本指ジェスチャーの有効化}

2本指、及び3本指のジェスチャーは、右クリックや2本指スクロールなどのシステムの別の設定と競合してしまうため、uTouchでこれらのジェスチャーを認識させたい場合はxinputコマンドで設定を無効化させる必要があります。まず、xinputコマンドを使って接続されているタッチデバイスのIDを確認します。下は筆者の環境でxinput listコマンドを実行した結果です。

\begin{commandline}
% xinput list
+ Virtual core pointer                    	id=2    [master pointer  (3)]
|   → Virtual core XTEST pointer              	id=4    [slave  pointer  (2)]
|   → HID 0566:3107                           	id=11   [slave  pointer  (2)]
|   → Wacom Bamboo 16FG 4x5 Finger            	id=8    [slave  pointer  (2)]
|   → Wacom Bamboo 16FG 4x5 Pen stylus        	id=9    [slave  pointer  (2)]
|   → Wacom Bamboo 16FG 4x5 Pen eraser        	id=12   [slave  pointer  (2)]
+ Virtual core keyboard                   	id=3    [master keyboard (2)]
    → Virtual core XTEST keyboard             	id=5    [slave  keyboard (3)]
    → Power Button                            	id=6    [slave  keyboard (3)]
    → Power Button                            	id=7    [slave  keyboard (3)]
    → HID 0566:3107                           	id=10   [slave  keyboard (3)]
\end{commandline}

筆者が使用しているタッチデバイスは「Wacom Bamboo 16FG 4x5 Finger」に相当するので、IDは8であることが分かります。

ここで以下の3つのコマンドを実行すると、XInputの2本指・3本指に対する設定が無効化されます。\footnote{設定方法の詳細はUbuntu Wikiで調べられます。\url{https://wiki.ubuntu.com/Multitouch/TouchpadSupport}}

\begin{commandline}
% xinput set-prop 8 "Synaptics Tap Action" 0 0 0 0 1 0 0
% xinput set-prop 8 "Synaptics Two-Finger Scrolling" 0 0
% xinput set-prop 8 "Synaptics Click Action" 1 0 0
\end{commandline}


\dancersection{数学ソフトウェア使ってますか？}{濱田龍義}
\label{sec:your-label}

Debian パッケージには「数学」というセクションが存在し、多数の数学ソフト
ウェアが提供されています。 一方で、パッケージには未収録ですが、
数学の研究、教育の現場で使われているフリーソフトウェアが
世界中で開発されています。
2003年頃から、このような数学ソフトウェアをライブCDであるKNOPPIX に収録して紹
介してきたプロジェクトが KNOPPIX/Math です。
KNOPPIX は Debian をベースに、ドイツの Klaus Knopper によって開発が進
められている Live Linux です。当初は CD 起動のみに対応していましたが、
DVD や USB メモリーディスクにも対応し、現在も開発が進められています。
KNOPPIX/Math では、2006年から LiveDVD を採用しました。
また、2012年からは KNOPPIX 以外のシステムの利用も考慮し、
MathLibreとプロジェクト名を変更しています。 
本講演では MathLibre に収録している様々な数学ソフトウェアから、
いくつかを紹介します。

\subsection{数学ソフトウェアの歴史}
我々は、数学を取り扱うもの、また、数学に関連するもの、そういったものすべ
てを数学ソフトウェアと呼んでいます。
%例えば、前の佐々木先生の講演では\TeX{}(\TeX{}Live) が取り上げられました。
Donald E. Knuth によって生み出された組版システム \TeX{}は、
数学を生業とするものにとっては、欠かせない道具であり、
これもまた、数学ソフトウェアの一種です。
一般的に、数式処理ソフトウェア、数値計算ライブラリ、可視化ツールなども
数学ソフトウェアと考えて良いでしょう。

その中で、数式処理ソフトウェアと呼ばれるソフトウェアについて紹介します。
Debian のオフィシャルパッケージの中で、比較的使いやすい物としては、
Maxima が有名です。Maxima の原型は MACSYMA と呼ばれるシステムで、
1960年代に MIT の人工知能研究グループによって開発されました。
1980年代には MACSYMA は商用ソフトウェアとしても流通していましたが、
現在の Maxima は、William Schelter によって GNU Common Lisp 上に実装され
たものを原型に2001年にGPL化され、Maxima と名称を改めて、
フリーソフトウェアとして公開されたものです。
Maximaは、方程式の求解、多項式の因数分解、初等函数の微積分、
行列計算、グラフの描画等に対応しています。中でも積分アルゴリズムの実装につ
いて評価が高いようです。

Debian 上で Maxima を起動するための命令は {\tt maxima} です。
\begin{commandline}
knoppix@Microknoppix:~$ maxima

Maxima 5.26.0 http://maxima.sourceforge.net
using Lisp GNU Common Lisp (GCL) GCL 2.6.7 (a.k.a。GCL)
Distributed under the GNU Public License。See the file COPYING.
Dedicated to the memory of William Schelter.
The function bug_report() provides bug reporting information.
(%i1) integrate(1/(x^3+1),x);
                                         2 x - 1
                       2            atan(-------)
                  log(x  - x + 1)        sqrt(3)    log(x + 1)
(%o1)           - --------------- + ------------- + ----------
                         6             sqrt(3)          3
(%i2) 
\end{commandline}

\subsubsection{Maximaのユーザインターフェース}
コマンドラインからの利用が一番速く手軽ですが、
一般的なグラフィカルユーザインターフェースとしては、
XMaxima ({\tt xmaxima}) や WxMaxima ({\tt wxmaxima}) が存在します。
XMaxima は Tcl/Tk, WxMaxima は WxWidget によって
実装されています。また、Emacs 用に便利なインターフェースとしては
imaxima ({\tt maxima-emacs}) が存在します。
Emacs 上で {\tt M-x imaxima} で起動すると、
数式の計算結果を \TeX{} スタイルに整形された形で出力されます。
また、少し変わったインターフェースとしては GNU TeXmacs ({\tt texmacs})と呼ばれる
科学技術計算用ワードプロセッサが存在します。
こちらも計算結果の出力を整形された形で表示することができます。 

\begin{center}
\begin{figure}[ht]
\begin{minipage}[c]{8cm}
  \includegraphics[width=1\hsize]{images/imaxima.eps}
  \caption{imaxima on Emacs}
  \label{fig:imaxima}
\end{minipage}
\begin{minipage}[c]{8cm}
  \includegraphics[width=1\hsize]{images/texmacs.eps}
  \caption{GNU TeXmacs}
  \label{fig:texmacs}
\end{minipage}
\end{figure}
\end{center}

Maxima と同じく、長い歴史を持つ数式処理システムとしては、Reduce もよく知られ
た存在です。
Reduce もまた、1960年代に開発が始められたシステムですが、こちらは
理論物理学からの要請により開発されました。
Reduce も MACSYMA と同様に1980年代に商品化され、日本では差分方程式論、
および可積分系等の分野で多くのユーザを獲得しています。
その後、2009年に Reduce は Tony Hearn によって BSD ライセンスで公開され、
現在に至ります。
まだ、Debian オフィシャルパッケージには含まれていませんが、
getdeb ({\tt http://www.getdeb.net/})から、パッケージが入手可能です。
Reduce もまた、微分方程式の求解、積分、行列計算、グラフの描画等に対応し
ています。

Maxima も Reduce も、たいへん歴史の古いソフトウェアであり、
現在も、多くのユーザを獲得し、開発グループが日夜、
更新を続けているソフトウェアです。
その他にも、数論の PARI/GP、群論の GAP、統計計算の R、可換環論の Singular、Macaulay2等が研究ツールとして有名です。PARI/GP、GAP、R はオフィシャルパッケージに
なっていますが、Singular、Macaulay2 については、上流開発者によるパッケー
ジは提供されていますが、オフィシャルには収録されていません。

一方、日本国内における数式処理システムの開発については、
1970年代に日本電信電話会社で AL が、1980年代に
理研で GAL が開発されました。また、1980年代末に、
富士通研究所で開発された Risa/Asir は、現在、拠点を
神戸大学に移して、研究、開発が進められています。特にグレブナー基底等、
多項式の計算に特化して、高速計算が可能であり、
MathLibre プロジェクトの中心的な存在として収録されています。
ただ、Risa/Asir は富士通研究所時代のライセンスを引き継いでおり、
オープンソースソフトウェアライセンスとは
異なるライセンスで配布されています。

\subsection{最近のシステム}
ここで、最近の動きに注目して、いくつかの数学ソフトウェアを紹介します。
\subsubsection{Sage}
Sage は2005年に William Stein によって開始されたオープンソースプロジェクトです。
彼が Sage の開発を始めた背景については
``Mathematical Software and Me: A Very Personal Recollection'' \cite{stein}に
詳しく述べられています。
現在、Sage は数学者を始めとする大勢の専門家によって開発が進められていま
す。2007年にはフリーソフトウェアの賞である
Les Trophes du Libre の科学技術部門において金賞を受賞しています。
Sage Days と呼ばれるイベントを世界各地で開催しており、開発者と
利用者からなる巨大なコミュニティが存在します。
先日、九州大学において日本で初の Sage Days が開催され、多くの
参加者を得ました。

Sage は「車輪の再発明」はしないということを掲げており、
既に実績のある Maxima や Singular、PARI/GP、GAP、R といった
数学ソフトウェアを組み合わせることで、使いやすい環境の構築を
目指しています。それぞれの数学ソフトウェアをつなぎ合わせているのは
オブジェクト指向プログラミング言語 Python です。
Python 自身もオープンソースソフトウェアですが、世界中で熱狂的な利用者、開発者を
獲得しています。その使いやすさと、多機能性から
さまざまなプロジェクトが Python で開発されています。
それまでは、数学ソフトウェアを使いこなすためには、
そのソフトウェアごとに異なるプログラミング機能を活用しなければいけなかったのですが、
Sage は Python という一般的なプログラミング言語を
用いることで、統一的なインターフェースを提供しています。また、
Python のオブジェクト指向言語としての機能を活用できる点も
魅力となっているようです。
Sage Notebook と呼ばれるユーザーインターフェースを提供しており、
Mozilla Firefox 等の
Webブラウザ上で数式処理やグラフ描画といった機能を利用することができます。

Sageについての入門書としては、Ted Kosan による ``Sage for Newbies''
\cite{newbie} が良く知られています。これは横田博史氏によって「はじめての
Sage」\cite{ponpoko}として翻訳され、MathLibre にも収録されています。
最近、韓国では大学初年級の微分積分と線形代数について Sage を用いて解説した書籍が
出版されました。

Sage は、あまりに巨大なシステムであり、更新も頻繁であるため、
現在は、Debian パッケージとして配布されていません。Linux 用には
バイナリー版が配られています。多少の時間はかかりますが、CPUごとに最適化する
ため、ソースからコンパイルすることをお勧めします。
Windows 版については、以前は仮想マシンの Ubuntu 上で起動したサーバに
Windows 上のブラウザから接続する形式だったのですが、現在は、
Fedora Core 上で起動したサーバに Fedora Core 上の Chrome を接続させる
形になったようです。

\begin{figure}[ht]
\begin{minipage}[c]{0.45\hsize}
\includegraphics[height=0.8\hsize]{images/sage.eps}
\caption{Sage によるグラフ描画}
\label{fig:sage}
\end{minipage}
\begin{minipage}[c]{0.48\hsize}
\includegraphics[height=0.72\hsize]{images/taylor.eps}
\caption{GeoGebra によるテイラー多項式}
\label{fig:geogebra}
\end{minipage}
\end{figure}


\subsubsection{GeoGebra}
GeoGebra はオーストリアのヨハネスケプラー大学の Markus Hohenwarter によって
始められた数学ソフトウェアプロジェクトです。
彼はザルツブルク大学の学生時代に
テキサス・インスツルメンツ社の電卓 TI-92 Plus に触れる機会を持ちました。
彼は電卓に収録されていた動的幾何ソフト Cabri Geometry 
と数式処理システム Derive に刺激を受けて開発を志したということです\cite{markus}。
2001年2月に最初のプロトタイプを開発し、
2002年3月には GeoGebra の開発でコンピュータサイエンスと数学教育に関する
修士号を取得しています.
この間、GeoGebra は、各国で数多くの賞を受賞しています。
2004年から2006年にかけては数学教育に関する PhD プロジェクトとして開発が
進められ、Austiran Academy of Sciences から支援を受けて、着実にその存在
を世界中に知らしめました。
GeoGebra もまた、オープンソースソフトウェアとして公開されています。
Java の実行環境を必要としますが、Windows、MacOS X、Linux 等、計算機環境を問わ
ずに利用可能です。Debian では stable に 3.2 系が testing に 4.0 系が
収録されています。

GeoGebra は起動すると ``Dynamic Mathematics for Everyone'' というメッセージ
を表示します。日本語に訳すと「動的数学ソフトウェア」でしょうか。
これは GeoGebra が Cabri や Cinderella と言った
動的幾何学ソフトウェア(Dynamic Geometry Software)
と呼ばれるソフトウェアの影響を受けていること、
また、主要なユーザインターフェースが動的幾何学ソフトウェアとしての機能を備えていることから類推されます。
GeoGebra という名称は幾何学（Geometry）+ 代数学（Algebra）という意の造語です.開発初期の段階では GeoGebra は動的幾何学ソフトウェアとしての機能しか持ちませんでした。しかし、現在では関数入力によるグラフ描画、数式処理、スライダー、表計算機能等を備えており、幾何学ソフトウェアという枠組みだけでは語り尽くせない存在です。

メニューやヘルプ、マニュアル等の翻訳についても世界中のボランティアスタッ
フによって活発に行われており、最新の GeoGebra 4.0 では約50ヵ国語に対応しました。
日本語化については、北海道教育大学の和地輝仁氏が中心となって進めており,
国内のユーザーを増やすきっかけとなっています。
%韓国語版については、Gyeonggi-Buk Science High School の Choi Kyeong-Sik によって翻訳が進められており、Naver という韓国最大手のインターネット検索ポータルサイトに GeoGebra のコミュニティを形成し普及に努めているようです。

GeoGebra は動的幾何学ソフトウェアとしての機能と
グラフ描画ソフトの機能が連携することで使い易いインターフェースを提供しています.
また、Maxima や Reduce と連携して数式処理機能を備えているため、
微分や積分、因数分解等の基本的な演算にも対応しています。
図 \ref{fig:geogebra} のようにグラフ上の点を動的に動かしてテイラー多項式によって描かれるグラフを観察することもできます。
 
表計算ビューを備えたことで、統計方面についても
機能が強化されており、教材作成に威力を発揮するものと思われます。
すべての機能を述べることはできませんが、
ヘルプやさまざまなサンプル、ムービー等も豊富で、
初めての方でも使いやすい数学ソフトウェアだと思います。
どちらかと言えば、研究よりも数学教育に焦点をあてたソフトウェアですが、
その使いやすいインターフェースから構成される可視化機能は、
プレゼンテーションなどでも威力を発揮するでしょう。
次期バージョンの4.2では本格的な数式処理シェルを備え、
5.0では3Dに対応する予定です。
潜在的な能力も含めて今後の展開が楽しみな数学ソフトウェアです。

2012年7月4日--6日にはRIMS共同研究「数式処理研究の新たな発展」が
計画されていますが、7月5日に GeoGebra Institute から
Zsolt Lavizca, Bal\'azs Koren の2人が GeoGebra の最新事情についての講演
が行われます。

\subsection{まとめ}
ここに紹介したソフトウェアは、MathLibre に収録している100以上の
数学ソフトウェアのごく一部です。本稿が、数学ソフトウェアに
興味を持っていただくきっかけになれば幸いです。

\begin{thebibliography}{99}
%\bibitem{stein1}
%David Joyner and William Stein,
%\emph{Open source mathematical software},
%Notices of the AMS、\textbf{54} (3) (2007),
%http://www.ams.org/notices/200710/tx071001279p.pdf

\bibitem{stein}
William Stein,
``\emph{Mathematical software and me:A very personal recollection}'',
http://wstein.org/

\bibitem{newbie}
Ted Kosan,
``\emph{Sage for newbies}'',
http://sage.math.washington.edu/home/tkosan/

\bibitem{ponpoko}
Ted Kosan, 横田博史 訳,
「\emph{はじめてのSage}」,
http://www.bekkoame.ne.jp/$\sim$ponpoko/KNOPPIX/

\bibitem{markus}
Markus Hohenwarter and Judith Preiner,
``\emph{Dynamic Mathematics with GeoGebra}'',
The Journal of Online Mathematics and Its Applications,
\textbf(7), 2007, http://mathdl.maa.org/mathDL/
\end{thebibliography}

\end{document}
