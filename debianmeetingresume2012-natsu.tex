%; whizzy paragraph
%; whizzy-paragraph "^\\\\dancersection"
% -initex iniptex -latex platex -format platex -bibtex jbibtex -fmt fmt
% 以上 whizzytex を使用する場合の設定。

%     Tokyo Debian Meeting resources
%     Kansai Debian Meeting resources
%     Copyright (C) 2012 Junichi Uekawa
%     Copyright (C) 2012 Nobuhiro Iwamatsu

%     This program is free software; you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation; either version 2 of the License, or
%     (at your option) any later version.

%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.

%     You should have received a copy of the GNU General Public License
%     along with this program; if not, write to the Free Software
%     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

%  preview (shell-command (concat "evince " (replace-regexp-in-string "tex$" "pdf"(buffer-file-name)) "&"))
% 画像ファイルを処理するためにはebbを利用してboundingboxを作成。
%(shell-command "cd image2012-natsu; ebb *.png")

% progress memo:
% 2010/12-2011/05がマージ対象、関西は2010/12-2011/05(仮)
%  -- 2012 ???
% イベント等でない場合は理由を書くこと。
% 必要な変更点は FIXME で記録しています。

%%ここからヘッダ開始。

\documentclass[mingoth,a4paper]{jsarticle}
\usepackage{monthlyreport}
\usepackage{supertabular}

\usepackage{comment}


\newcommand{\commandannotate}[2][4]{%
  \raisebox{0.33ex}{%
    \smash{%
      \ovalbox{%
        {\scriptsize\rule{0pt}{0.75ex}}%
        \smash{%
          \raisebox{-0.25ex}{%
            \scriptsize{}%
            \ifcase#1%           0
            \or $\uparrow{}$%    1
            \or $\rightarrow{}$% 2
            \or $\downarrow{}$%  3
            \or $\leftarrow{}$%  4
            \else%               5-9
            \fi%
            {#2}%
          }%
        }%
      }%
    }%
  }%
}
\usepackage{alltt}
\newenvironment{terminal}{%
  \begin{trivlist}\item\begin{screen}%
    \begin{alltt}\renewcommand{\baselinestretch}{0.75}%
      \begin{small}%
}{%
      \end{small}%
    \end{alltt}%
  \end{screen}\end{trivlist}%
}


% section の代わりの環境 -- 改訂する。
\renewcommand{\dancersection}[2]{%
\newpage
あんどきゅめんてっど でびあん 2012年夏号
%
% top line
\vspace{0.1mm}\\
{\color{dancerdarkblue}\rule{\hsize}{2mm}}

%
% middle text
%
\begin{minipage}[t]{0.6\hsize}
\color{dancerdarkblue}
\vspace{1cm}
\section{#1}
\hfill{}#2\\
\end{minipage}
\begin{minipage}[t]{0.4\hsize}
\vspace{-2cm}
\hfill{}\includegraphics[height=8cm]{image200502/openlogo-nd.eps}\\
\vspace{-5cm}
\end{minipage}
%
% bottom line
{\color{dancerlightblue}\rule{0.66\hsize}{2mm}}
%
\vspace{2cm}
}
% end of dancersection.

\begin{document}

\begin{titlepage}
\thispagestyle{empty}

\vspace*{-2cm}
あんどきゅめんてっど でびあん 2012年夏号\\
\hspace*{-2cm}
\includegraphics{image2012-natsu/dotdeb.pdf}\\
\hfill 2012年06月23日 初版発行

\rotatebox{10}{\fontsize{32}{32} {\gt 東京エリアＤｅｂｉａｎ勉強会}}

\rotatebox{10}{\fontsize{32}{32} {\gt 関西Ｄｅｂｉａｎ勉強会} }

\vspace*{-2cm}
\hfill{}\includegraphics[height=6cm]{image200502/openlogo-nd.eps}
\end{titlepage}

\newpage
\thispagestyle{empty}\mbox{}
\newpage

\setcounter{page}{1}
\begin{minipage}[]{0.2\hsize}
 \definecolor{titleback}{gray}{0.9}
 \colorbox{dancerlightblue}{\rotatebox{90}{\fontsize{80}{80}
{\gt \color{dancerdarkblue}デビアン勉強会} }}
\end{minipage}
\begin{minipage}[]{0.8\hsize}
\hrule
\vspace{1mm}
\hrule
\setcounter{tocdepth}{1}
{\small
\begin{multicols}{2}
  \tableofcontents
\end{multicols}
} %FIXME: does not fit in one column! しかし二段にするとあまり美しくない？
\vspace{1mm}
\hrule
\vspace{3cm}

\end{minipage}

% FIXME: 本文を追加すること。
%-------------------------------------------------------------------------------
\dancersection{Introduction}{上川 純一, 山下 尊也}
%-------------------------------------------------------------------------------

\subsection{東京エリアDebian勉強会}

 Debian勉強会へようこそ。これからDebianの世界にあしを踏み入れると
 いう方も、すでにどっぷりとつかっているという方も、月に一回Debianについ
 て語りませんか？

 Debian勉強会の目的は下記です。

\begin{itemize}
 \item \underline{Debian Developer} (開発者)の育成。
 \item 日本語での「\underline{開発に関する情報}」を整理してまとめ、アップデートする。
 \item \underline{場}の提供。
 \begin{itemize}
  \item 普段ばらばらな場所にいる人々が face-to-face で出会える場を提供
	する。
  \item Debian のためになることを語る場を提供する。
  \item Debianについて語る場を提供する。
 \end{itemize}
\end{itemize}

 Debianの勉強会ということで究極的には参加者全員がDebian Packageをがりがり
 と作るスーパーハッカーになった姿を妄想しています。情報の共有・活用を通し
 て Debianの今後の能動的な展開への土台として、「場」としての空間を提供す
 るのが目的です。

\subsection{関西 Debian 勉強会}

 関西 Debian 勉強会はDebian GNU/Linux のさまざ
 まなトピック(新しいパッケージ、Debian 特有の機能の仕組、Debian 界隈で起
 こった出来事、などなど）について話し合う会です。

 目的として次の三つを考えています。
 \begin{itemize}
  \item メーリングリストや掲示板ではなく、直接顔を合わせる事での情報交換の促進
  \item 定期的に集まれる場所
  \item 資料の作成
 \end{itemize}

 それでは、楽しい一時をお楽しみ下さい。

%-------------------------------------------------------------------------------
% end of header
%-------------------------------------------------------------------------------

\clearpage
\newpage

%-------------------------------------------------------

%-------------------------------------------------------------------------------
\dancersection{東京エリアDebian勉強会 2011年の振り返り}{まえだこうへい}
%-------------------------------------------------------------------------------
\index{debianjp@Debian JP} 
\index{とうきょうえりあ@東京エリアDebian勉強会}
\index{2011ねん@2011年}

2011年12月で7年目のDebian勉強会が終了しました。

\subsection{基本的な数値}

Debian 勉強会は毎回事前課題事後課題を設定しており、予習復習を必要だと謳っている勉強会です。
実際にどれくらいの人が出席しているのか、またその人たちがどれくらい事前課
題・事後課題を提出しているのか、確認してみましょう。
\fgref{fig:attendandprepostwork}です。
値は一年の移動平均です。

結果を見ると参加者数は下降傾向にあり、事前課題の提出率は昨年からは横ばい傾向です。
事前課題をちゃんとやる常連参加者に収斂されてきているのでしょうか？
一方、事後課題(ブログ)の率はさらに低下しています。昨年、「ブログはもう流行らないのでしょうか」との一言がありましたが、まさにその通りかもしれません。

\begin{figure}[ht]
\begin{center}
 \includegraphics[width=0.7\hsize]{image201112/memberanalysis/attend.png}
\caption{東京エリアDebian勉強会事前課題・事後課題提出実績(12ヶ月移動平均)}\label{fig:attendandprepostwork}
\end{center}
\end{figure}

毎回の参加者の人数と、その際のトピックを見てみます。
今年も昨年同様、人数的には大きく増減はありませんが、10月の筑波大での開催での参加者が、昨年の筑波大でのつくらぐさんとの合同勉強会の時と同じ参加者数でした。新参の参加者を期待した筑波大生の参加は思ったほどではなかった一方、初参加なのにわざわざ都心から筑波大まで参加してくれた方が意外と多かった回でした。2009年から見ると、大学での開催はいつもより参加者数および初参加者が増えるので、来年以降も続けていくと良いでしょう。
また、リストをみると、毎月数名は初参加者も毎月いて、そのうち一部は2回目以降も参加する人がいることを考えると、先ほどの参加数が下降傾向にありつつ、事前課題の提出数が横ばいであるのは、ちゃんと事前課題を提出する人が常連になる傾向にあるのではないか、とも見れます。事前課題の提出率は維持しつつ、参加者数は増やしていく為の対策は必要でしょう。


会場を見ると、今年の会場は、あんさんぶる荻窪以外の公民館などの利用が増えました。
また、今年は３年前の草津温泉、昨年の木更津に続き、三回目のDebian温泉を伊東の山喜温泉で開催しました。
Debian Hack Cafeも6月ごろから月1回程度のペースで再開しているようです。

\begin{table}[ht]
\begin{minipage}{0.5\hsize}
 \caption{東京エリアDebian勉強会参加人数(2005-2006年)}\label{tab:count}
 \begin{center}
  \begin{tabular}{|l|c|p{10em}|}
 \hline
   & 参加人数 & 内容 \\
 \hline
   2005年1月 & 21 & 秘密\\
   2005年2月 & 10 & debhelper 1\\
   2005年3月 & 8 &  (早朝) debhelper 2、social contract\\
   2005年4月 & 6 & debhelper 3\\
   2005年5月 & 8 & DFSG、dpkg-cross、lintian/linda\\
   2005年6月 & 12 & alternatives、d-i\\
   2005年7月 & 12 & toolchain、dpatch\\
   2005年8月 & 7 & Debconf参加報告、ITPからアップロードまで\\
   2005年9月 & 14 & debconf\\
   2005年10月 & 9 & apt-listbugs、バグレポート、debconf翻訳、debbugs\\
   2005年11月 & 8 & DWN翻訳フロー、statoverride\\
   2005年12月 & 8 & 忘年会\\
   2006年1月 & 8 & policy、Debian勉強会でやりたいこと\\
   2006年2月 & 7 & policy、multimedia \\
   2006年3月 & 30 & OSC: debian勉強会、sid \\
   2006年4月 & 15 & policy、\LaTeX{} \\
   2006年5月 & 6 & mexico \\
   2006年6月 & 16 & debconf、cowdancer\\
   2006年7月 & 40 & OSC-Do: MacBook Debian \\
   2006年8月 & 17 & 13執念 \\
   2006年9月 & 12 & 翻訳、Debian-specific、oprofile \\
   2006年10月 & 23 & network、i18n会議、Flash、apt \\
   2006年11月 & 20 & 関西開催： bug、sid、packaging \\
   2006年12月 & 14 & 忘年会 \\
 \hline
  \end{tabular}
 \end{center}
\end{minipage}
\begin{minipage}{0.5\hsize}
 \caption{東京エリアDebian勉強会参加人数(2007-2008年)}\label{tab:count2007}
 \begin{center}
  \begin{tabular}{|l|c|p{10em}|}
 \hline
 & 参加人数 & 内容\\
 \hline
   2007年1月 & 15 & 一年を企画する \\
   2007年2月 & 13 & dbs, dpatch\\ 
   2007年3月 & 80 & OSC仮想化 \\
   2007年4月 & 19 & quilt, darcs, git\\
   2007年5月 & 23 & etch, pbuilder, superh \\   
   2007年6月 & 4 & エジンバラ開催：Debconf7 実況中継 \\
   2007年7月 & 18 & Debconf7 参加報告\\
   2007年8月 & 25 & cdn.debian.or.jp \\   
   2007年9月 & 14 & exim \\   
   2007年10月 & 30 & OSC Tokyo/Fall(CUPS) \\   
   2007年11月 & 19 & live-helper, tomoyo linux kernel patch, server\\
   2007年12月 & 11 & 忘年会\\
   2008年1月 & 23 & 一年を企画する \\
   2008年2/29,3/1 & 36 & OSC  \\
   2008年3月 & 37 & データだけのパッケージ、ライセンス \\
   2008年4月 & 17 & バイナリパッケージ \\
   2008年5月 & 20 & 複数のバイナリパッケージ \\
   2008年6月 & 10 & debhelper \\
   2008年7月 & 17 & Linux kernel patch / module パッケージ \\
   2008年8月 & 10 & Debconf IRC会議とDebian温泉 \\
   2008年9月 & 17 & po4a, 「Debian メンテナのお仕事」 \\
   2008年10月 & 11? & OSC Tokyo/Fall \\
   2008年11月 & 17 & 「その場で勉強会資料を作成しちゃえ」 Debian を使った \LaTeX{} 原稿作成合宿 \\
   2008年12月 & 12 & 忘年会 \\
 \hline
  \end{tabular}
 \end{center}
\end{minipage}
\end{table}

\begin{table}[t]
\begin{minipage}{0.5\hsize}
 \caption{東京エリアDebian勉強会参加人数(2009-2010年)}\label{tab:count2009}
 \begin{center}
  \begin{tabular}{|l|c|p{10em}|}
 \hline
 & 参加人数 & 内容\\
 \hline
   2009年1月 & 12 & 一年を企画する \\
   2009年2月 & 30 & OSC パッケージハンズオン\\ 
   2009年3月 & 23 & Common Lisp, パッケージ作成 \\
   2009年4月 & 15 & Java Policy, ocaml, 開発ワークフロー\\
   2009年5月 & 13 & MC-MPIパッケージ化、Erlang、Androidアプリ、DDTP \\   
   2009年6月 & 14 & DDTP・DDTSS、bsdstatsパッケージ、Debian kFreeBSD\\
   2009年7月 & 4 & スペインにてDebconf 9\\
   2009年8月 & 14 & スペイン Debconf 9 参加報告 \\   
   2009年9月 & 26 & GPGキーサインパーティー \\   
   2009年10月 & 30 & OSC Tokyo Fall\\
   2009年11月 & 12 & Octave, R, gnuplot, auto-builder \\
   2009年12月 & 10 & 忘年会\\
   2010年1月 & 17 &  東京大学にて新年会 \\
   2010年2月 & 11 & Debian温泉,ocaml,haskell \\
   2010年3月 & 12 & weka,fftw,dpkg v3 quilt \\
   2010年4月 & 15 & upstart,piuparts,debtags \\
   2010年5月 & 22 & 筑波大学,kernel \\
   2010年6月 & 12 & OSC-Doリハーサル  \\
   2010年7月 & 0 & キャンセル  \\
   2010年8月 & 3 & Debconf (NYC) \\
   2010年9月 & 30 & OSC Tokyo/Fall \\
   2010年10月 & 13 & 俺のDebianな一日 \\
   2010年11月 & 15 & ext4,btrfs,nilfs,ceph \\
   2010年12月 & 14 &  cacert, libsane \\
 \hline
  \end{tabular}
 \end{center}
\end{minipage}
\begin{minipage}{0.5\hsize}
 \caption{東京エリアDebian勉強会参加人数(2011年)}\label{tab:count2011}
 \begin{center}
  \begin{tabular}{|l|c|p{10em}|}
 \hline
 & 参加人数 & 内容\\
 \hline
   2011年1月 & 12 & 荻窪,Kinect,アンケートシステム,CACertサイン会 \\
   2011年2月 & 13 & 北新宿生涯学習館,HDFS,Debian Game Team \\
   2011年3月 & ? & OSC Tokyo/Spring,CACert ATE Tokyo \\
   2011年4月 & 12 & IIJ,barkports,initramfs,月刊PPC64 \\
   2011年5月 & 15 & 戸山生涯学習館,Apache2モジュール,Debian on ニフクラ,Debian/m68k,月刊PPC64 \\
   2011年6月 & 17 & 東京オリンピックセンター,ドキュメント処理系,2011再計画 \\
   2011年7月 & 3 & DebConf11 \\
   2011年8月 & 12 & 荻窪,パッケージング関連, Debconf11報告 \\
   2011年9月 & 9 & 山喜旅館,Debian温泉2011 \\
   2011年10月 & 22 & 筑波大学,Haskell,LaTeX,レポート自動生成,月刊debhelper開始 \\
   2011年11月 & ? & OSC Tokyo/Fall \\
   2011年12月 & 9 & スクウェア・エニックス,quiltでporting,月刊debhelper,振り返り \\
 \hline
  \end{tabular}
 \end{center}
\end{minipage}
\end{table}

\clearpage

%-------------------------------------------------------------------------------
\dancersection{関西Debian勉強会 2011年の振り返りと2012年の企画}{Debian JP}
%-------------------------------------------------------------------------------
\index{debianjp@Debian JP}
\index{かんさいDebianべんきょうかい@関西Debian勉強会}
\index{2011ねん@2011年}

初回が2007年3月なので、2011年で5年目になりますね。

\subsection{勉強会全体}

毎回のセッションについてですが、
今年はパッケージ作成やBTSに関する題材が多く扱われました。
定番のネタ(Debianの入門的なお話、ライセンス、パッケージ作成、BTS)などの題材は
毎年更新されていくべき題材なので, 今後も繰り返し扱っていきたい所です。
事前課題で提出されていた「インストール大会」のような初心者講習もやってみたい
所ですね。

また、昨年から事前課題の提出が普通になってきましたので、
来年からは事後統計(アンケート)も提出してもらおうか, なんて考えています。

運営に関しては、常連さんだった河田さんが運営側になり、Debian JP Project
へ加入されました。また、今回の発表にある通り倉敷さんが DD になるため
の NM プロセスへ申請されています。

イベント参加については、OSC Kansai@ Kobe, OSC Hokkaido, OSC Kansai@
Kyoto, KOF に参加しました。勉強会から fork した GPG キーサインパーティも
毎回実施されています。今後も継続して参加する予定です。

\subsection{開催実績}

関西Debian勉強会の出席状況を確認してみましょう。グラフで見る
と\fgref{fig:kansaipeoplechart}になります。また、毎回の参加者の人数とその
際のトピックを \tbref{tab:count2011kansai} にまとめました。グラフ中の黒線
は参加人数, 赤線は1年の移動平均です。参加人数が$0$となっているところは人
数が集計されていないor開催されなかった月ですので、欠損値処理をした方が良いですね%
\footnote{R使った事ないので今日は間に合いませんでした}。

Debian勉強会申し込みシステムを使用するようになり, 事前課題を設定すること
も多くなりました。また, アンケートシステムも稼動するようになるでしょうか
ら、今後は事前課題と事後課題のグラフを追加しようと思っています。


\begin{figure}[h]
  \begin{center}
    \includegraphics[width=.8\hsize]{image201112/memberanalysis/kansai.png}
  \end{center}
  \caption{関西の参加人数推移(参加人数と12ヶ月移動平均)}
  \label{fig:kansaipeoplechart}
\end{figure}
\begin{table}
  \begin{minipage}{0.5\hsize}
    \caption{関西Debian勉強会の参加人数とトピック(2007年)}
    \begin{center}
      \begin{tabular}{|l|c|p{10em}|}
        \hline
                   & 参加人数 & 内容 \\
        \hline
        2007年3月  & 19       & 開催にあたり \\
        2007年4月  & 25       & goodbye、youtube、プロジェクトトラッカー\\
        2007年6月  & 23       & 社会契約、テーマ、debian/rules、bugreport\\
        2007年7月  & 20前後   & OSC-Kansai \\
        2007年8月  & 20       & Inkscape、patch、dpatch\\
        2007年9月  & 16       & ライブラリ、翻訳、debtorrent\\
        2007年10月 & 22       & 日本語入力、SPAMフィルタ\\
        2007年11月 & 20前後   & KOF \\
        2007年12月 & 15       & 忘年会、iPod touch\\
        \hline
      \end{tabular}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.45\hsize}
    \begin{center}
    \caption{関西Debian勉強会参加人数(2008年)}\label{tab:count2008kansai}
    \vspace{-1em}
      \begin{tabular}{|l|c|p{10em}|}
        \hline
                   & 参加人数 & 内容 \\
        \hline
        2008年2月  & 20       & PC Cluster, GIS, \TeX \\
        2008年3月  & 23       & bug report, developer corner, GPG \\
        2008年4月  & 24       & coLinux, Debian GNU/kFreeBSD, sid \\
        2008年5月  & 25       & ipv6, emacs, ustream.tv\\
        2008年6月  & 20       & pbuilder, hotplug, ssl\\
        2008年8月  & 13       & coLinux \\
        2008年9月  & 17       & debian mentors, ubiquity, DFSG\\
        2008年10月 & 11       & cdbs,cdn.debian.or.jp \\
        2008年11月 & 35       & KOF \\
        2008年12月 & ?        & TeX資料作成ハンズオン\\
        \hline
      \end{tabular}
    \end{center}
  \end{minipage}
\end{table}
\begin{table}
  \begin{minipage}{0.5\hsize}
    \caption{関西Debian勉強会の参加人数とトピック(2009-2010)}
    \begin{center}
      \begin{tabular}{|l|c|p{10em}|}
        \hline
                   & 参加人数 & 内容 \\
        \hline
        2009年1月  & 18       & DMCK, LT \\
        2009年3月  & 12       & Git \\
        2009年4月  & 13       & Installing sid, Mancoosi, keysign \\
        2009年6月  & 18       & Debian Live, bash\\
        2009年7月  & 30?      & OSC2009Kansai \\
        2009年8月  & 14       & DDTSS, lintian \\
        2009年9月  & 14       & reportbug, debian mentors\\
        2009年10月 & 16       & gdb, packaging \\
        2009年11月 & 35       & KOF2009 \\
        2009年12月 & 16       & GPS program, OpenStreetMap \\
        2010年1月  & 16       & Xen, 2010年企画 \\
        2010年2月  & 16       & レンタルサーバでの利用, GAE \\
        2010年3月  & 30?      & OSC2010Kobe \\
        2010年4月  & 12       & デスクトップ環境, 正規表現 \\
        2010年5月  & 11       & ubuntu, squeeze \\
        2010年6月  & 11       & debhelper7, cdbs, puppet \\
        2010年7月  & 40?      & OSC2010Kyoto \\
        2010年8月  & 17       & emdebian, kFreeBSD \\
        2010年9月  & 17       & タイルWM \\
        2010年10月 & 12       & initramfs, debian live \\
        2010年11月 & 33       & KOF2010 \\
        2010年12月 & 14       & Proxmox, annual review \\
        \hline
      \end{tabular}
    \end{center}
  \end{minipage}
  \begin{minipage}{.45\linewidth}
    \caption{関西Debian勉強会の参加人数とトピック(2011)}\label{tab:count2011kansai}
    \begin{center}
      \begin{tabular}{|l|c|p{10em}|}
        \hline
        開催年月  & 参加人数 & 内容 \\
        \hline
        2011年1月 &10        & BTS, Debian GNU/kFreeBSD\\
        2011年2月 &15        & pbuilder, Squeezeリリースパーティ\\
        2011年3月 &17        & ライセンス, Debianのドキュメント関連\\
        2011年4月 &25        & OSC 2011 Kansai @ Kobe, GPG キーサインパーティ \\
        2011年5月 &20        & vi, dpkg \\
        2011年6月 &17        & IPv6, vcs-buildpackage{svn, git}\\
        2011年7月 &17        & OSC 2011 Kansai @ Kyoto, GPG キーサインパーティ\\
        2011年8月 &20        & Debianパッケージ作成ハンズオン\\
        2011年9月 &11        & vcs-buildpackage{bzr, git}\\
        2011年10月&11        & Emacs, vim の拡張のDebianパッケージ, 翻訳\\
        2011年11月&23        & KOF 2011\\
        2011年12月&13        & NMプロセス, BTS\\
        \hline
      \end{tabular}
    \end{center}
  \end{minipage}
\end{table}


\clearpage

%-------------------------------------------------------------------------------
\dancersection{東京エリアDebian勉強会の開催方法}{野島 貴英}
%-------------------------------------------------------------------------------
\index{とうきょうえりあでびあんべんきょうかいのかいさいほうほう@東京エリアDebian勉強会の開催方法}

\subsection{はじめに}

東京エリアDebian勉強会では、毎年12月号資料では勉強会の開催方法についてま
とめています。今回は野島が一通りの流れをまとめます。これを読めば、あなたも
東京エリアDebian勉強会を開けるはず！

\subsection{東京エリアDebian勉強会を開く時のスケジュール}

% 東京エリアDebian勉強会は表\ref{tab:meeting-schedule}のスケジュールで行います。

\begin{table}[ht]
\begin{center}
\small
\begin{tabular}{|p{12em}|p{31em}|}
\hline
時期&作業内容 \\
\hline\hline
開催2ヶ月前 & 場所を確保します。会議室は２ヶ月前に予約しないと埋まりやすいです。\\
\hline
開催2ヶ月前から1ヶ月前 & 勉強会のテーマと、事前課題を決めます。\\
\hline
開催1ヶ月前 & 勉強会のテーマに沿った原稿を募集します。時間枠にあわせた発表が埋まらない場合、
発表者を枠が埋まるまで、探す事になります。また、開催にあたり、作業の分担が必要な時は、この時
ぐらいに割り当てを完了します。また、宴会の場所について、確保が困難な事が予想される場合は、
あらかじめ席のみ予約しておきます。\\
\hline
開催2週間前までに & Debian勉強会予約システム\url{http://debianmeeting.appspot.com}に予約登録
ページを作成します。Debian JP Blog \url{http://www.debian.or.jp/}及び、
Debian勉強会Webサイト \url{http://tokyodebian.alioth.debian.org/} に勉強会の内容を提示します。
メールで debian-users メーリングリストにアナウンスを投げます。
Debian JP twitter や mixi Debian コミュニティーなどにもアナウンスすることが多いです。\\
\hline
開催１週間前 & 発表者は勉強会資料用リポジトリに資料をコミットします。\\
\hline
開催２日前　& 参加者の募集の締切りを行います。この時までに揃った事前課題を勉強会資料にマージします。\\
\hline
開催1日前　& kinkos等の印刷製本サービスに原稿印刷および製本を依頼します。\\
\hline
開催当日　& \begin{enumerate}
  \item 参加者から費用の回収と集計をします。
  \item 勉強会を定刻どおりに開催します。
  \item 司会者、発表者と協力して時間内に勉強会を終了します。
  \item 宴会の場所の確保が困難でない時は、宴会の場所を抑えます。
  \item 宴会の開催、宴会の会計をします。
\end{enumerate} \\
\hline
開催後　& Debian勉強会予約システムからアンケートをおくります。 \\
\hline
12月　& 勉強会のアンケート結果などを一年分集計して発表します。 \\
\hline
\end{tabular}
\caption{全体スケジュール}
\label{tab:meeting-schedule}
\end{center}
\end{table}

\subsection{東京エリアDebian勉強会の開催調整}

東京エリアDebian勉強会の開催調整は専用のメーリングリストがあり、普段はこちらで調整が行われます。
運営者専用のメーリングリストで、一部のコアメンバーのみが参加しています。
運営に積極的に参加したい人は勉強会運営者に連絡を取る必要があります。

\subsection{初めて東京エリアDebian勉強会の開催を担当する場合の事前準備}

初めて東京エリアDebian勉強会の開催を担当する場合以下の項目が準備してあると
スムーズです。

\begin{enumerate}
\item Debian JP Projectの提供するサーバーへログインできるアカウント\\
Debian JP Blogを更新する際に必要になります。
これは通常Debian JP Projectの会員になるときに付与されます。
会員でない人は会員にコミットしてもらうよう依頼する必要があります。

\item \url{http://alioth.debian.org/}アカウント
資料の編集等を行う際に必要になります。
アカウントを取得したら、メーリングリストでtokyodebianグループ権限に所属させてほしい旨、
取得したアカウント名を沿えて依頼します。このアカウントは誰でも取得可能です。

\end{enumerate}

また、勉強会の幹事担当の場合に必要な知識とコンピュータの環境は以下になります。

\begin{enumerate}
\item Debianが動作し、インターネットが利用できるPCの用意
\item ssh,emacs,muse-el,git、subversionの基本操作についての知識
\item ブラウザとHTMLの記載の知識
\item \url{http://alioth.debian.org/},\url{http://qwik.jp/}の使い方の知識
\item \LaTeX{}の知識
\end{enumerate}

わからないことや困ったことがあればメールやメーリングリストで聞いてみましょう。

\subsection{東京エリアDebian勉強会の掲示の出し方}

\url{http://www.debian.or.jp/}に掲示を出す場合の編集の仕方は、
\url{http://www.debian.or.jp/project/webmasters.html}にその記載があります。
実際には、subversionでリポジトリをとってきて、
\texttt{./www.debian.or.jp/blosxom/ data/events/tokyodebian-XX.d} (XXは第XX回を示します）を
作成します。

\url{http://debianmeeting.appspot.com/eventadmin/edit?eventid=}のフォームの編集
はフォームに沿って情報を入れるだけです。ただ、細かい事は、\url{http://tokyodebian.alioth.debian.org/YYYY-MM.html}へのリンクをURLの
欄に指定し、そちらを参照してもらいます。

\url{http://tokyodebian.alioth.debian.org/}へは、\url{http://qwik.jp/メーリングリスト名}のトップ
ページに記載されているやり方に従います。実際にはgit
で\url{git+ssh://git.debian.org/git/tokyodebian/muse.git} リポジトリをcloneして、muse形式で編集し、make publishする事となります。

\clearpage

%-------------------------------------------------------------------------------
\dancersection{Debian勉強会予約システム再訪}{上川 純一}
%-------------------------------------------------------------------------------
\index{Debianべんきょうかいよやくしすてむ@Debian勉強会予約システム}
\index{python appengine}
\index{django}

Debian 勉強会予約システムの開発開始から2年経ちました。当初は宴会君をリプレー
スするために突貫でつくりあげたものですがほぼそのままの状態で運営されてい
ます。面倒くさがって適当に実装した部分、ウェブアプリケーションで気をつけ
るべきところをよくわからずに書いていた部分があったのでいまから振り返って
どういう課題があったのかを検討します。

\subsection{脆弱性}

\subsubsection{POST/GET の使い分け}

当初めんどくさかったのでpostとgetのハンドラを一緒にしてました。よって、
あらゆるページがGETとPOSTの両方で動くようになっています。それを適切にGET
とPOSTにわけるようにしました。

GETは情報の取得のみ、POSTは登録などの副作用のある処理に利用します。

\index{XMLHttpRequest}
ブラウザのセキュリティモデルとして、same-originじゃないとPOSTがやりにく
いようになっています。GETはたとえばscriptタグやimgタグなどを埋め込んでお
けばいくらでも発行できますが、POSTはXMLHttpRequestの発行が必要で、
XMLHttpRequestにはsame-origin policyがあります。

以前は任意のページからscriptタグの埋め込みをして勝手にDebian勉強会に登録
することが可能でしたが、今はそれができないようになっています。
これは勝手に予約するHTMLページの例です:
\begin{commandline}
<html>
  <head>
    <title>auto reserve exploit</title>
    <script
 src="http://localhost:8080/eventregister?eventid=df24a1e1de11c067c461537dce6394e0e51df6ad
&user_prework=&user_attend=attend&user_enkai_attend=enkai_attend&user_realname=myname">
    </script>
  </head>

  <body>
    <h1>auto reserve exploit</h1>
    <p>
      ぼくはまちちゃん
    </p>
\end{commandline}

\subsubsection{HTML escaping}

当時よくわからなかったのとめんどくさかったので入力文字列のサニタイズとかエスケープとかまったくしてませんでした。関西Debian勉強会ではHTMLタグを勉強会の予約ページの案内文に入力して
いたようで、それでこの脆弱性がそもそも存在するのに思い至りました。

任意の文字列をHTMLとして出力できると、任意のjavascriptのコードを実行する
ことができます。たとえば、説明ページを開いた瞬間に予約登録するイベントを作成することができます。

\begin{commandline}
<script>
var xhr = new XMLHttpRequest();
xhr.open('POST', 'http://localhost:8080/eventregister');
xhr.withCredentials = true
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); 
xhr.send('eventid=df24a1e1de11c067c461537dce6394e0e51df6ad&' 
+ 'user_prework=%E3%81%BC%E3%81%8F%E3%81%AF%E3%81%BE%E3%81%A1%E3%81%A1%E3%82%83%E3%82%93&'
+ 'user_attend=attend&user_enkai_attend=enkai_attend&user_realname=hamachi');
</script>
\end{commandline}

\begin{wrapfigure}{r}{0.5\hsize}\includegraphics[width=\hsize]{image201201/xhr.png}\end{wrapfigure}

しかたがないので文字列をエスケープするようにしました。
副作用としてHTMLタグを説明文に打ち込むことができないようになっています。

\subsubsection{任意のURL表示}

Debian勉強会予約システムでは説明文の表示が貧弱な代わりに任意のURLを
iframeで埋め込み表示できるようにしています。通常管理している勉強会のWiki
ページを埋め込むことで二重に情報を管理しなくてすむようにという意図です。

URLの中には特殊なものもあります。\url{javascript:}で始まるURLだとその
Javascriptのコードを実行することができます。できても普通の役には立たなさ
そうなので\url{http://}以外は許可しないようにしておきました。

また、iframe buster と呼ばれる手法によりiframe
から脱出できるようで、そういうページをiframeの中でひらいているつもりにな
るとユーザが誤解する可能性があります。

\index{iframe sandbox}
すべてのブラウザでサポートされているわけではないのですが、iframeに
sandbox属性をつけておきjavascriptなどの実行を制約しておきました。

\subsection{可能性と脆弱性のバランス}

今回いろいろと脆弱性があったのでふさいでみました。しかし、脆弱性を塞ぐの
も、ありうる被害とのバランスで考えるべきだと思います。Debian勉強会に提出
する事前課題が漏洩する、勝手に宴会に参加することになっている等の程度の脆
弱性と、自由にHTMLが記述できる自由とどちらが重要かと考えてみてください。
すこし悩ましいと思いませんか?

\clearpage

%-------------------------------------------------------------------------------
\dancersection{quiltでportingしてみた}{杉本典充}
%-------------------------------------------------------------------------------
\index{quiltでぽーてぃんぐしてみた@quiltでportingしてみた}
\index{porting}
\index{kFreeBSD}
 
\subsection{はじめに}

debianのパッケージ作成で使用しているパッチ管理ツールquiltについて説明します。
またquiltを用いてkFreeBSDのportingパッチを作成しましたので、これについても説明します。

\subsection{Debianパッケージのフォーマット}

現在Debianで使用している主なソースパッケージフォーマットは２つです。
\footnote{東京エリアDebian勉強会 2010年03月号「dpkg ソース形式 "3.0(quilt)"」 吉野与志仁}
\footnote{\url{http://wiki.debian.org/Projects/DebSrc3.0}}

\begin{itemize}
 \item{3.0(native)：tarball１つで構成されたソースパッケージフォーマット}
  \begin{itemize}
   \item{packagename-version.tar.ext}
   \item{packagename-version.dsc}
  \end{itemize}
  \item{3.0(quilt)：あるアップストリームのtarballとDebianパッケージ作成に
必要なtarballに分割しているソースパッケージフォーマット}
  \begin{itemize}
   \item{packagename-upstreamversion.orig.tar.ext}
   \item{packagename-upstreamversion.orig-component.tar.ext（任意）}
   \item{packagename-debianversion.debian.tar.ext}
   \item{packagename-debianversion.dsc}
  \end{itemize}
\end{itemize}

ソースパッケージフォーマットの詳細は `dpkg-source(1)' コマンドで確認することができます。
\footnote{manによると3.0(custom)、3.0(git)、3.0(bzr)というパッケージ形式の定義があるようです。}

アップストリームのソースコードを無修正のままDebianパッケージを作成した場合、
lintian処理でエラーになったり、Debianの開発ポリシーを満たせない場合が
あります（アップストリームのソースコードはIPv6で動作しない、など）。
そのときは、3.0(quilt)のソースパッケージフォーマットでパッケージを作成し、
必要なパッチを当ててからソフトウェアのビルド処理を行うことで対応させます。

\subsection{quiltパッケージ}
quiltはdebianパッケージを作成するときにパッチファイルを管理するツールとして
採用しているソフトウェアです。
Debianパッケージとして提供しており、aptでインストールできます。

\begin{commandline}
# apt-get update
# apt-get install quilt
\end{commandline}

quiltコマンドは複数のpatchファイルをスタックに積んだようなイメージで、
パッチの適用順番を管理します。
\footnote{東京エリアDebian勉強会 2007年01月号「パッチ管理ツールquiltの使い方」小林儀匡}
quiltコマンドを使うことで、パッケージ作成に必要なパッチが複数ある場合も
正しく適用でき、不要なパッチが出てきたときにそのパッチを取り除くことが容易に
なります。


\subsection{quiltの使用例：Debian GNU/kFreeBSD向けのportingパッチ作成}

\subsubsection{Debian GNU/kFreeBSDとは}
Debian Projectで開発しているOSはLinuxカーネルを用いた「Debian GNU/Linux」が有名ですが、
Linuxカーネル以外を用いたDebianがあります。その１つとしてFreeBSDカーネルを用いた「Debian GNU/kFreeBSD」
\footnote{\url{http://wiki.debian.org/Debian\_GNU/kFreeBSD}}があり、ユーザランドはDebianなので APT が使え、
デバイスやシステムコールといったカーネル特有の機能はFreeBSDカーネルに準じる、という特徴があります。
Debuan GNU/kFreeBSDは安定版のリリースには至っていませんが、日々開発が続けられています。
本稿では以降「Debian GNU/kFreeBSD」を「kfreebsd」と略記します。

\subsubsection{kfreebsdのporting作法}
Debianのporting関連情報およびkfreebsdのporting情報は以下にあります。

\begin{itemize}
 \item{\url{http://www.debian.org/ports/}}
 \item{\url{http://www.debian.org/ports/kfreebsd-gnu/}}
 \item{\url{http://glibc-bsd.alioth.debian.org/porting/}}
\end{itemize}

「\url{http://glibc-bsd.alioth.debian.org/porting/PORTING}」を読むと
kfreebsd向けにportingするには以下の確認および修正が行うようにとあります。

\begin{itemize}
 \item{Add our system name to checks here and there}
  \begin{itemize}
   \item{Makefileやスクリプト中のunameなどをチェックしてください。 }
  \end{itemize}
 \item{debian/control files}
  \begin{itemize}
   \item{debian/controlファイルでArchitectureをlinux専用ソフトウェアの場合は「linux-any」等、
CPUの違いのみでLinux、kfreebsdは関係なく使用できるソフトウェアの場合は「any-i386」等に変更してください。}
  \end{itemize}
 \item{Libraries, your beloved enemy}
  \begin{itemize}
   \item{libtool、aclocal.m4周りに対応してください。}
  \end{itemize}
 \item{Preprocessor Variables}
  \begin{itemize}
   \item{kfreebsdのシステムマクロは「\_\_FreeBSD\_kernel\_\_」、
バージョンマクロは「\_\_FreeBSD\_kernel\_version」なので対応してください。}
  \end{itemize}
 \item{Writing to devfs (kFreeBSD)}
  \begin{itemize}
   \item{FreeBSDカーネルでは（udevではなく）devfsを使うようにしてください。}
  \end{itemize}
 \item{RT signals}
  \begin{itemize}
   \item{FreeBSDカーネルは「POSIX RT (realtime) signals」がないので変更してください。}
  \end{itemize}
 \item{Get libc soname (6 or 6.1 on linux-gnu, 0.1 on kfreebsd-gnu, etc)}
  \begin{itemize}
   \item{使用するlibcの名前をハードコードしているプログラムがあれば修正してください。}
  \end{itemize}
\end{itemize}


\subsubsection{kfreebsdに対応させたいパッケージとその原因}

今回portingするパッケージは既にkfreebsd用パッケージとして存在している
icewmとなります。
icewmはウィンドウマネージャのソフトウェアで軽快な動作をするのが特徴です。
icewmではタスクバーにバッテリー残量アイコンを表示する機能がありますが
kfreebsdでは表示されません。linux-i386及びlinux-amd64では表示されるため
kfreebsdのportingが不完全の可能性があります。

まずはビルド準備とソースコードのダウンロードを行います。

\begin{commandline}
# apt-get update
# apt-get build-dep icewm
$ apt-get source icewm
\end{commandline}
%$

ソースコードを「\_\_FreeBSD\_\_」及び「\_\_linux\_\_」grepすると、電源周りの処理で以下のマクロが検出されます。
\begin{commandline}
$ cd icewm-1.3.7/src
$ grep -nr __FreeBSD__ *
aapm.cc:30:#ifdef __FreeBSD__
aapm.cc:74:#if defined(__FreeBSD__) && defined(i386)
aapm.cc:99:#if defined(__FreeBSD__) && defined(i386)
aapm.cc:273:#ifndef __FreeBSD__
aapm.cc:333:#ifndef __FreeBSD__
aapm.cc:418:#ifndef __FreeBSD__
aapm.cc:463:#ifdef __FreeBSD__
aapm.cc:885:#ifndef __FreeBSD__
aapm.h:2:#if defined(linux) || (defined (__FreeBSD__)) || (defined(__NetBSD__) && defined(i386))
（以下略）
$ grep -nr __linux__ *
(なにもなし)
\end{commandline}
%$

\_\_FreeBSD\_\_マクロはFreeBSD OSを示すマクロですが、kfreebsdでは「\_\_FreeBSD\_kernel\_\_」がシステム（厳密にはカーネル）を示すマクロです。そのためマクロでシステムを切り分けているはずがkfreebsd向けのパッケージビルド時にLinuxカーネル向けの処理が有効なコードとしてビルドされてしまいバッテリー残量アイコンの表示がうまく動作していないようです。

そのため、今回はこのマクロを「PORTING」の記述に従って以下のような修正を行います。

\begin{commandline}
（修正前）#ifdef __FreeBSD__

（修正後）#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
\end{commandline}
これで修正方針が定まりましたので、debianパッケージ作成に向けてパッチを作成していきます。

\subsection{quiltの登場}
今回は新規のパッチファイルとなるため、quiltのパッチスタックに新規追加します。
まず、debian/patches/series 記述されておるパッチスタックを見てみます。

\begin{commandline}
$ tail -4 debian/patches/series
tray_hotfixes
imap_unseen
ifstate_exact_check
debian-changes-1.3.7~pre2-1.1
\end{commandline}
%$

次に\texttt{quilt new} を実行し、現在の変更内容を kfreebsd\_porting\_aapm
というファイル名で保存し、スタックに追加します。
 
\begin{commandline}
$ quilt new kfreebsd_porting_aapm
Patch kfreebsd_porting_aapm is now on top
\end{commandline}

実行下後のパッチスタックは以下のようになります。

\begin{commandline}
$ tail -4 debian/patches/series
imap_unseen
ifstate_exact_check
debian-changes-1.3.7~pre2-1.1
kfreebsd_porting_aapm
\end{commandline}
%$

これでパッチを追加できる準備ができました。
次にportingするために修正を行うソースファイルをquiltで管理するように登録処理をします。
その後「quilt edit ソースファイル」を実行すると、環境変数EDITORで登録したエディタが自
動で起動しますのでソースファイルの修正作業を行います。


\begin{commandline}
$ quilt add src/aapm.h
File src/aapm.h added to patch kfreebsd_porting_aapm

$ quilt edit src/aapm.h
File src/aapm.h is already in patch kfreebsd_porting_aapm

$ quilt refresh
Refreshed patch kfreebsd_porting_aapm

$ quilt add src/aapm.cc
File src/aapm.cc added to patch kfreebsd_porting_aapm

$ quilt edit src/aapm.cc
File src/aapm.cc is already in patch kfreebsd_porting_aapm

$ quilt refresh
Refreshed patch kfreebsd_porting_aapm
\end{commandline}

できたパッチファイル「kfreebsd\_porting\_aapm」を確認します。

\begin{commandline}
$ cat debian/patches/kfreebsd_porting_aapm
Index: icewm-1.3.7/src/aapm.h
===================================================================
--- icewm-1.3.7.orig/src/aapm.h 2010-10-31 23:09:36.000000000 +0900
+++ icewm-1.3.7/src/aapm.h      2011-12-10 23:17:15.000000000 +0900
@@ -1,10 +1,10 @@

-#if defined(linux) || (defined (__FreeBSD__)) || (defined(__NetBSD__) && defined(i386))
+#if defined(linux) || (defined (__FreeBSD__)) || (defined (__FreeBSD_kernel__)) || ((defined(__NetBSD__) && defined(i386))

 #include "ywindow.h"
 #include "ytimer.h"

-#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__)
 #define APMDEV "/dev/apm"
 #else
 #define APMDEV "/proc/apm"
（以下略）
\end{commandline}
%$

あとはパッケージをビルドします。

\begin{commandline}
$ dch
$ debuild -uc -us
\end{commandline}
%$

作成したパッケージをインストールして確認します。
\begin{commandline}
$ sudo dpkg -i icewm-common_1.3.7-1.1_kfreebsd-amd64.deb icewm_1.3.7-1.1_kfreebsd-amd64.deb
$ reboot
\end{commandline}
%$

作成したパッチはバグレポートと共にBTSへ送信しておきましょう。

\begin{commandline}
$ reportbug
$ w3m http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=650395
\end{commandline}
%$

\subsection{終わりに}
これでkfreebsdのicewmウィンドウマネージャ上でバッテリー残量アイコンを表示することができました。

みなさんもkfreebsd含め様々なアーキテクチャで数多くのパッケージがDebianで動作するようにがんばりましょう。

\begin{thebibliography}{0}
 \bibitem{debmtg-quilt} 東京エリアDebian勉強会 2007年01月号「パッチ管理ツールquiltの使い方」小林儀匡
 \bibitem{debmtg-dpkg-quilt} 東京エリアDebian勉強会 2010年03月号「dpkg ソース形式''3.0(quilt)''」 吉野与志仁
 \bibitem{dpkg-source-man} man dpkg-source(1), man quilt(1)
 \bibitem{quilt-man} man quilt(1)
 \bibitem{debsrc3} DebSrc 3.0 \url{http://wiki.debian.org/Projects/DebSrc3.0}
 \bibitem{maint-guide-ja} Maint Guide 日本語版\url{http://www.debian.org/doc/manuals/maint-guide/first.ja.html}
 \bibitem{kfreebsd-wiki} kFreeBSD wiki \url{http://wiki.debian.org/Debian\_GNU/kFreeBSD}
 \bibitem{bsd-porting} porting glibc to BSD \url{http://glibc-bsd.alioth.debian.org/porting/}
\end{thebibliography}
 
\clearpage

%-------------------------------------------------------------------------------
\dancersection{Debianの使えるVPSを使ってみた}{上川 純一}
%-------------------------------------------------------------------------------
\index{vps}

自宅サーバ最強だと思っていた時期が僕にもありました、が幼少な子供が自宅に
いると破壊活動に従事される可能性があり、自宅は設置したマシンを安定してサー
バとして稼働させるのに適した環境とはいえません。また、つけっぱなしにして
いると音がうるさいので静音PC化とかにこだわるのですが、そろそろそれにも飽
きてきました。静音のためにファンレスにしとくと夏気づいたら熱暴走してます。
また、PCは自宅の消費電力の中でも大きな割合を占めてました。

しかし、常時走っているノードがないと、リグレッションテストを走らせること
すらできません。
我慢できなくなってきたので、Debianノードで好きなようにいじれるようなサービスを
探して試してみました。2012年1月15日時点の情報です。\footnote{2012年6月現在：半年後みたらまた状況が変わってたので当時の状況の参考程度の情報です}
近年IaaSクラウドとかいうバズワードがあってよくわからなくなっているのですが、
ここで僕の欲しいサービスは多分仮想プライベートサーバ（略してVPS）です。

\subsection{さくらインターネットのVPS}
\index{さくらいんたーねっと@さくらインターネット}
\index{kvm}

KVMのノードがひとつ手に入ります。

デフォルトではCent OS がはいった状態で起動するのですが、Debian をインストー
ルするメニューがブラウザで利用する管理画面で選択できます。Debianのインストー
ルを選択すると、Debian Installerが起動し、Java Applet のVNCクライアント経
由でコンソール画面を見ながらインストールします。

良くも悪くもDebian Installerですが、一部カスタマイズされているようで、
例えば、sshがデフォルトでインストールされるようになっています。
公開鍵認証にしたい場合はあとで自分でsshの公開鍵を登録すればいいと思います。

ブラウザで利用する管理画面で再起動とかVNCでコンソール画面に接続するなどのメン
テナンスが行えます。

使用料金は「さくらのVPS 512」で980円/月です。
支払いはクレジットカード以外の方法もありますが、クレジットカードだと二週
間の無料お試しが可能なようです。
利用を開始すると住所の確認のためにハガキが送られてきてその中に書いてある
お知らせ番号を入力させられます。
日本国内に住所があることが利用の条件です。

\subsection{Amazon AWS EC2}
\index{Amazon AWS EC2}
Xenのノードがひとつ手にはりいます。既存のDebian の AMI \footnote{Amazon
Machine Image: / のファイルシステムイメージのようで
す}\cite{debianec2image}をクローンする感じでインスタンスが立ち上がります。
自分でAMIをつくってもいいみたいです。

ブラウザで利用する管理画面からインスタンスの再起動などが行えます。

ブート時のログが制御コンソールから見れますが、コンソール接続する方法は見
つけられませんでした。起動に失敗したらAMIからつくりなおせばいいという発想
なんでしょうか。

初回時の接続は公開鍵認証のSSHでrootユーザとして接続します。ログインはイン
スタンスを作成するウェブインタフェースにて作成した公開鍵認証です。

使用料金は一時間あたり10セント程度で東京リージョンのスモールインスタンス
が借りれます。

最初の開始の利用手続きでは、Amazon.comのアカウントをつかって登録します、
その際に電話番号を確認のために電話がかかってきます。クレジットカードが必
要です。

\subsection{S@@Ses}
\index{xen}

XenベースでのVPSサービスを提供しています。
LTサーバであれば月450円で利用できるようです。
初期費用3000円かかるというのと3ヶ月単位の契約だというので僕は試してませ
ん。最初に二週間のお試し期間があるようです。

ブラウザで利用する管理画面からインスタンスの再起動などが行えます。

OSの初期化メニューからのOSの選択肢にLenny や Squeeze があり、それを選択
するとインストール済みのXenのイメージが立ち上がり、root で ssh ログイン
できるようになります。

\subsection{まとめ}

参考のため、各社の手頃っぽいエントリーモデルを並べてみました\footnote{AWS EC2が高く
見えるけど、 micro instanceのspot instanceにすればもっと安いです。}。

\begin{tabular}{|l|p{11em}|p{12em}|p{11em}|}
\hline
 & さくらのVPS 512 & AWS EC2 Small & S@@ses LT \\
\hline
使用料金 & 980円 / 月& \$0.10/時間 & 450 / 月(3ヶ月単位) + 3000円初期料金\\
CPU & 仮想 2 core & 1 ECU & 2.66GHz\\
メモリ & 512MB & 1.7GB& 512MB \\
ディスク & 20GB & 160GB & 50GB \\
仮想化技術 & KVM & Xen & Xen \\
コンソールアクセス & VNC経由 & ? & ? \\
Debian利用 & 
ブラウザで利用する管理画面にD-I起動するメニューあり、VNC経由でD-Iからインストール& 
Debian AMIをさがしてきてブラウザで利用する管理画面から起動するとroot に ssh 可能なインスタンス & 
ブラウザで利用する管理画面のメニューから初期化を選択すると root に ssh可能な状態のインスタンス \\
\hline
\end{tabular}

\subsection{さいごに}

ほかにもいろいろサービスがあるみたいですが、Debianが利用できるVPSサービ
スが日本でも充実してきたのだなという感想です。

各社ストレージ構成がどうなっているのかバックアップ体制がどうなっているの
かなどの記述がみあたらないので、障害発生の確率とか障害発生時の対応がどう
なのか予想もつきません。そういう情報は価格競争が一旦収束して、
業界が成熟してから重要になるのかもしれません。

個人的にはとりあえずさくらインターネットを使ってみることにしてみました。

\begin{thebibliography}{0}
 \bibitem{aws} Amazon Web Services \url{http://aws.amazon.com/jp/}
 \bibitem{sakuravps} VPS(仮想専用サーバ)のさくらインターネット
	 \url{http://vps.sakura.ad.jp/}
 \bibitem{saases} SaaSes \url{http://www.saases.jp/}
 \bibitem{debianec2image} Debian Wiki: Cloud Amazon EC2 Image \url{http://wiki.debian.org/Cloud/AmazonEC2Image}
\end{thebibliography}

\clearpage

%-------------------------------------------------------------------------------
\dancersection{Debianでtwitter連携}{岩松 信洋}
%-------------------------------------------------------------------------------
\index{twitter}

Debian の作業内容を Twitter に投げていたら 上川さんにどんなことやっているのか
紹介して欲しいとの連絡がありました。
今回は Debian からどのようにして Twitter を使っているのか、
使うにはどのようにしたらいいのか説明します。

\subsection{Twitter API について}
\index{twitter api}

Twitter は、 ユーザーが「ツイート」と呼ばれる 140 文字の「つぶやき」を投稿し、 
そのツィートを閲覧したりツィートに対してさらにツィートしたりなど、
コミュニケーションするためのサービスです。
Twitter ではこの「ツィート」を投稿、削除、参照、検索などをプログラムから
行えるように API を公開しています。これを Twitter APIといいます。
Twitter がサービスとして公開しており、利用するためには利用規約に同意する
必要があります。

またTwitter API は大きく分けて、REST、Search、Streaming の3種類があります。
REST API はツイートの更新や参照などを行う基本的なAPI、
Search API はツイートを検索するAPI、
Streaming API はタイムラインをリアルタイムに受け取るためのAPIです。
また、これらのAPIを使うためにはアクセス用のIDが必要で、
利用できるAPIの回数なども決まっています。
APIを使うにはこのIDを使った認証処理が必要になります。
APIをラッパーし、Twitter APIを使いやすくするためのTwitter API用のライブラリが
いくつか存在します。

\subsection{Debian での Twitter APIサポート状況}

まず、Debian でのtwitter周りの整備状況を確認してみます。
言語毎に Twitter API 用のパッケージが整備され、
表\ref{tab:twitterpakcages}のようにパッケージが提供されています。
メジャーな言語ではいくつかライブラリがあるようですが、手の足りていない
言語チームでは整備が遅れているようです。興味のある方はメンテナンスに参加
してみてはいかがでしょうか。

\begin{table}[ht]
 \caption{Debian で提供されている各言語用のパッケージ}
 \label{tab:twitterpakcages}
\begin{center}
  \begin{tabular}{|c|c|}
 \hline
 言語 & パッケージ名 \\
 \hline
 C, C++ & libsocialweb, bitlbee, etc. \\
 Perl & libnet-twitter-lite-perl, libnet-twitter-perl \\
 Python & python-twyt, python-tweepy, python-twitter \\
 Ruby & libtwitter-ruby1.x \\
 Haskell & なし（パッケージになってない） \\
 OCaml & なし（パッケージになってない） \\
 \hline
 \end{tabular}
\end{center}
\end{table}

\subsection{Debian から Twitter APIを使ってみる}

次に Ruby の Twitter API用ライブラリを使った簡単な例を紹介します。
例えば、「test」というツィートをポストするアプリケーションを作成するには以下の順番で行います。

\subsubsection{Twitterアプリケーション登録申請}

\url{https://dev.twitter.com/}にアクセスし、
OAuthを利用するにあたり必要となる、Consumer key、Consumer secret等を取得します。
これらのデータはTwitterアプリケーション毎に異なります。
アプリケーション名を「api-test」とした場合、以下のような内容で適当なファイルに保存します。
\begin{commandline}
api-test:
    login: iwamatsu
    oauth_consumer:
        key: XXXXXX
        secret: XXXXX
    oauth_access:
        key: XXXXX
        secret: XXXXX
\end{commandline}

\subsubsection{パッケージをインストールする}
\index{libtwitter-ruby1.9.1}

インストールは apt-get で行えます。

\begin{commandline}
$ sudo apt-get install libtwitter-ruby1.9.1
\end{commandline}
%$

\subsubsection{Twitter API ライブラリを使ったソースコードと実行}

コードは以下のようになります。
Twitterアプリケーション登録申請したときに取得した「Consumer key」等を
保存したファイルを「/home/hoge/.twitter.yml」、アプリケーション名として指定し
インスタンスを生成します。そして status メソッドで「test」をポストするようにします。

\begin{commandline}
$ cat test.rb
#!/usr/bin/ruby

require 'twitter'
twitter = Twitter::Client.from_config("/home/hoge/.twitter.yml", "api-test")
twitter.status(:post, "test");

$ ruby ./test.rb
\end{commandline}
%$

以上がDebian から Twitter API を使う例となります。

\subsection{私が使っているツール紹介}

Twitterはメモや作業内容などを通知をする場合に非常に便利なツールです。
Debian の作業内容などを通知できないかなと思っていくつかTwitter用ツールを作成
したので紹介します。

\subsubsection{Debian Hack Cafe 通知ツール}

毎週東京/関西のどこかで行われていると言われている Debian Hack Cafe。
Hack Cafe開催通知を行うためのアカウントとして @debian\_hackcafe があります。
これは Debian Hack Cafe GPGキーリングに登録された人なら誰でもつぶやけるという
特徴があります。
つぶやく場合、libwww-perl パッケージに含まれる lwp-request を使ってつぶやきを
サーバにPOST するとサーバで処理が行われ、問題がない場合 @debian\_hackcafe アカウント
としてつぶやきます。

\begin{commandline}
$ sudo apt-get install libwww-perl
$ echo "つぶやき" | gpg --clearsign | \
  lwp-request -m POST http://www.nigauri.org/debian_hackcafe_post
\end{commandline}

このシステムは以下のように処理されます。

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.7\hsize]{image201201/debianmeeting201201-imagedata-twgw.eps}
\caption{Debian Hack Cafe 通知ツール構成図}
\label{fig:debian-kernel-team}
\end{center}
\end{figure}

\begin{enumerate}
\item つぶやきをGPGサインしてサーバにポスト
\item サーバで鍵のサインをチェック
\item 署名からGPGキーIDを取得し、ID管理DBからGPGキーIDに紐づくTwitterIDを取得
\item つぶやきに ID をいれて Twitter APIを使ってつぶやく 
\end{enumerate}

このようにすることで Twitter のアカウントとパスワードを共有することなく、
限定されたされたメンバで、つぶやくことができます。
PGP/GnuPG を使って署名チェックするなんて Debian らしくてかっこいい！
と個人的に思っています。

また、このシステムを Debian JPアカウント（@debianjp）用にアップデートし、
運営できるようにする予定です（今までは運営している人たちでアカウントとパスワード
を共有していたようです）。また Debian JP の誰がつぶやいていたのかわからないという
問題も解決する予定です。

\subsubsection{パッケージがアップロードされたらつぶやく dput-tweet}
\index{dput-tweet}

最近スポンサーアップロードを行う事が多くなりました。またスポンサーしている人は
Twitterのアカウントを持っているので、アップロードした旨を通知する方法の一つとして
Twitter を使うようにしました。この通知を行うツールが dput-tweet です。
Ruby の勉強用に作ったツールで、dput のラッパーになっており、dput したらパッケージ名と
バージョンスポンサーした人のTwitterIDをつぶやくというものです（図\ref{fig:dput-tweet-v1}）。
このツールのいけてない点として、dput しか対応できてない事と実行時にスポンサーする人のTwitter IDを指定する
必要がある事です。

\begin{commandline}
$ dput-tweet -s mkouhei ordereddict_1.1-1_amd64.changes
....
「dput ordereddict_1.1-1 @mkouhei [dput-tweet] 」とつぶやきます。
\end{commandline}
%$

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.7\hsize]{image201201/debianmeeting201201-imagedata-v1.eps}
\caption{パッケージアップロード通知ツール dput-tweet v1}
\label{fig:dput-tweet-v1}
\end{center}
\end{figure}

もっと楽をしたいと思ったので、今は inotfy を使って upload ファイルが作成されたらつぶやく
機構にしました。これによって dput / dupload の両方に対応できます。
また upload ファイルから changes ファイルを抽出し、Changed-By の行から 得たメールアドレスを元に
TwitterID を DB から取得し、つぶやきに入れるようにしました（図\ref{fig:dput-tweet-v2}。

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.7\hsize]{image201201/debianmeeting201201-imagedata-v2.eps}
\caption{パッケージアップロード通知ツール dput-tweet v2}
\label{fig:dput-tweet-v2}
\end{center}
\end{figure}

\subsection{まとめ}
いくつかのツールを作ってみて、Twitter APIの使い方がわかってきました。
今度は Debian JP メンバの活動Tweetなどができるようにしたり、
Twitter だけでなく
FacebookなどのサービスのAPIについても調べてみようと思います。

\clearpage

%-------------------------------------------------------------------------------
\dancersection{月刊debhelper 第2回}{野島 貴英}
%-------------------------------------------------------------------------------
\index{げっかんでぶへるぱー@月刊debhelper}
\index{debhelper}

\subsection{はじめに}

Debianパッケージを作成する際、沢山の処理をdebian/rulesというファイルに
GNUのmakeのmakefileの形式で記述することになります。しかしながら、細かい処理を
記載していくと膨大な量となってしまいます。
これをできるだけ簡潔に記載できるように考えられたツールとしてdebhelperという
コマンド群が存在します。

本企画はこのdebhelperのコマンドについて、毎月持ち回りで解説していくという
ものです。ルールは、毎月2つ以上のコマンドを解説し、次回発表の立候補が無い場合は
発表者が次の発表者を決めれるというルールの元に進めて行きます。

\subsection{今月のコマンドその1:dh}

\subsubsection{dhの動作概要}
\index{dh}
dhは引数に指定したシーケンス名に基づいて一連のdebhelperを起動するコマンドとなります。実際の使い方では、以下の内容をdebian/rulesに記述して利用します。

\begin{commandline}
$ cat debian/rules
#!/usr/bin/make -f
%:
        dh $@
\end{commandline}
% $

\subsubsection{dhに指定できるシーケンス名}
\label{sec:debhelper-sequences}
dhに指定できるシーケンス名は表\ref{tab:sequence-dh-name}の通りです。

\begin{table}[ht]
\begin{center}
\small
\begin{tabular}{|p{8em}|p{35em}|}
\hline
シーケンス名&シーケンスの説明 \\
\hline
binary & 構築からパッケージ作成まで実行するシーケンスです。\\
binary-arch & arch依存のパッケージの構築からパッケージ作成まで実行するシーケンスです。\\
binary-indep & arch非依存のパッケージの構築からパッケージ作成まで実行するシーケンスです。\\
build & 構築からテストまで実行するシーケンスです。\\
build-arch & arch依存のパッケージの構築からパッケージ作成まで実行するシーケンスです。\\
build-indep & arch非依存のパッケージの構築からパッケージ作成まで実行するシーケンスです。\\
clean &　一度パッケージを構築したディレクトリから、パッケージ構築時に生成したものを取り除き、構築ディレクトリを綺麗にします。\\
install & 構築から、パッケージ生成直前までの処理を行うシーケンスです。\\
install-arch & arch依存のパッケージについて、構築から、パッケージ生成直前までの処理を行うシーケンスです。\\
install-indep & arch非依存のパッケージについて、構築から、パッケージ生成直前までの処理を行うシーケンスです。\\
\hline
\end{tabular}
\caption{dhで指定できるシーケンス名一覧}
\label{tab:sequence-dh-name}
\end{center}
\end{table}

なお、--with fooを指定すると、dhに指定可能なシーケンスが増える場合があります(例： --with quiltのpatchシーケンス等。）

\subsubsection{dhのコマンドラインオプション}

表\ref{tab:sequence-dh-opts}にdhのコマンドラインオプションを載せます。(man dhより)

\begin{table}[ht]
\begin{center}
\small
\begin{tabular}{|p{10em}|p{33em}|}
\hline
オプション&説明 \\
\hline
--with addon[,addon ...] & debhelperコマンドに適切な場所で一連のコマンドを実行するような付加機能(addon)を指定します。\\
\hline
--without addon　& --withとは逆の働きをします。指定された付加機能を使わないようにします。\\
\hline
--list, -l & 利用可能な付加機能(addon)一覧です。\\
\hline
--no-act & 指定された一連の処理の内容を表示するだけコマンドとなります。表示だけして実際にはコマンドを実行しません。\\
\hline
その他 & dhに、先に記載した以外の何かオプションを渡すとそれはのちに実行する全コマンドへ引き渡されます。-v、-X、-Nや、他の特別なオプションを指定するのに使われます。\\
\hline
\end{tabular}
\caption{コマンドラインオプション一覧}
\label{tab:sequence-dh-opts}
\end{center}
\end{table}

この他にも、debhelperコマンド共通で使えるコマンドラインオプションがman debhelperに
記載されており、dhコマンドでも利用できます。こちらも参照ください。

\subsubsection{廃止されたコマンドラインオプション}

--until,--before,--after,--remainingがありましたが、これらは全部dhが解釈する
``override\_{\em DHコマンド名}ターゲット''による動作に置き換えられた為、{\em 廃止}となりました。

なので、昔のdebian/rulesにあるような、以下の用な書き方は{\em 廃止}です。

\begin{commandline}
廃止された書き方
#!/usr/bin/make -f

%:
        dh $@

build: build-stamp
build-stamp:
        dh build --before configure
        dh_auto_configure -- --with-gnu-ld --disable-nls
        dh build --after configure
        touch build-stamp
\end{commandline}
%$

代わりの書き方は次の章で述べます。

\subsubsection{``override\_{\em debhelperコマンド名}''ターゲットについて}

dhコマンドは''dh シーケンス名''により、そのシーケンスに必要な一連のdebhelperコマンドを呼び出す機能があります。(どんなdebhelperコマンドが呼び出されるかは、--no-actをオプションにつけて、dh --no-act buildとか、dh --no-act installとかして見てください）

この呼び出されるコマンドを一部変更したい場合は以下のように書きます。

\begin{commandline}
今時の書き方：
#!/usr/bin/make -f

%:
        dh $@

override_dh_autoconfigre:
        dh_auto_configure -- --with-gnu-ld --disable-nls
\end{commandline}
%$

こうすると、本来であれば、dh\_auto\_configureがオプション無しで呼び出される場所が全部
``dh\_auto\_configure -- --with-gnu-ld --disable-nls''で呼び出されるようになります。

他の例として、configureスクリプトが無く、代わりにImakefileがあるような古いX用のプログラムを
パッケージにする用な場合は以下のように書きます。

\begin{commandline}
Imakefileを利用するような場合：
#!/usr/bin/make -f

%:
        dh $@ --with quilt

override_dh_auto_configure:
        xmkmf -a
\end{commandline}
%$

こうすると、本来であれば、dh\_auto\_configureが呼び出される場所全部で、
``xmkmf -a''を呼び出すようになります。

この''override\_{\em debhelperコマンド名}''ターゲットは、コマンドを{\em 実行したくない場合}にも利用可能です。(``override\_{\em debhelperコマンド名}''のアクションを空にする事がミソです。)

\begin{commandline}
dh_auto_test,dh_compress,dh_fixpermsを実行したく無い場合：
#!/usr/bin/make -f

%:
        dh $@ 

override_dh_auto_test override_dh_compress override_dh_fixperms:

\end{commandline}
%$


また、build-arch,binary-arch,build-indep,binary-indepターゲットがdhに
指定されるときにあわせて振る舞いを変更したい場合は
''override\_{\em debhelperコマンド名}-indep''や、
''override\_{\em debhelperコマンド名}-arch''を
使って、それぞれの場合にdhによって呼び出されるコマンドを
変更できます。以下の例では、ドキュメントパッケージの作成に時間がかかるので、build-indepや、
binary-indepの時にだけドキュメントを作成してくれるようにする場合のdebian/rulesとなります。

\begin{commandline}
ドキュメント作成を分離して、時間のかかるドキュメント作成が何度も実行されないようにする:
#!/usr/bin/make -f
%:
        dh $@

override_dh_auto_build-indep:
        $(MAKE) -C docs

# No tests needed for docs
override_dh_auto_test-indep:

override_dh_auto_install-indep:
        $(MAKE) -C docs install

\end{commandline}
%$

\subsubsection{addonについて}

dhコマンドのオプション--with addonにてaddonが提供するパッケージの作成方法を組み込む
事ができます。お使いのシステムで現在どんなaddonが使えるかはdh --listを実行すると一覧
が出てきます。

\begin{commandline}
$dh --list
bash-completion
dkms
python-central
python-support
python2
quilt
tex
$
（...お使いのシステムによって表示される量が変わります...)
\end{commandline}

実はこれらは/usr/share/perl5/Debian/Debhelper/Sequence/''addon名''.pmとして
インストールされています。こちらを利用して、現在のDebianで、どんなaddonが提供されているかを
知りたければ、次のようにして調べる事ができます。

\begin{commandline}
$ apt-file search Debhelper/Sqeuence
autotools-dev: /usr/share/perl5/Debian/Debhelper/Sequence/autotools_dev.pm
bash-completion: /usr/share/perl5/Debian/Debhelper/Sequence/bash_completion.pm
cli-common-dev: /usr/share/perl5/Debian/Debhelper/Sequence/cli.pm
...中略...
sphinx-common: /usr/share/perl5/Debian/Debhelper/Sequence/sphinxdoc.pm
tex-common: /usr/share/perl5/Debian/Debhelper/Sequence/tex.pm
xserver-xorg-dev: /usr/share/perl5/Debian/Debhelper/Sequence/xsf.pm
xulrunner-dev: /usr/share/perl5/Debian/Debhelper/Sequence/xulrunner.pm
$ apt-file search Debhelper/Sqeuence | wc -l
43
$
\end{commandline}
% $
全部で43個もありますね。(debian sidで実行）

複数addonを指定したい場合は繰り返し--withオプションで指定したり、カンマで区切って指定します。

\begin{commandline}
quilt用のaddonと、autotools_dev用のaddonを併用したい時：
#!/usr/bin/make -f
%:
        dh $@ --with quilt --with autotools_dev
#       dh $@ --with quilt,autotools_dev　もOK
\end{commandline}
%$

\subsubsection{addonの構造について}

addonが何をしているかは/usr/share/perl5/Debian/Debhelper/Sequence/''addon名''.pm
を覗くとピンときます。

例えば、--with quiltの場合、

\begin{enumerate}
 \item dh cleanにて、dh\_cleanを呼び出す前に、quiltパッケージが一緒に提供しているdh\_quilt\_unpatchコマンドを呼び出すようになります。
 \item dh buildでは、dh\_auto\_configureの前にdh\_quilt\_patchを呼び出すようになります。
 \item dhにシーケンス名patchが追加され、dh patchが使えるようになります。
\end{enumerate}

addonを自分で書く場合は、dh内で定義されている表\ref{tab:dh-api}のAPIを呼び出して書いてください。

\begin{table}[ht]
\small
\begin{center}
\begin{tabular}{|p{20em}|p{23em}|}
\hline
API名&APIの説明 \\
\hline
insert\_before(\$existing,\$new) & \$existingで指定されるdebhelperコマンドを実行する直前に\$newを実行します。\\
\hline
insert\_after(\$existing,\$new) & \$existingで指定されるdebhelperコマンドを実行した直後に\$newを実行します。\\
\hline
remove\_command(\$command) & \$commandをdhが実行しないようにします。\\
\hline
add\_command(\$command,\$sequence) & \$sequenceで示されるシーケンスで実行されるコマンド群の最後に\$commandを付け加えます。また、本APIを使って\ref{sec:debhelper-sequences}章で示されないシーケンスを新たに作成することができます。\\
\hline
add\_command\_options(\$command,@options) & \$commandに、配列@optionsで示される一連のオプションを付け加えて実行するようにします。\\
\hline
remove\_command\_options (\$command,@options) & \$commandから配列@optionsで示される一連のオプションを取り除く。@optionsをまったく指定せずにremove\_command\_options(\$command)と呼び出すと、\$commandについてのオプション全部を取り除きます。\\
\hline
\end{tabular}
\caption{addon用のAPI一覧}
\label{tab:dh-api}
\end{center}
\end{table}

量もそんなになく、非常にわかりやすいので、興味のある人は/usr/share/perl5/Debian/Debhelper/　Sequence/quilt.pmを試しに読んでみるとよいと思います。

なお、複数のaddonを指定した場合、同じ内容のdebhelperコマンドが意図せず複数回も同じシーケンスに挿入される事がありますが、きちんと１個の呼び出しにまとめてくれます。

\subsubsection{dhの内部動作}

dhコマンドはdebian/rulesがmakeファイルである事を利用しながら、makeコマンドと協調して動作します。

図\ref{fig:dh-internal-schema1}にdpkg-buildpackageを呼び出したときの
dhの内部動作を示します。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=17cm]{image201112/dh-internal-schema1.png}
  \end{center}
  \caption{dh内部動作}
  \label{fig:dh-internal-schema1}
\end{figure}

図\ref{fig:dh-internal-schema1}から判るように、dpkg-buildpackageから
makeコマンドが起動され、次にdhが起動され、
さらにdhからmakeが起動されるという関係になっている事が判ります。また、
override\_{\em debhelperコマンド名}ターゲットの処理を行うのに、makeコマンドを使って
処理をしているという事も判ります。

dhを使うと、makeコマンドはoverride\_{\em debhelperコマンド名}ターゲットの処理をする役目だけを
担当します。
そのうち、dhコマンドが進化すると、makeコマンドの力を借りなくてもパッケージ作成ができるようになる
かもしれませんね。

\subsubsection{``debian/パッケージ名.debhelper.log''ファイルについて}

最近のdhコマンドを使うdebian/rulesには、ファイルの依存関係についての記載がありません。この為、パッケージビルド中で処理が中断した場合、どこから再開すれば良いかをdebian/rulesでmakeが判定する事はできません。

実は、dhコマンドはclean以外のシーケンスが指定されると、''debian/パッケージ名.debhelper.log''というファイルに処理を行ったdebhelperコマンドを記録しています。ここで、万一dhの処理が中断した場合、処理をどこから始めれば良いかについてはこのログファイルを参照して処理の再開を行います。

``debian/パッケージ名.debhelper.log''の中身は以下のようになっています。

\begin{commandline}
debian/パッケージ名.debhelper.logの中身:
dh_auto_test
dh_prep
dh_installdirs
...中略...
dh_buiddeb
\end{commandline}

また、このファイルはdh cleanによって消去されます。なお、dh cleanの時には、このログファイルは作成されません。つまり、dh cleanの処理を中断した場合は、dh cleanは呼び出される一連のdebhelperコマンドは最初から実行されてしまいます。

なお、処理再開の場所は、このログファイルのみ参照して決める為、処理を中断した後に、パッケージのソースファイルを変更して再開させるような使い方はできません。例えば、ソースファイル中のあるファイルを変更した為、特定のパッケージのシーケンスについては再会時に全部やり直しが必要だったとしても、これを自動で検知することはできません。

\subsubsection{dpkg-buildflagとの関係}

dhは互換性度合い(COMPATABLITY LEVEL)のv9から、
パッケージ構築の時に使う環境変数を設定するため、内部でdpkg-buildflag相当の処理を
呼び出します。

その為、9をdebian/compatに指定すると、debhelperコマンドに設定される環境変数は、
\begin{enumerate}
\item /etc/dpkg/buildflags.confの中身
\item XDG\_CONFIG\_HOME/dpkg/buildflags.conf (XDG\_CONFIG\_HOMEは環境変数です)の中身
\item HOME/.config/dpkg/buildflags.conf (HOMEは環境変数です)の中身
\item DEB\_flag\_MAINT\_SET, DEB\_flag\_MAINT\_STRIP, DEB\_flag\_MAINT\_APPEND, DEB\_flag\_MAINT\_PREPEND, DEB\_BUILD\_MAINT\_OPTINS（全部環境変数です）の値
\end{enumerate}
により様々に変化します。どのように変わるかはman dpkg-buildflagを参照してください。

\subsection{今月のコマンドその2:dh\_testroot}

\subsubsection{dh\_testroot動作詳細}

 現在の実行ユーザがrootであるかどうかを確認するコマンドです。rootユーザでは無い場合、
エラーメッセージを出力して処理を中断します。

\subsubsection{dh\_testrootコマンドラインオプション}

　コマンドラインオプションは特にありません。何か指定しても無視されます。

\subsubsection{dh\_testrootを実行してみる}

早速、実行してみましょう。

\begin{commandline}
$ sudo dh_testroot
$ echo $?
0
$ dh_testroot
You must run this as root (or use fakeroot).
$ echo $?
255
$ fakeroot dh_testroot
$ echo $?
0
\end{commandline}
% $

このようにroot権限で実行するか、fakeroot経由で実行した時のみ0を返却します。

\subsubsection{次回の発表について}

次の発表者は勉強会で発表します。選ばれた人はよろしくおねがいします。

\clearpage

%------------------------------------------------------------------------------
\dancersection{月刊debhelper 第3回}{山田 泰資}
%------------------------------------------------------------------------------
\index{げっかんでぶへるぱー@月刊debhelper}
\index{debhelper}

\subsection{はじめに}
パッケージビルド手順を記述するdebian/rulesファイル。これを
簡潔化するためにdebhelperコマンド群(dh\_*)がありますが、
その一方で裏側で一体何がなされているのか掴み難くなって
しまいました。

本企画ではこのコマンド群を、毎月持ち回りで解説します。毎月2つ以上の
コマンドを解説し、次回発表の立候補が無い場合は発表者が次の発表者を
指名できるというルールで進めて行きます。

\subsection{今月のコマンド：dh\&dh\_auto\_* - シーケンスとビルドシステム}

dhコマンドの全体像については前回の野島さんの発表で既に解説されて
いるのですが、そこで「試しに読んでみるとよいと思います」とあったので、
実際に読みつついじってみました。その中でもう少し判ったことがあったので
報告します。

\subsubsection{dhの動作、再まとめ}
\index{dh}

dhコマンドを実行すると、デフォルトでは以下のコマンド群が
各シーケンス毎に呼ばれます：

\begin{table}[ht]
\begin{center}
\small
\begin{tabular}{|p{8em}|p{35em}|}
\hline
シーケンス名&シーケンスで実行されるコマンド \\
\hline
clean & dh\_testdir dh\_auto\_clean dh\_clean \\
build & dh\_testdir + (rules build-arch build-indep) \\
build-indep & dh\_testdir dh\_auto\_configure dh\_auto\_build dh\_auto\_test \\
build-arch & dh\_testdir dh\_auto\_configure dh\_auto\_build dh\_auto\_test \\
install &
\begin{minipage}[t]{\columnwidth}%
(rules build install-arch install-indep) + \newline
dh\_testroot dh\_prep dh\_installdirs dh\_auto\_install
dh\_install dh\_install*\newline
dh\_bugfiles dh\_ucf dh\_lintian dh\_gconf dh\_icons
dh\_perl dh\_usrlocal dh\_link\newline
dh\_compress dh\_fixperms
\end{minipage} \\
install-indep & (rules install-indep) + ＜上のinstallと同じ＞ \\
install-arch & (rules install-arch) + ＜上のinstallと同じ＞ \\
binary & (rules install binary-arch binary-indep) \\
binary-indep &
\begin{minipage}[t]{\columnwidth}%
(rules install-indep) +
dh\_installdeb dh\_gencontrol dh\_md5sums dh\_builddeb \\
\end{minipage} \\
binary-arch &
\begin{minipage}[t]{\columnwidth}%
(rules install-arch) + \newline
dh\_strip dh\_makeshlibs dh\_shlibdeps + ＜上のbinary-indepと同じ＞ \\
\end{minipage} \\
\hline
\end{tabular}
\caption{dhの各シーケンスで実行されるコマンド}
\label{tab:sequence-dh-commands}
\end{center}
\end{table}
かつてはrules(Makefile)に羅列されていたコマンド群が、
今はdhの中にPerlのリスト変数で管理されている形になります。
そしてdebhelperモジュール（*.pm）がロード時にリストの内容を
いじって実行内容を変更することでビルド過程をカスタマイズします。

わざわざmakeを使わず自前なのは、実行内容を変更するという
モジュール機構とoverride機構がmakeベースでは依存関係ツリーの
変更になり実現困難だったからでしょうか。たしかに拡張makeでも
使わない限り難しそうです（拡張makeまで行きたくないから現状の
実現方法・・・なんでしょうか）。

さて、今回の話題は、このモジュール機構になります。
普段何気なくどんなパッケージでもパッケージビルドされている訳ですが、
言語環境や開発者の選択によってビルド方法は千差万別です。これは
どうやって吸収されているのでしょうか？

\subsubsection{２つのモジュール：シーケンスとビルドシステム}
ここで登場するのが「シーケンス」とは別の、「ビルドシステム」
モジュールになります。この２つは
\begin{itemize}
\item シーケンスモジュールは（主に）前処理・後処理を追加し、適切なパッケージビルドが行われるようにする
\item ビルドシステムモジュールは各ソースパッケージに内包されるビルド方式を自動認識し、それを駆動する
\end{itemize}
と異なる役割を持ちます。典型的なconfigure\&makeパターンで説明すると、
\begin{enumerate}
\item Sequence/autotools\_dev.pm が config.sub/config.guess を最新に更新
\item Buildsystem/autoconf.pm が ./configure を発見・実行
\item Buildsystem/makefile.pm が Makefile を認識し、make でビルドやインストール
\end{enumerate}
といった連携リレーになります（autotools\_devは--withで有効化された場合のみ）。

\subsubsection{ビルドシステムの選択と連携}
さて、ビルドシステムは以下のフローで自動選択されています：
\begin{enumerate}
\item まず、Buildsystem/*.pmは全部ロードする
\item 各モジュールのcheck\_auto\_buildable APIにて「ビルドできる度」を照会
\item 同じクラス階層の中で一番大きい「ビルドできる度」を返したものを選択
\end{enumerate}
ポイントは
\begin{itemize}
\item この自動選択はconfigure/build/test/install/cleanの各段で毎回行われる
\item 同じクラス階層縛りがある
\end{itemize}
の２点です。つまり、
\begin{itemize}
\item 毎回行われるので、各段で応答・不応答を変えてモジュール間連携を行う
\item 自分が優先されるべき場合、親クラスの結果を上回るようにして勝つ
\end{itemize}
とする必要があり、「単純にビルドできるから真値を返す」という実装では
ないのでした。これは自前のビルドシステム拡張、特に他と連携する場合に
必要な留意事項になります。具体的にどういうコードなのかというとcmakeの
ものが参考になります：
\begin{commandline}
=== Buildsystem/cmake.pm ===
sub check_auto_buildable {
    my $this=shift;
    my ($step)=@_;
    if (-e $this->get_sourcepath(``CMakeLists.txt'')) {
        my $ret = ($step eq ``configure'' && 1) ||
                  $this->SUPER::check_auto_buildable(@_);
        # Existence of CMakeCache.txt indicates cmake has already
        # been used by a prior build step, so should be used
        # instead of the parent makefile class.
        $ret++ if ($ret && -e $this->get_buildpath(``CMakeCache.txt''));
        return $ret;
    }
    return 0;
}
\end{commandline}
%$
Makefileジェネレータとしてconfigureステージだけ担当のような
顔をしつつ、ビルドキャッシュがある場合は自分が後段も担当すべきとして
親であるmakefile.pmを押しのけて勝つ、というわけです。

\subsubsection{ビルドシステムは誰が呼んでいるのか}
ところでこのビルドシステム、誰が呼んでいるのでしょうか？例えばdhでは
\begin{commandline}
$ dh --buildsystem=perl_makemaker
\end{commandline}
%$
のように指定できるのですが、dhにはどこにもビルドシステムに関する
処理は書かれていません。

これはdhからオプションをそのままスルーパスされる形で
\footnote{Debianは、ビルドコマンド調査の時も思いましたが
コマンドライン引数の引き回し本当に多用しますね・・・}
dh\_auto\_(build\textbar{}clean\textbar{}configure\textbar{}install\textbar{}test)の
dh\_auto\_*系コマンド（だけ）が呼び出し元になっています。シーケンス中の
すべてのdh\_*コマンドに同様にスルーパスは届くのですが、反応するのが
この5つだけ、という訳です（man debhelperのBUILD SYSTEM OPTIONS）。
だからこそ独自処理を書く場合はrulesに
\begin{commandline}
override_dh_auto_build:
        ...
\end{commandline}
などとoverride\_dh\_auto\_*ターゲットを書くという話になるわけです。
dh\_auto\_*さえ止めれば、いかなるシーケンスが走ってもビルドシステム
呼び出しが行われず、実際のビルドは行われないからです。

これらのdh\_auto\_*コマンドは上のロード→照会(check\_auto\_buildable)
→API(configure\textbar{}build\textbar{}test\textbar{}install\textbar{}clean)
コールのトリガを引いているだけです。このフローの詳細はライブラリ化
されているので各コマンドは3行くらいしかありません。

\subsubsection{ビルドシステムの追加方法}
ビルドシステムの拡張は簡単で、以下のAPIを実装した*.pmをBuildsystem/
フォルダに置くだけです。基底クラスに空実装があるので全部書く必要はなく、
実際に処理を追加したいAPIのみ実装すれば十分です。
\begin{quote}
\begin{verbatim}
check_auto_buildable($step)                          # 必須
pre_building_step($step)                             # オプション
configure() build() test() install($destdir) clean() # いずれかを実装
post_building_step($step)                            # オプション
\end{verbatim}
\end{quote}
各APIの処理は名称から想像される通りで、先に解説済みのc\_a\_b API以外は
返値もありません（使われていません）。

サンプルとして、今は懐かしきimake/xmkmfを使ったソースパッケージの
自動検知＋ビルドに対応するようにimake.pmモジュールを用意してみました：
\begin{commandline}
package Debian::Debhelper::Buildsystem::imake;
use strict;
use base 'Debian::Debhelper::Buildsystem::makefile';

sub DESCRIPTION { "imake (IMakefile)" }
sub new { shift->SUPER::new(@_); }
sub check_auto_buildable {
    my($self, $step) = @_;
    return 1 if ($step eq "configure" &&
                 glob($self->get_sourcepath("I[Mm]akefile")));
    return 0;
}
sub configure { shift->doit_in_sourcedir("xmkmf", "-a", @_); }
1;
\end{commandline}
こんな簡単なものでも、ktermなどの対象パッケージをビルドするには十分です。

なお、これを組み込むにはDh\_Buildsystems.pmのソース中の自動判定リストの
末尾に
\begin{commandline}
our @BUILDSYSTEMS = (``autoconf'', ..., ``imake'');
\end{commandline}
のようにモジュール名を追加してやる必要があります。

\subsubsection{まとめ}
本解説ではdhフレームワークを支えるビルドシステム部分を解説しました。
これはdh\_*コマンドとしてはdh\_auto\_*の5コマンドに対応し、これらを
通してビルドシステムが駆動されています。

\subsection{今月のコマンド：dh\_builddeb}
\index{dh\_builddeb}

dh\_builddebは、dhによって起動される一連のコマンドシーケンスの最後を
飾るコマンドです（ちなみに最初はdh\_testdir）。

マニュアルは「dpkg-deb を呼ぶだけのかんたんなおしごと\footnote{
dh\_builddeb simply calls dpkg-deb(1) to build a Debian package or packages.
}」と一行だけの解説ですが、これが意外にも中で色々としていてdh\_*コマンドの
勉強になります。

\subsubsection{何をしているの？}

やっていること自体は以下の３つです：
\begin{enumerate}
\item debhelper(7)のファイル排除指定があれば、その除去処理をする
\item deb/udeb形式の判定を行い、dpkg-debの起動分けをする
\item さらに、DEB\_BUILD\_OPTIONSのparallel=指定があれば、dpkg-debを並列駆動する
\end{enumerate}
マニュアルの解説が１行の割には、意外に仕事をしています。

\subsubsection{疑問：udebって何？}
\index{udeb}
実はudebの存在を知りませんでしたが、udebというのはDebian Installer(d-i)で
使用される*.deb風のパッケージです。形式としてはudebもdebも同じで
普通にdpkgで操作できるのですが、極小リソースでの限定的な利用を
想定しているためドキュメントはおろかチェックサム機能などまで外されています。
\begin{commandline}
=== debian/control ===
Section: debian-installer
...
XC-Package-Type: udeb
XB-Installer-Menu-Item: 1200 <- d-i menuでの表示制御パラメータ
\end{commandline}
のように特殊なヘッダが入っているcontrolがある場合、dh\_builddebは
自動的にudebビルドモードでdpkg-debを起動します。

他にもこういう特殊ヘッダはあるのだろうかとか、これを入れると
具体的に何をどう変えられるのかなどudebとd-iの話は更に掘ると
面白そうですが、今回は脱線ということでここまでにしておきます
\footnote{
資料としては http://d-i.alioth.debian.org/doc/talks/debconf6/paper/ かな？
}。
udeb固有処理は他のdh\_*コマンドにも多数含まれており、is\_udeb()で
様々な処理分けを裏側でしています。

\subsubsection{debhelper(7)系コマンドの実装パターン}
dh\_builddebの中を覗くと、各所で\$dh{...}という変数へのアクセスが
頻出しています。これはdh\_*コマンドのdebhelper(7)オプションの
パースや共通的な処理が Debian::Debhelper::Dh\_Lib ライブラリで
行われており、このライブラリとコマンド側の連携に \%dh という
グローバル変数が使われているためです。また \%ENV も多用されています。

コードの流れとしては、debhelperの純正(Perl製)dh\_*コマンドは
概ね以下の実装パターンになっています：

\begin{commandline}
use Debian::Debhelper::Dh_Lib; # init()関数などがインポートされる
init(options => { ``myopt=s'' => \&dh{MYOPT}, ... }); # @ARGVや%ENVの定型処理

# 含まれているパッケージの数だけ処理を反復
foreach my $package (@{$dh{DOPACKAGES}}) {
    # 上のinit()で取り込まれた結果を見ながら処理をする
    if ( $dh{...}) { ... # Dh_Lib.pm の API を呼んだりするなど ... }
    # 自動的に取り込まれない環境変数（コマンド固有）は自分で処理する
    if ($ENV{...}) { ... # 上記同様 ... }
}
\end{commandline}

dh\_builddebの場合は、上のループの中が不要ファイルの削除と
dpkg-debの起動になり、これが例えばdh\_stripの場合は各生成中パッケージの
ワーキングフォルダをスキャンして、しかるべきファイルをstripして回ると
いうようになります。

\subsubsection{まとめ}
dh\_builddebコマンドの解説と、そこから出てきた疑問と共通的な構成の解説を
行ってみました。dh\_*コマンドは実質１行しかないものから1000行に迫るものまで
色々ありますが、dh\_builddebはちょうど理解する上で手頃な大きさです。

\clearpage

%-------------------------------------------------------------------------------
\dancersection{月刊 debhelper 第4回}{山本 浩之}
%-------------------------------------------------------------------------------
\index{げっかんでぶへるぱー@月刊debhelper}
\index{debhelper}

\subsection{パッケージのmakeの前に…}

先月までに学んできたように、debhelper は、基本的にビルドに必要な一連のdh\_XXX コマンドを自動実行します。

例えばdebhelperは、dh\_auto\_configureというコマンドを提供しており、これはご想像の通り、
\begin{commandline}
./configure --build='dpkg_architecture_value("DEB_BUILD_GNU_TYPE")' --prefix=/usr --includedir=/usr/include \
--mandir=/usr/share/man --infodir=/usr/share/info --sysconfdir=/etc --localstatedir=/var \
--libdir=/usr/lib/\$multiarch --libexecdir=/usr/lib/\$multiarch --disable-maintainer-mode \
--disable-dependency-tracking --host='dpkg_architecture_value("DEB_HOST_GNU_TYPE")
\end{commandline}
をしているだけです。

しかし、メンテナによってautotoolsを利用し、confugureスクリプトをビルドの度に毎回configure.acから生成したい人もいるでしょうし、もしかするとMakefileの元となるMakefile.inだって、毎回Makefile.amから生成したい人もいるでしょう。
また、Debianパッケージオリジナルのパッチをあててパッケージを作るのは、ごく当たり前のように行なわれています。

そこで今月は、一連のdh\_XXXXコマンドへの追加の仕組みと、その例として、dpatchパッケージで提供されるdh\_dpatch\_patchコマンドと、autotools-devパッケージで提供されるdh\_autotools-dev\_updateconfigコマンドの追加について解説しましょう。

\subsection{一連のdh\_XXXXコマンドへの追加の仕組み}

基本となる一連のdh\_XXXXコマンドは、大元のコマンドであるdhスクリプトに記述してあり、すべてについては先月や先々月に話されているので、割愛します。

特にmake直前に実行されるものは、
\begin{commandline}
dh_testdir  #カレントディレクトリの確認
dh_auto_configure  #./configureの実行
\end{commandline}
だけです。

勿論、これだけではパッチもあてられないですし、configureスクリプトの再生成もできません。

そこでdhスクリプトは、一連のdh\_XXXコマンドを列挙する配列にし、これを\$sequences{\$sequence}のスカラ変数として保持しています。(この辺はperlにあまり詳しくないので、ちょっと間違っているかも…)

また、この\$sequencesからdh\_XXXXコマンドを除いたり(remove\_command)、あるdh\_XXXXコマンドの前に追加する(insert\_before)サブルーチンも用意されています。

dhスクリプトは、/usr/share/perl5/Debian/Debhelper/Sequence/ディレクトリのなかにあるファイルを参照しており、ここに
\begin{commandline}
insert_before("dh_auto_configure", "dh_new_command")
\end{commandline}
という記述のあるファイル(アドオン)が追加されると、dh\_auto\_configureの前にdh\_new\_command が実行されるようになります。

ただし、rulesの
\begin{commandline}
dh $@ --with 〜 
\end{commandline}
%$
でアドオンが指定されない限り評価はされないので、ビルドに不必要なdh\_XXXXコマンドを入れていても大丈夫なはずです。

\subsection{dh\_dpatch\_patchコマンド}

dpatchパッケージをインストールすると、/usr/share/perl5/Debian/Debhelper/Sequence/ディレクトリにdpatch.pmファイルが入り、これには、
\begin{commandline}
insert_before("dh_auto_configure", "dh_dpatch_patch")
insert_before("dh_clean", "dh_dpatch_unpatch")
\end{commandline}

という記述があります。これは見て想像できるとおり、makeの直前に実行される./configureのさらに直前に、dh\_dpatch\_patchを加えています。
また、下の記述は、以前にビルドしたことがある場合に、パッチする前の状態にするdh\_dpatch\_unpatchコマンドも追加されています。

このdh\_dpatch\_patchは、パッケージソースのdebian/patches/00listに記述されたファイル名のパッチを先頭からパッチするコマンド、dpatchスクリプトを実行します。

すなわち、もしconfigureスクリプトにdpatchでなんらかのパッチをあてて実行したければ、dpatchパッケージをBuild-depし、debian/patches/ディレクトリにパッチファイルとそれに合わせた00listファイルを用意し、
\begin{commandline}
dh $@ --with dpatch
\end{commandline}
とrulesファイルに記述しておけば良いはずです。

makeだけしたいならば、ターミナルで、
\begin{commandline}
$ dh_dpatch_patch
$ ./configure 〜
$ make
\end{commandline}
%$
でも大丈夫です。

\subsection{autotoolsだって使いたい}

ビルドするマシンの環境に合わせて、configureスクリプトなどを調整してくれるツールとして、GNU autotoolsというものがあります。次にこのGNU autotoolsをdebhelperで利用する方法について述べましょう。

\index{dh-autoreconf}
dh-autoreconfパッケージをインストールすると、依存関係でautomake、autoconfと、automakeに依存してautotools-devがインストールされます。
autotools-devパッケージは/usr/share/perl5/Debian/Debhelper/Sequence/ディレクトリにautotools-dev.pmファイルが入ります。
これには、
\begin{commandline}
insert_before("dh_auto_configure", "dh_autotool-dev_updateconfig")
insert_before("dh_clean", "dh_autotool-dev_restoreconfig")
\end{commandline}
と記述されています。

dh\_autotool-dev\_updateconfigコマンドは、カレントディレクトリ以下で実行しているシステムタイプの標準名を推測するためのconfig.guessとconfig.subファイルを探し、config.guess.dh-origとconfig.sub.dh-origファイルに名前を換え、それぞれ/usr/share/misc/ディレクトリにある最新autotool-devのconfig.guessとconfig.subをコピーしてきます。

dh-autoreconfパッケージは/usr/share/perl5/Debian/Debhelper/Sequence/ディレクトリにautoreconf.pmファイルが入ります。
これには、
\begin{commandline}
insert_before("dh_auto_configure", "dh_autoreconf")
insert_before("dh_clean", "dh_autoreconf_clean")
\end{commandline}
と記述されています。

dh\_autoreconfコマンドは、簡単に言うと、automake、autoconfをしてくれるautoreconfスクリプトを呼び出し、configureやMakefile.inを再生成します。

dh\_autoreconfを使いたいときは、このパッケージにBuild-depし、
\begin{commandline}
dh $@ --with autoreconf
\end{commandline}
%$
とrulesファイルに記述しておけば良いはずです。
debian/autoreconfファイルにディレクトリのリストがあれば、そこだけconfigureやMakefile.inを更新してくれます。

autoreconf.pmファイルでは「dh\_auto\_configureより前だよ」という指定しかありませんから、dh\_autoreconfが実行されてパッチがあてられるのか、パッチがあてられてからdh\_autoreconfが実行されるのかまでは記述されていません。
dhスクリプトを見た限りでは「--with」オプションの順でリストされているようです。つまり、dh-autoreconfパッケージを利用するソースパッケージのMakefileに対してBTSでパッチを書く場合は、「--with」オプションの順を確認する必要がありそうです。

\subsection{おわりに}

今回はmakeを実行する前に使用されるconfigureスクリプトなどの、debhelperを使ったカスタマイズ法について、駆け足で説明してみました。

\clearpage

%-------------------------------------------------------------------------------
\dancersection{月刊debhelper 第5回}{杉本 典充}
%-------------------------------------------------------------------------------
\index{げっかんでぶへるぱー@月刊debhelper}
\index{debhelper}


\subsection{今月のコマンド：dh\_md5sums}
\index{dh\_md5sums}

dh\_md5sumsコマンドは「DEBIAN/md5sumsファイルを生成する」コマンドです。

\subsubsection{DEBIAN/md5sumsファイルについて}
「\$ ar x debian-package.deb」を実行し現れるcontrol.tar.xxファイルを展開
するとmd5sumsファイルが出てきます。このmd5sumsファイルはdata.tar.xxファイルに含むファイルそれぞれから取得したmd5sumを記述しています。

\begin{commandline}
$ apt-get download hello-debhelper
$ ar x hello-debhelper_2.7-3_i386.deb
$ ls
control.tar.gz  data.tar.gz  debian-binary  hello-debhelper_2.7-3_i386.deb
$ tar xf control.tar.gz
$ ls
control         data.tar.gz    hello-debhelper_2.7-3_i386.deb
control.tar.gz  debian-binary  md5sums
$ head -n 1 md5sums
098518cc321f0467dc0e7c67f65e2cc1  usr/bin/hello
\end{commandline}
%$

\subsubsection{パッケージのビルド処理におけるdh\_md5sumsの実行}
dh\_md5sumsコマンドはインストールするファイルのmd5sumを取得する処理のため、ビルド処理の終盤で実行されます。

\begin{commandline}
$ apt-get source hello-debhelper
$ cd hello-debhelper-2.7
$ debuild -uc -us
  (省略)
  dh\_gencontrol -a
  dh\_md5sums -a
  dh\_builddeb -a
  (省略)
$ ls debian/hello-debhelper
DEBIAN   usr
$ head -n 1 debian/hello-debhelper/DEBIAN/md5sums
098518cc321f0467dc0e7c67f65e2cc1  usr/bin/hello
\end{commandline}
%$

\subsubsection{コマンドのオプション}

\begin{table}[ht]
\caption{dh\_md5sumsのコマンドラインオプション一覧}
\begin{center}
\small
\begin{tabular}{|p{12em}|p{33em}|}

\hline
オプション&説明 \\
\hline
-x,  --include-conffiles & DEBIAN/conffilesファイルに記述した設定ファイルのmd5も生成します。\\
\hline
-Xitem, --exclude=item & md5sumの生成を除外するファイル名を指定します。ただしディレクトリが別でもファイル名が一致すればどちらも除外されます。 \\
\end{tabular}
\end{center}
\end{table}

\subsection{今月のコマンド：dh\_strip}
\index{dh\_strip}

dh\_stripコマンドは「実行ファイル、共有ライブラリ、スタティックライブラリをstripする」コマンドです。

\subsubsection{デバッグシンボルの扱い方を制御する}
オプションなしや環境変数を指定せずにdh\_stripコマンドを実行するとコンパイルしたオブジェクトファイルのデバッグシンボルをstripするのが通常の処理です。しかし、デバッグを目的とする場合はデバッグシンボルをstripしてしまうとデバッガが十分に機能しないため困ります。

dh\_stripコマンドではデバッグシンボルを以下のように扱うことができます。\cite{debugpackage}

\begin{itemize}
 \item オプションなしで実行すると、stripする。
 \item 環境変数DEB\_BUILD\_OPTIONS=nostripを指定して実行すると、stripしない。（処理的にはdh\_stripが即座に終了する）
 \item --dbg-packageオプションを指定すると、/usr/lib/debug配下にデバッグシンボルを分離して残すパッケージ（＝デバッグパッケージ）を作成する。
\end{itemize}

\subsubsection{デバッグパッケージを作成するための条件}
debhelperの機能を利用するとstrip済みのバイナリパッケージに加えて簡単にデバッグパッケージを作成できます。デバッグパッケージを追加で作成したい場合は以下の処理を記述してパッケージをビルドすればよいです。

\begin{itemize}
 \item CFLAGSなどのコンパイルオプションに''-g'を付与しビルド時にデバッグシンボルを生成するようにする。
 \item debian/rulesでoverride\_dh\_stripを定義し、dh\_strip --dbg-package=package-dbgを処理させる。
 \item debian/controlにパッケージ「package-dbg」の定義を記述する。このとき、パッケージ「package-dbg」はパッケージ「package」にバージョン指定をしてdependすること。
\end{itemize}

\subsubsection{コマンドのオプション}

\begin{table}[ht]
\caption{dh\_stripのコマンドラインオプション一覧}
\begin{center}
\small
\begin{tabular}{|p{12em}|p{33em}|}
\hline
オプション&説明 \\
\hline
-Xitem, --exclude=item & 指定した文字列を含むファイルをstrip処理の対象から除外する。複数のファイルを指定したい場合はオプションを複数回指定することも可能。\\
\hline
--dbg-package=package & デバッグシンボルを含むパッケージ「package-dbg」を作成する。 \\
\hline
-k, --keep-debug & パッケージをビルドした作業ディレクトリ内のusr/lib/debugにstrip後のデバッグシンボルファイルを残す。--dbg-packageオプションの指定で事足りる場合は多いが、より細かくデバッグシンボルを扱いたい場合を想定して用意されている。 \\
\end{tabular}
\end{center}
\end{table}

\begin{thebibliography}{0}
\bibitem{debugpackage} Debian Wiki - DebugPackage \url{http://wiki.debian.org/DebugPackage}\
\bibitem{bestpkgpractice} Debian.org 第6章パッケージ化のベストプラクティス \url{http://www.debian.org/doc/manuals/developers-reference/best-pkging-practices.html}
\end{thebibliography}

\clearpage

%-------------------------------------------------------------------------------
\dancersection{Debian開発者のKDE環境あれこれ}{野島 貴英}
%-------------------------------------------------------------------------------
\index{DebianかいはつしゃのKDEかんきょう@Debian開発者のKDE環境}
\index{kde}

最近のDebianをそのままインストールすると、特に指定しない場合GNOMEという
デスクトップ環境がインストールされます。しかしながら、Debianではいくつも
デスクトップ環境が用意されており、ユーザは自由にこれらを選んで使うことが
できます。デスクトップ環境はユーザにとってはいつも使う環境ですから、
いろいろとこだわりもあるかとおもいます。今回はそんな中、KDEというデスクトップ環境に
ついてあれこれ語ってみます。

\subsection{利用者としてのKDE導入方法}

Debianの安定版の利用を検討していて、KDE環境をいわゆる利用者として
使う為にインストールするやり方について簡単に述べます。

\begin{enumerate}
 \item 安定版のDebianのインストールDVDを用意します。
 \item インストーラのメニュー画面が出ましたら、TABキーをおすと画面下の方に編集可能な行
が現れますので、以下の例ように''desktop=kde''という文言を追加します。なお、日本語106キー
ボードを使っている場合、キートップの刻印の通りに"="を押しても"="文字が入力できない場合が
ありますが、この場合は"\verb|^|"の刻印のキーを押すと"="文字が入力できます。

\begin{commandline}
 /install.amd/vmlinuz vga=788 initrd=/install.amd/initrd.gz --- quiet desktop=kde
\end{commandline}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=7cm]{image201202/kdedesk/stable-inst-menu.png}
\caption{安定版インストール画面でTABキーを押したときの様子}
\end{center}
\end{figure}
\item あとは通常どおりインストールを行います。インストールを進めていくと
「インストールするソフトウェアの選択:」のメニューが現れますので、"Debian desktop environment"
を選択しておいてください。
\item インストールが完了しましたら、リブートを行います。
\item KDE環境が起動します。
\end{enumerate}

以上となります。簡単ですね。

\subsection{開発者としてのexperimental版KDE導入方法(KVM+spice)}
\label{sec:exp-kde}
\index{kvm}
\index{spice}

東京エリアDebian勉強会にいらっしゃるような方々には、前述のインストールと環境では
きっと「ぬるゲー（笑）」な感じのはずです。その場合、是非とも
experimental版のKDE環境を利用いただき、BTS書き/パッチ開発/翻訳/デバッグなどの
開発活動に勤しんでみましょう。ここでは、開発者向けKDE環境導入について簡単に述べます。

\begin{itemize}
\item 開発者向けにexperimental版導入を前提にします。
\item 仮想環境であるKVMを利用して仮想環境上に導入します。これなら、ディスクイメージファイルをとっておけば、
うっかりexperimental環境でaptitude full-upgradeして全く立ち上がらなくなっても（実話）あっさり復帰できます。
\item サウンドももちろん欲しいので仮想デスクトップ環境としてspiceを使います。
\item いつでもどこでも開発できるようにモバイル環境に構築します。
\end{itemize}
図\ref{fig:kde-env}のKDE開発環境の用意を想定します。

\begin{figure}[ht]
\begin{center}
\includegraphics[width=10cm]{image201202/kdedesk/kde-dev-env.png}
\caption{\label{fig:kde-env}KDE開発環境}
\end{center}
\end{figure}

以下は導入に関しての流れです。（細かい事は割愛します。操作にあたっては適宜root権限が必要だったりします）
\begin{enumerate}
\item HostOSとなるPCのBIOSを操作して、CPUの仮想技術支援機構のスイッチをONにしてブートしておきます。
\item HostOSに\url{http://www.debian.org/CD/netinst}から名刺サイズのCDイメージを落として置きます。
\item HostOSの/etc/network/interfacesに以下の追記を行い、br0を作っておきます。
\begin{commandline}
# 追記はここから。aptitude install bridge-utilsはやっておくこと。
auto br0
iface br0 inet static
        address 192.168.0.1
        netmask 255.255.255.0
        bridge_ports none
        bridge_stp off
        bridge_fd 0
        bridge_maxwait 0
\end{commandline}
\item HostOSの/etc/sysctl.d/bridge-filter-workaround.confを作り、sysctl -p /etc/sysctl.d/bridge-filter-workaround.confを実行して、br0のフィルタを無効化しておきます。
\begin{commandline}
# /etc/sysctl.d/bridge-filter-workaround.confの中身
net.bridge.bridge-nf-call-ip6tables = 0
net.bridge.bridge-nf-call-iptables = 0
net.bridge.bridge-nf-call-arptables = 0
\end{commandline}
\item HostOSの/etc/ppp/ip-up.d/kvm-bridge-up,/etc/ppp/ip-down.d/kvm-bridge-downを作っておきます。他にフィルタとか必要であれば適当にどうぞ。
\begin{commandline}
#!/bin/sh
# /etc/ppp/ip-up.d/kvm-bridge-upの中身
PATH=/bin:/usr/bin:/sbin:/usr/sbin
CDPATH=
sysctl -w net.ipv4.ip_forward=1
iptables -t nat -A POSTROUTING -o $PPP_IFACE -j MASQUERADE
iptables -A FORWARD -i br0 -o $PPP_IFACE -j ACCEPT
\end{commandline}
\begin{commandline}
#!/bin/sh
# /etc/ppp/ip-down.d/kvm-bridge-downの中身
#!/bin/sh
PATH=/bin:/usr/bin:/sbin:/usr/sbin
CDPATH=
sysctl -w net.ipv4.ip_forward=0
iptables -t nat -D POSTROUTING -o $PPP_IFACE -j MASQUERADE
iptables -D FORWARD -i br0 -o $PPP_IFACE -j ACCEPT
\end{commandline}
\item HostOSにkvm/libvirt/spice-client-gtkパッケージを導入しておきます。
\item HostOSにてGuestOS用のkde-test.xmlを以下の雛形で作成してvirsh define kde-test.xmlしておきます。\footnote{virt-installは何故か自分のexperimentalな環境ではSegmentation Faultで落ちてしまうのでここでは使いません。BTSしときます。}
\begin{commandline}
<domain type='kvm'>
  <name>kde-test</name>
  <memory>1048576</memory>
  <vcpu>1</vcpu>
  <os>
    <type arch='x86_64' machine='pc-1.0'>hvm</type>
    <boot dev='hd'/>
    <boot dev='cdrom'/>
    <bootmenu enable='yes'/>
  </os>
  <features>
    <acpi/>
    <apic/>
    <pae/>
  </features>
  <clock offset='utc'/>
  <on_poweroff>destroy</on_poweroff>
  <on_reboot>restart</on_reboot>
  <on_crash>restart</on_crash>
  <devices>
    <emulator>/usr/bin/kvm</emulator>
    <disk type='file' device='disk'>
      <driver name='qemu' type='raw' cache='writeback'/>
      <source file='/var/lib/libvirt/images/kde-test.img'/>
      <target dev='vda' bus='virtio'/>
    </disk>
    <disk type='file' device='cdrom'>
      <driver name='qemu' type='raw'/>
<!-- directory of cdimageは適当に変更ください -->
      <source file='/directory of cdimage/debian-6.0.4-amd64-businesscard.iso'/>
      <target dev='hdc' bus='ide'/>
      <readonly/>
    </disk>
    <controller type='ide' index='0'/>
    <interface type='bridge'>
<!-- macアドレスは適当に変更ください -->
      <mac address='52:54:00:31:cd:5a'/>
      <source bridge='br0'/>
      <model type='virtio'/>
    </interface>
    <serial type='pty'>
      <target port='0'/>
    </serial>
    <console type='pty'>
      <target type='serial' port='0'/>
    </console>
    <input type='mouse' bus='ps2'/>
    <graphics type='spice' port='5900' autoport='no'>
      <clipboard copypaste='yes'/>
    </graphics>
    <sound model='ac97'\>
    <video>
      <model type='qxl' vram='9216' heads='1'/>
    </video>
    <memballoon model='virtio'>
    </memballoon>
  </devices>
</domain>
\end{commandline}
\item HostOSで仮想環境用のディスクを10GBぐらいで作っておきます。
\begin{commandline}
qemu-img create -f raw /var/lib/libvirt/images/kde-test.img 10G
\end{commandline}
\item HostOSでKVMを起動して、spiceクライアントを接続します。
\begin{commandline}
virsh start kde-test; spicy -h 127.0.0.1 -p 5900 &
\end{commandline}
\item GuestOSのDebianインストーラが起動したら、TABキーを押し、画面下に現れた編集可能な行に、''priority=medium''を以下のように入力してインストールを開始します。
\begin{commandline}
 /install.amd/vmlinuz vga=788 initrd=/install.amd/initrd.gz --- quiet priority=medium
\end{commandline}
インストール途中「Debian アーカイブのミラーを選択」のメニューにて''sid''を選択し、「インストールするコンポーネント」として「sshサーバー」のみ(他は選択しない)とします。
\item インストールが完了すると、テキストコンソールからDebian sidなGuestOSへログインできるようになります。
\item GuestOSにログインして以下の行を/etc/apt/source.listへ付け加えます
\begin{commandline}
#追加内容
deb http://ftp.jp.debian.org/debian/ experimental main
deb-src http://ftp.jp.debian.org/debian/ experimental main
\end{commandline}
\item GuestOSの/etc/apt/preference.dにDebian KDEチーム製のexperimentalパッケージ用preferenceファイルをインストールします。
\begin{commandline}
cd /etc/apt/preference.d && wget http://pkg-kde.alioth.debian.org/files/kde-experimental
\end{commandline}
\item GuestOSで以下を実行し、experimentalなKDE環境を一気に入れてしまいます。
\begin{commandline}
aptitude update;aptitude aptitude install task-kde-desktop task-japanese-kde-desktop;aptitude clean
\end{commandline}
\item インストールが終わったら、GuestOSをリブートします。GuestOSでKDEのexperimental版が起動し、グラフィカルなログイン画面が現れます。
\end{enumerate}

\subsection{DebianとKDE環境のバージョン}

DebianのバージョンとKDEのバージョンの対応を表\ref{tab:kde-ver}に載せます。

\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|l|l|l|l||l|}
\hline 
Debian&stable&testing&unstable&experimental&upstream\\
\hline \hline
KDE &4.4&4.6&4.6&4.7.4&4.8.0\\
\hline
\end{tabular}
\caption{\label{tab:kde-ver}DebianのバージョンとKDEのバージョン}
\end{center}
\end{table}

KDEのupstreamは2012年1月25日に4.8.0をリリースしたばかりなので、まだ
experimentalも追いついていない状態です。

\subsection{KDE環境の開発の特徴}

KDE環境の開発は以下のような特徴があります。

\begin{enumerate}
\item Qt（キュート）ライブラリを使う。
\item C++のコードが基本
\item autotoolsの代わりにcmakeが使われる
\end{enumerate}

このため、Debianではパッケージ開発の為にpkg-kde-toolsパッケージが用意されています。

\subsection{DebianでのKDE環境のパッケージ開発}

DebianではKDE環境のパッケージ開発用にpkg-kde-toolsというパッケージを別に用意しています。こちらを導入するとKDE環境のパッケージ構築の際に便利な機能が使えるようになります。

\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline 
項番&拡張されるもの&拡張&備考\\
\hline
1&dh& --with kde & debhelperにkde用の拡張を指定\\
\hline
2&dh\_auto\_*& --buildsystem=kde & dh\_auto\_*がcmakeを使うようになる、KDE環境用の設定を行う等\\
\hline
3&CDBS&kde.mk& CDBSでKDE用の拡張が利用できるようになる\\
\hline
4&その他&variables.mkなど& debian/rulesの中で\$(DEB\_CMAKE\_KDE4\_FLAGS)などが使える等\\
\hline
\end{tabular}
\caption{\label{tab:pkg-kde-tools-inst}pkg-kde-toolsをインストールした時の拡張}
\end{center}
\end{table}

\subsection{超簡易的にKDE用プログラムのDebianパッケージを作ってみる}

ここでは超簡易的にKDE用プログラムのDebianパッケージを作ってみます。
まず、事前準備として、

\begin{itemize}
\item　環境は\ref{sec:exp-kde}章のexperimental環境を用意ください。
\item  必要なパッケージ(cmakeパッケージ等)
\footnote{KDE環境向けの開発が全く初めての人は、細かい事が判ってくるまで、aptitude build-dep kdeutilsしておいてKDEパッケージ開発に必要なパッケージをあらかじめまとめて導入しておくという手もあります}
\end{itemize}

次にkhello-1.0.0/なるディレクトリに\url{http://techbase.kde.org/Development/Tutorials/First_program}にある、main.cppとCMakeLists.txtを配置します。

\begin{commandline}
$ cd khello-1.0.0
$ ls 
CMakeLists.txt main.cpp
$
\end{commandline}
% $ 

次に、オリジナルのtar.gzアーカイブを作成しておきます。

\begin{commandline}
$ cd ..
$ tar czf khello_1.0.0.orig.tar.gz khello-1.0.0
$ ls -F 
khello-1.0.0/  khello_1.0.0.orig.tar.gz
$
\end{commandline}

dh\_make を使ってdebian/ディレクトリを仕込みます。あとはrulesファイル以外
いつも通り、パッケージを作成するようにファイルを作成しておきます。

\begin{commandline}
$ cd khello-1.0.0/debian
$ ls -F
README.Debian  changelog  control    docs   source/
README.source  compat     copyright  rules
$ 
\end{commandline}
% $

pkg-kde-toolsパッケージを利用するrulesファイルを記載します。

\begin{commandline}
# pkg-kde-toolsを使ったKDE開発用debian/rulesファイルの中身。

%:
       dh $@ --with kde
\end{commandline}
%$

あとは、dpkg-buildpackage -uc -us -rfakerootを実行してビルドします。

\begin{commandline}
$ dpkg-buildpackage -us -uc -rfakeroot
dpkg-buildpackage: source package khello
...中略...
dpkg-source: info: building khello in khello_1.0.0-1.debian.tar.gz
dpkg-source: info: building khello in khello_1.0.0-1.dsc
 debian/rules build
dh build  --with kde
   dh_testdir
   dh_auto_configure --buildsystem=kde
-- The C compiler identification is GNU
-- The CXX compiler identification is GNU
...中略...
\end{commandline}
%$

無事、--buildsystem=kdeが利用され、cmakeが実行されています。

しばらく待つと無事にkhello\_1.0.0-1\_amd64.debなどが出来上がります。

ほら、pkg-kde-toolsのおかげでパッケージ開発も簡単でしょ?でしょ？

\subsection{おわりに}

今回は、Debian開発者の為のKDE環境の構築と、簡単なパッケージ作成について、
一通り記載してみました。これを機に、KDE環境に関する開発をされる方が増えると
うれしいと思っています。

\subsection{参考文献}

\begin{itemize}
\item \url{http://pkg-kde.alioth.debian.org/} Debian KDE Teamのホームページ。
\item \url{http://techbase.kde.org} KDE Techbase
\item \url{http://kde.org/} KDE本家
\item \url{http://www.spice-space.org/} SPICE仮想デスクトップデバイス本家
\end{itemize}

\clearpage
%-------------------------------------------------------------------------------
\dancersection{CMakeを使ってみる}{野島 貴英}
%-------------------------------------------------------------------------------
\index{cmake}

\subsection{CMakeとは}

KDE環境の開発に使われているツールにCMakeがあります。これは従来のautotools
のようなものです。が、autotoolsに比べて次に述べる代表的な特徴があります。

\begin{itemize}
\item バイナリのプログラムである\\
autotoolsは、ご存知の通り、中はshスクリプトとなっています。これは
/bin/shを基本コマンドとして持つ従来のUNIX系のOSで使うなら非常に都合がよ
いのですが、そもそも/bin/shを持たないシステムの元で利用しようとすると
動作できません。これでは、例えば、標準的なCプログラムをコンパイル出来る環境
なのに、/bin/shが無いという本質ではない理由の為に移植性を損なうのはちょっと
残念です。

CMakeはバイナリのプログラムなので、コマンド単体で動作することができ、
/bin/shなどUNIXのコマンドが無い場所でも問題なく動作できます。

\item 様々なプラットフォーム用の構築システムに対応できる\\
　autotoolsはmakeに特化したツールとなります。ここで、そもそもMakefileが
一般的ではない開発環境（例：Microsoft Visual Studio等の様々なIDE)の場合、
MakefileよりもIDEのプロジェクトファイルを生成できた方がより都合がよかったりします。
CMakeは一本のCMakeLists.txtを用意するだけで、Makefileや、IDE環境用
のプロジェクトファイルを生成できたりする能力があります。この為、autotoolsを
利用したソースパッケージのように、Makefile.amと、例えば.vcprojファイルを別々に
修正してUNIX/Windows間の移植性を保つというような作業から開発者が開放
される可能性を意味します。

\item その他\\
 詳しいサマリは、DDJジャーナルの\url{http://drdobbs.com/cpp/184405251}に
サマリされているような機能がある模様です（まだ自分は未評価です。）

この記事からいくつか抜粋すると、

\begin{itemize}
\item QTライブラリのmocコマンド/ITKのCABLE/VTKのラッパー生成コマンドに対応したステートメント
\item 静的ライブラリ、動的ライブラリの生成を容易に切り替えれるようにする機能
\item ファイルの依存関係の自動生成、並列ビルドのサポート
\end{itemize}

がある模様です。
\end{itemize}

\subsection{使ってみる}

百聞は一見にしかずなので、ちょっと使ってみます。

cmakeパッケージをシステムに導入します。

\begin{commandline}
$ sudo aptitude install cmake
\end{commandline}
%$ 

次に以下のソース(hello.c,config.h.in)を用意します。

\begin{commandline}
/*hello.c*/
#include <stdio.h>
#include "config.h"
int main(int argc,char **argv)
{
	printf("hello world\n");
#if defined(HAVE_EXIT)
	printf("yes, this system has exit()\n");
#endif
	return(0);
}
\end{commandline}
\begin{commandline}
/*config.h.in*/
#cmakedefine HAVE_EXIT
\end{commandline}

次に、CMakeLists.txtを用意します。
\begin{commandline}
# cmakeのバージョンは2.8以上
cmake_minimum_required(VERSION 2.8)
# projectの名前を宣言
project(hello)

# CMake提供のマクロをロードする。ここでは関数がシステムにあるかを確かめるマクロ
# を使ってみる。
include (${CMAKE_ROOT}/Modules/CheckFunctionExists.cmake)

# exit()関数をチェックしてみる。あればHAVE_EXITを定義せよという意味。
check_function_exists(exit HAVE_EXIT)

configure_file (
  "${PROJECT_SOURCE_DIR}/config.h.in"
  "${PROJECT_BINARY_DIR}/config.h"
)
# cc -Iに何指定するか
include_directories ("${PROJECT_BINARY_DIR}")

# helloはhello.cから出来るという事を指定
add_executable(hello hello.c)
\end{commandline}

これら3つのファイルをhello-src/以下に配置します。
\begin{commandline}
$ ls -lR
.:
合計 4
drwxr-xr-x 2 nojima nojima 4096  2月 17 03:15 hello-src

./hello-src:
合計 8
-rw-r--r-- 1 nojima nojima 46  2月 17 03:15 CMakeLists.txt
-rw-r--r-- 1 nojima nojima  34  2月 17 04:21 config.h.in
-rw-r--r-- 1 nojima nojima 91  2月 17 03:10 hello.c
$
\end{commandline}

今回はビルド用ディレクトリ(hello-build)を作り、移動します。

\begin{commandline}
$ ls 
hello-src
$ mkdir hello-build
$ cd hello-build
\end{commandline}
% $

cmakeを実行します。

\begin{commandline}
$ cmake ../hello-src
-- The C compiler identification is GNU
-- The CXX compiler identification is GNU
-- Check for working C compiler: /usr/bin/gcc
-- Check for working C compiler: /usr/bin/gcc -- works
...中略...
-- Looking for exit
-- Looking for exit - found
-- Configuring done
-- Generating done
-- Build files have been written to: /.../cmake-test/hello-build
$ ls
CMakeCache.txt  CMakeFiles  Makefile  cmake_install.cmake  config.h
\end{commandline}

自動的に環境チェックが行われMakefile/config.hが出来上がります。
exit関数も見つかったとの表示が行われました。ここでmakeしてみます。

\begin{commandline}
$ make
Scanning dependencies of target hello
[100%] Building C object CMakeFiles/hello.dir/hello.c.o
Linking C executable hello
[100%] Built target hello
$ ls -F
CMakeCache.txt  CMakeFiles/  Makefile  cmake_install.cmake  config.h  hello*
$ ./hello
hello world
yes, this system has exit()
$
\end{commandline}

CMakeLists.txtから無事に実行バイナリ(hello)が出来上がりました。また、defined(HAVE\_EXIT)もTrueとなり、exit()関数がある時のコードもコンパイルされています。

\subsection{IDE用のプロジェクトファイルを生成してみる}

cmakeを引数無しで実行すると、helpが出てきます。このヘルプの文章の中に、どんなIDE用のプロジェクトファイルを生成できるかについて説明があります。試しに手元のDebianマシンで実行すると、

\begin{commandline}
$ cmake
...中略..
The following generators are available on this platform:
  Unix Makefiles              = Generates standard UNIX makefiles.
  CodeBlocks - Unix Makefiles = Generates CodeBlocks project files.
  Eclipse CDT4 - Unix Makefiles
                              = Generates Eclipse CDT 4.0 project files.
  KDevelop3                   = Generates KDevelop 3 project files.
  KDevelop3 - Unix Makefiles  = Generates KDevelop 3 project files.
$
\end{commandline}

ここでは試しに先ほどのhello-buildディレクトリ以下でKDevelp3 project ファイルを生成してみます。

\begin{commandline}
$ cmake -G KDevelop3 ../hello-src
...中略...
$ ls 
MakeCache.txt  Makefile             config.h        hello.kdevelop.filelist
CMakeFiles     cmake_install.cmake  hello.kdevelop  hello.kdevses
$
\end{commandline}
%$
確かにKDevelp3用のプロジェクトファイル(hello.kdevelop等)が生成されています。

\subsection{おわりに}

cmakeはKDEの他にもmysqlでも採用されています。また、wikipedia(\url{http://ja.wikipedia.org/wiki/CMake})によれば、利用しているアプリケーションも続々増えている模様です。

使いこなせると強力なツールとなりそうな感じです。皆さんも使ってみてはいかがでしょうか？Debianならaptitudeで簡単に導入できますので、是非試してみてください。

\subsection{参考文献}

\begin{itemize}
\item \url{http://www.cmake.org/} CMake本家
\item \url{http://www.cmake.org/cmake/help/cmake_tutorial.html} CMakeチュートリアル
\item \url{http://drdobbs.com/cpp/184405251?pgno=1} DDJジャーナルの記事
\end{itemize}


%-------------------------------------------------------------------------------                                                                                                                             
\dancersection{Debian 勉強会 - ユーザサイド -  Apache2 / HTTP サーバから始める Debian}{岩松 信洋}
%-------------------------------------------------------------------------------                                                                                                                             
\index{Debianべんきょうかいゆーざさいど}
\index{apache}

普段はちょっと開発者寄りな話をしているDebian
勉強会ですが、今回は OSC 出張企画として、ユーザー視点の勉強会を開催します。
今回はよく使われていると思われる Apache2 / HTTP サーバ に焦点を当ててみます。

\subsection{はじめに}

Debian は 日本では HTTP サーバとして利用されているように見えませんが、
世界では一番採用されている Linux ディストリビューションになったようです。
\footnote{\url{http://w3techs.com/blog/entry/debian_is_now_the_most_popular_linux_distribution_on_web_servers}}
この記事によると、利用されている理由は HTTP サーバパッケージの種類が多くある事が理由の一つに挙げられています。
Debian を HTTP サーバとして利用している理由を実際に使っている方に聞いてみたところ、理由はこれだけではないことが分かりました。
Debianのパッケージングシステム、APT、Apahce モジュールパッケージの多さ、
Webアプリケーションで採用される P言語（Perl, Python, PHP）のサポートなどがあり、
一番良い点として挙げられたのは設定ファイルの柔軟性についてでした。

Debian の Apache2 / HTTP サーバ は Red Hat 系 と違い、Debian 特有の構成になっています。これは他のディストリビューションしか
知らない人にとっては難しいかもしれません。
しかしDebian特有の構成を理解すると、他のディストリビューションとのメリット、
デメリットが見えてくると思います。
というわけで今回は、Debian の Apache2 / HTTP サーバ (以下、Apache2 ） について勉強していこうと思います。

\subsection{Debian の Apache2 バージョン}

まず、Debian で提供されている Apache2 のバージョンを見てみます。
表\ref{tab:apache-version}にまとめました。
Upstream と比べると少し古いですが、機能的には問題ないでしょう。
RHEL、CentOS（\texttt{バージョン 2.2.15-15}）
と比べても特にバージョンが古いというわけでもありません。

\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline 
ディストリビューション & stable & testing &unstable & experimental & upstream\\
\hline \hline
バージョン & 2.2.16-6+squeeze6 & 2.2.22-1 & 2.2.22-1 & - & 2.4.1 \\
\hline
\end{tabular}
\caption{\label{tab:apache-version}Debian ディストリビューションと Apache2 のバージョン}
\end{center}
\end{table}

\subsection{Debianのパッケージ構成とパッケージのインストール}

次に Apache2 のパッケージ構成とインストール方法について説明します。

\subsubsection{パッケージ構成}

Debian の Apache2 で提供されているパッケージは以下の通りです。
HTTP サーバの処理モデルごとにパッケージ
（apache2-mpm-worker、apache2-mpm-prefork、apache2-mpm-event、apache2-mpm-itk）
が分離されていることがわかります。
これにより自分の用途に合わせたパッケージをインストールできます。
Red Hat系は一つのパッケージに纏まっていて、処理モデル毎にサフィックスをつけています（例：httpd.worker）。
\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|l|}
\hline 
パッケージ名 & パッケージの説明\\
\hline \hline 
apache2 & Apache HTTP サーバメタパッケージ \\
\hline
apache2-mpm-worker & スレッドモデル Apche HTTP サーバ\\
\hline 
apache2-mpm-prefork & 非スレッドモデル Apache HTTP サーバ\\ 
\hline
apache2-mpm-event & イベントドリブンモデル Apache HTTP サーバ\\ 
\hline 
apache2-mpm-itk & マルチユーザ環境  Apache HTTP サーバ\\
\hline
apache2.2-common & Apache HTTP サーバ 共通ファイル \\
\hline
apache2.2-bin & Apache HTTP サーバの共通バイナリファイル\\ 
\hline
apache2-utils & ウェブサーバ用ユーティリティプログラム \\
\hline
apache2-suexec & Apache2 mod-suexec 用 基本 suexec プログラム \\
\hline
apache2-suexec-custom & Apache2 mod-suexec 用 設定可能 suexec プログラム \\
\hline
apache2-dbg & Apache HTTP サーバ デバッグシンボルファイル \\
\hline
apache2-prefork-dev & 非スレッドモデル Apache HTTP サーバ 開発用ヘッダファイル\\
\hline
apache2-threaded-dev & マルチスレッドモデル　Apache HTTP サーバ 開発用ヘッダファイル \\
\hline
apache2-doc & Apache HTTP サーバドキュメント \\
\hline
\end{tabular}
\caption{\label{tab:apache-pkg}Debian で 提供される Apache2 パッケージ}
\end{center}
\end{table}

次にパッケージの依存関係図を図\ref{fig:apache-pkg-dep}に示します。依存関係が複雑なので
ユーザは不安になるかもしれません。しかしDebianでは
強力なパッケージ管理ツール APT によって気にする事なくインストールできます。

\begin{figure}[ht]
 \begin{center}
  \includegraphics[width=1.0\hsize]{image201203/apache2-pkg.png}
 \end{center}
\label{fig:apache-pkg-dep}\caption{Debian でのパッケージ依存関係}
\end{figure}

\subsubsection{インストール}

Debianで Apache2 をインストールする場合は \texttt{apt-get install}コマンドを
使います（図\ref{fig:install}）。

Debianでは apache2 というメタパッケージを使ってインストールすることが多いです。
apache2 をインストールすると、apache2-mpm-worker がインストールされます。
他の HTTP サーバパッケージをインストールしたい場合は、各々のパッケージを
指定してインストールする必要があります。

またCentOSなどでは、「httpd」 パッケージとして提供されているのでパッケージ名が異なります。
普段は他のディストリビューションを使っている人は注意しましょう。


\begin{figure}[ht]
 \begin{center}

\begin{terminal}
$ sudo apt-get update \commandannotate{リポジトリを更新}
$ sudo apt-get install apache2 \commandannotate{apache2 パッケージをインストール}
\end{terminal}

 \end{center}
\label{fig:install}\caption{Debian で Apache2 をインストールする}
\end{figure}


\subsubsection{Apache HTTP サーバの起動と停止}

Debian は「インストールしたものは使う」というポリシーなので、インストール完了の時点で
既に Apache HTTP サーバは起動しています。停止したい場合には root 権限で 
「\texttt{/etc/init.d/apache2 stop}」 を実行します。
起動したい場合は 「\texttt{/etc/init.d/apache2 start}」、再起動したい場合には
「\texttt{/etc/init.d/apache2 restart}」を実行します。
図\ref{fig:startstop}に例を示します。

\begin{figure}[ht]

\begin{terminal}
$ ps ax | grep apache2 \commandannotate{apache2 のプロセスを確認}
10034 ?        Ss     0:05 /usr/sbin/apache2 -k start
13008 ?        S      0:00 /usr/sbin/apache2 -k start
....
$ sudo /etc/init.d/apache2 stop \commandannotate{apache2 を停止}
$ ps ax | grep apache2 \commandannotate{apache2 のプロセスを確認}
16833 pts/1    S+     0:00 grep apache2 
$ sudo /etc/init.d/apache2 start \commandannotate{apache2 を開始}
10048 ?        Ss     0:05 /usr/sbin/apache2 -k start
13024 ?        S      0:00 /usr/sbin/apache2 -k start
....
\end{terminal}

\label{fig:startstop}\caption{Apache2の起動と停止}
\end{figure}



デフォルトの状態では、マシンを立ち上げ時に HTTP サーバが起動するようになっています。
マシン立ち上げ時に HTTP サーバの起動しないようにするには、ランレベル毎のサービス起動スクリプト
を制御するツール \texttt{update-rc.d}を使います。

全てのランレベルで apache2 を起動させないようにするには、コマンドに
サービス名と remove を指定して実行します。 

またインストール直後のデフォルトの状態に戻したい場合には、コマンドに
サービス名と default を指定して実行します。

実行例を図\ref{fig:update-rc}に示します。


\begin{figure}[ht]
\begin{terminal}
$ sudo update-rc.d -f apache2 remove \commandannotate{全てのランレベルで apache2 を起動させないようにする。} 
$ sudo update-rc.d -f apache2 default \commandannotate{サーバ起動をデフォルトの状態に戻す}
\end{terminal}
%$
\label{fig:update-rc}\caption{ランレベルの制御}
\end{figure}


Red Hat系では \texttt{chkconfig}を使いますが、Debianでも提供されています。
しかし、chkconfig は RedHat系のサービス管理ツールなので Debian 
ではうまく動作しないことがあるようです。同様のツールとして
\texttt{sysv-rc-conf}があるのでこちらを使ったほうがいいでしょう。
図\ref{fig:sysv-rc}に簡単な使い方を説明します。

\begin{figure}[ht]

\begin{terminal}
$ sudo apt-get install sysv-rc-conf \commandannotate{sysv-rc-conf パッケージをインストール} 
$ sudo sysv-rc-conf --list  \commandannotate{現在の状態を出力}
apache2      0:off1:off2:on3:on4:on5:on6:off
bootlogd     S:on
（中略）
$ sudo sysv-rc-conf --level 2 apache2 off \commandannotate{ランレベル2のapache2を無効にする}
$ sudo sysv-rc-conf --list | head -1 \commandannotate{現在の状態を出力}
apache2      0:off1:off2:off3:off4:off5:off6:off
$ sudo sysv-rc-conf --level 2 apache2 on\commandannotate{ランレベル2のapache2を有効にする} 
$ sudo sysv-rc-conf --list | head -1  \commandannotate{現在の状態を出力}
apache2      0:off1:off2:on3:off4:off5:off6:off
\end{terminal}
%$
\label{fig:sysv-rc}\caption{Apache2の起動と停止}
\end{figure}


\subsection{Apache2 の設定ファイル}

Red Hat 系の場合、主な設定は \texttt{/etc/httpd/conf/httpd.conf}で行い、include されるファイルは
\texttt{/etc/httpd/conf.d/}ディレクトリに格納しますが、Debian の場合は表\ref{tab:apache-files}のように
なっています。

\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|l|}
\hline 
設定ファイル & 内容\\
\hline \hline
/etc/apache2/apache2.conf & 基本設定\\
\hline
/etc/apache2/httpd.conf & オーバーライドする設定\\
\hline
/etc/apache2/conf.d/ & 基本設定の中でIncludeするファイルを格納する\\
\hline
/etc/apache2/ports.conf & ポートの設定\\
\hline
/etc/apache2/envvars & 環境変数の設定\\
\hline
/etc/apache2/mods-available/ & 利用可能なモジュール設定\\
\hline
/etc/apache2/mods-enabled/ & 利用中のモジュール設定\\
\hline
/etc/apache2/sites-available/ & 利用可能なサイト設定\\
\hline
/etc/apache2/sites-enabled/ & 利用中のサイト設定\\
\hline
/var/www & ドキュメントルート\\
\hline
/usr/lib/cgi-bin & cgi-bin\\
\hline
/var/log/apache2 & Apache2 ログ\\
\hline
\end{tabular}
\caption{\label{tab:apache-files}{Debian の Apache2 設定ファイル群}}
\end{center}
\end{table}

\texttt{apache2.conf}には図\ref{fig:apache2conf}のような行があり、\texttt{apache2.conf}
から各設定が読み込まれるようになっています。
Apache2 の設定を
を変更する場合、\texttt{apache2.conf}を変更せず、
\texttt{httpd.conf} や \texttt{ports.conf}を変更します。

\begin{figure}[ht]
\begin{terminal}
（省略）
# Include module configuration:
Include /etc/apache2/mods-enabled/*.load
Include /etc/apache2/mods-enabled/*.conf

# Include all the user configurations:
Include /etc/apache2/httpd.conf

# Include ports listing
Include /etc/apache2/ports.conf
（中略）
# Include generic snippets of statements
Include /etc/apache2/conf.d/

# Include the virtual host configurations:
Include /etc/apache2/sites-enabled/
\end{terminal}

\label{fig:apache2conf}\caption{apache2.confの内容}
\end{figure}


\subsection{サイトを設定する}

Debian は\texttt{/etc/apache2/sites-available/default} に apache2 のデフォルトのサイト設定
を格納しています。サイトを一つだけ構築する場合はこのファイルを変更し、
apache2 を再起動すれば
設定された内容で apache2 が立ち上がります。再起動する方法は図\ref{fig:apache2restart}の通りです。

\begin{figure}[ht]
\begin{terminal}
$ sudo /etc/init.d/apache2 restart
\end{terminal}
%$
\label{fig:apache2restart}\caption{Apache2の再起動}
\end{figure}

Debian の apache2 で複数のサイトを立ち上げる場合、httpd.conf や apache2.conf は編集しません。
サイト別に設定を記述し、\texttt{/etc/apache2/sites-available/}ディレクトリに格納します。
そして、そのサイトを設定を有効にするコマンド「\texttt{a2ensite}」実行し、apache2 を再起動します。

簡単な手順を説明します。
例えば、test.example.org というサイトを立ち上げるとします。内容は図\ref{fig:siteexample}のようになるでしょう。

\begin{figure}[ht]
\begin{terminal}
<VirtualHost *>
    ServerAdmin admin-test@example.org
    ServerName test.example.org
    DocumentRoot /home/test/public_html/
    <Directory />
        Options FollowSymLinks ExecCGI Includes
        AllowOverride None
    </Directory>
</VirtualHost>
\end{terminal}
\label{fig:siteexample}\caption{サイトの設定例}
\end{figure}


そしてこのサイト設定を\texttt{/etc/apache2/sites-available/test}に格納します。
格納した後、サイトを有効にする「\texttt{a2ensite}コマンド」に有効にしたいサイトの
設定ファイル名を指定して実行します。実行すると\texttt{/etc/apache2/sites-enabled/}
にシンボリックリンクが張られ設定が有効になります。
有効にしただけでは、稼働しているhttpd サーバには設定が反映されていないため、
httpd サーバを再起動します。

図\ref{fig:siteenable-setting}に例を示します。

\begin{figure}[ht]
\begin{terminal}
$ ls -l /etc/apache2/sites-enabled/
合計 0
lrwxrwxrwx 1 root root 26 2011-03-20 08:23 000-default -> ../sites-available/default
lrwxrwxrwx 1 root root 30 2011-03-20 08:23 default-ssl.old -> ../sites-available/default-ssl
$ sudo a2ensite test \commandannotate{test を有効にする}
Enabling site test.
Run '/etc/init.d/apache2 reload' to activate new configuration!
$ ls -l /etc/apache2/sites-enabled/
合計 0
lrwxrwxrwx 1 root root 26 2011-03-20 08:23 000-default -> ../sites-available/default
lrwxrwxrwx 1 root root 29 2012-03-10 06:24 test -> ../sites-available/test
lrwxrwxrwx 1 root root 30 2011-03-20 08:23 default-ssl.old -> ../sites-available/default-ssl
$ sudo /etc/init.d/apache2 restart \commandannotate{Apache2 を再起動}
\end{terminal}
\label{fig:siteenable-setting}\caption{サイトを有効にする}
\end{figure}

サイトの設定を無効にする場合には、サイトを有効にする「\texttt{a2dissite}コマンド」
に無効にしたいサイトの設定ファイル名を指定して実行します。実行すると\texttt{/etc/apache2/sites-enabled/}
からシンボリックリンクが削除されます。サイト設定を無効にした後は、有効時と同様にhttpd サーバを
再起動する必要があります
図\ref{fig:sitedisable-setting}に例を示します。

\begin{figure}[ht]
\begin{terminal}
$ sudo a2dissite test \commandannotate{test を無効にする}
Site test disabled.
Run '/etc/init.d/apache2 reload' to activate new configuration!
$ ls -l /etc/apache2/sites-enabled/
合計 0
lrwxrwxrwx 1 root root 26 2011-03-20 08:23 000-default -> ../sites-available/default
lrwxrwxrwx 1 root root 30 2011-03-20 08:23 default-ssl.old -> ../sites-available/default-ssl
\end{terminal}
%$

\label{fig:sitedisable-setting}\caption{サイトを無効にする}
\end{figure}

このように Debian　ではサイトの設定を分離し、サイト毎に状態を管理することができます。
他のディストリビューションでは \texttt{include} 等を使って管理することができますが、
ファイル内容を変更する必要があり非常に手間です。
Debian はシンボリックリンクを使うことによってApache2 の設定ファイルを
変更せずにサイト設定の有効・無効ができるようになっています。

\subsection{モジュールを有効/無効にする}
Debian のモジュールに関する設定はモジュール毎の設定ファイルとして
\texttt{mods-available}ディレクトリに格納されています。
それらのうち、実際に有効にするものが
シンボリックリンクとして \texttt{mods-enabled} ディレクトリに張られます。
シンボリックリンクは手動で行わず、モジュールを有効にする場合には\texttt{a2enmod}コマンド、
無効にする場合には\texttt{a2enmod}コマンドを使います。

図\ref{fig:a2enmod}にmod\_info を有効にする例を、
図\ref{fig:a2dismod}にmod\_info を有効にする例を示します。

\begin{figure}[ht]
\begin{terminal}
$ 
sudo a2enmod info
\end{terminal}
%$
\label{fig:a2enmod}\caption{mod\_infoを有効にする}
\end{figure}

\begin{figure}[ht]
\begin{terminal}
$ sudo a2dismod info
\end{terminal}
%$
\label{fig:a2dismod}\caption{mod\_infoを無効にする}
\end{figure}

\subsection{その他}

その他、注意すべき点をいくつか教えてもらったので紹介します。

\subsubsection{libapache2-mod-php5 と apache2-mpm-prefork}

Apache2 上で mod-php5 を使いたい場合、apache2-mpm-worker は使えない点に
注意してください。これは PHP5（mod-php5）の制限で、スレッドで動作することができないためです。
libapache2-mod-php5 をインストールすると、
を使いたい場合、apache2-mpm-worker が削除され、apache2-mpm-prefork がインストールされます。
PHP ユーザの方は注意しましょう。

\subsubsection{再起動確認について}
その他、Debian で Apache2 を使う理由として、再起動確認を行うという点があります。
例えばglibc が更新されたとき、サーバ系は再起動する必要があるのですが、Red Hat系では
再起動してくれず、管理者が手動で行う必要があります。
CentOS を使っている会社ではデーモンを再起動しないとならないアップデートがあったかどうか
チェックするツールをわざわざ作って管理していたりするようです。
しかし Debian では再起動の確認が行われる（設定によって自動再起動も可能）ので、
管理者の手を煩わせません。このような細かいところに気を使ってくれるのも Debianの良い所です。

\subsection{まとめ}
Debian のパッケージ古いというのは昔の話です。
stableとtesting へのセキュリティバグへの対応があり、その対応も他のディストリビューションと
比べて比較的早いです。
よく指摘されるDebian の設定ファイル、ディレクトリ構造ですが、
今回の説明で独自なのは理由があり、理にかなっている事が分かります。
またこれらを容易に操作できるように、専用のツールもあります。
パッケージによる、細かいところへの気配りができるところがDebianのよいところだと思います。
今回のApache の話が気になった方はとりあえずDebian 使ってみてはいかがでしょうか。
%-------------------------------------------------------------------------------
\dancersection{Debian での node 入門}{上川純一}
%-------------------------------------------------------------------------------
\index{node.js}
\index{node}
\index{javascript}

JavaScript\cite{javascript-mdn,ecmascript}で
プログラムをガリガリ書きたいとおもったことはありませんか?
昨年（2011年）一時期話題になっていたnodeをDebianで試してみましょう。
node\footnote{マニュアルなどにはnodeと記述されていますが、通称は
node.jsのようです}は
イベントベースのサーバサイドJavaScriptエンジンとフレームワークです。
何に使えるかというと、JavaScriptでウェブサーバが書きやすくなっています。
シェルスクリプトでコードを書く代わりにnodeを使ってJavaScriptを使うことも
まぁ出来ますがウェブサーバが便利になるのが一番大きいと思われます。
特徴はシングルスレッドなんだけどほとんどすべてのI/O処理を非同期イベント
処理によって実現することによって、たくさんのリクエストを効率よく処理する
あたりでしょうか。

node のパッケージはsqueezeにはないですが、wheezy にはすでに入っていま
す。
インストールは簡単:
\begin{commandline}
# apt-get install nodejs
\end{commandline}

Node 本体は nodejs というパッケージ名で入っています\footnote{すでにnodeと
いうパッケージが存在するからnodeという名前がつけられなかったのだと思われ
ます。}が、関連するモジュールパッケージの名前はnode-ではじまるようになっ
ています。

node コマンドを実行するとJavaScriptインタープリタのREPLインタフェースが起
動します。ここでコマンドラインからJavaScriptを適当に実行できるようです。
この時点では単なるV8のコマンドラインインタフェースですね。

\begin{commandline}
$ node -v 
v0.6.12
$ node
> console.log('hello world')
hello world
\end{commandline}

nodeのバージョン番号ですが、node の2012年4月1日時点の安定版の最新版は0.6
系列で、0.7系列は開発版という位置づけのようです。0.8系列がリリースされた
らまたDebianのnodeも更新されるでしょう。

まとめると次のようになっています。
\begin{itemize}
 \item 0.4: 2012年1月までDebian sid に入っていた安定版
 \item 0.6.12: 2012年4月時点での最新安定版(stable)
 \item 0.7.x: 開発版(unstable)
 \item 0.8.x: 多分近い将来リリースされるだろう安定版
\end{itemize}

\subsection{Debian 流儀でのNodeモジュールパッケージインストール}

Debianパッケージで提供されている node のモジュールパッケージを使ってみましょう。

\subsubsection{NodeでCLIツールを作ってみる}

とりあえず、node でコマンドラインインタフェース（CLI)のツールをつくってみたい、のでnode cli を
インストールして適当にコードを書いてみるという場面を想定してみます。cli
モジュールはDebianパッケージになっているので以下でインストールできます。
\index{node-cli}

\begin{commandline}
# apt-get install node-cli
\end{commandline}

とりあえず無駄に平均を計算してみるコードを書いてみました。

\begin{commandline}
// Command-line tool to sum the stdin items.
var cli = require('cli');

cli.withStdinLines(function(lines, newline) {
    var sum = 0;
    var count = 0;

    for (var i = 0; i < lines.length; ++i) {
	console.log(lines[i]);
	if (lines[i] != '') {
	    sum += parseInt(lines[i]);
	    count ++;
	}
    }
    console.log('sum: ' + sum + ' avg: ' + sum / count);
});
\end{commandline}

コマンドラインで適当に実行してみたところ、結果が表示されました。

\begin{commandline}
$ node sum.js < testdata.txt
10
15
200
8

sum: 233 avg: 58.25
\end{commandline}
%$
\subsection{npm -- Node のパッケージ管理システム}
\index{npm}

Node のモジュールは npm で管理されています。Debian パッケージになって
いないパッケージなどは、npm コマンドを利用して直接インストールすることも可能です。
Perl でいうCPAN、TeXでいうCTAN のようなもののようです。
Debian パッケージを使うべきかnpmを使って導入するべきか悩ましいところです
が、Debianパッケージになるまでにはどうしてもタイムラグがあるので、最新のコードをつ
かって開発する場合にはnpmを利用することになると思われます。ある程度こな
れてきたらないパッケージはITPするのがよいでしょう。

Debianの提供するモジュールパッケージは/usr/lib/nodejs 以下にインストール
されますが、
Debian パッケージの npmを利用する場合は /usr/local/lib/nodejs 以下に入り
ます。

で、喜び勇んで手元で実行したところExceptionをはいて終了しました。どうやら
node 0.6.2に対応していない古いバージョンの npm (Node 0.4系列ではうごいた
はず)が現在パッケージされており、動かなくなっている模様です。
\debianbug{622628}

\subsection{npmのアップストリーム版をインストールしてみる}

npmが使えないのは不便なので、Debianパッケージになっていないnodeモジュール
をインストールする方法としてDebianパッケージではないnpmを利用する方法を紹
介します。

node 0.6 系列に対応しているnpmは1.1です。
npmjs\cite{npmjs} サイトからインストーラをダウンロードして実行します。
npm がインストールできたらモジュールは npm installコマンドでインストールできるよ
うになります。
\index{npm install}

npm は sudo 前提で設計されているようです。sudoでroot権限に昇格するのはビ
ルド時にnobody権限に切り替えるのに使うようです。

npmパッケージはシステムグローバルにもパッケージローカルにもインストールで
きますが、一般ユーザ権限でプロジェクトローカルに利用するためにパッケージ
をインストールすることを基本として設計されているようです。

\texttt{sudo npm install パッケージ名}
だとカレントディレクトリ以下にsudoを発行したユーザ権限でインストールする
ようです。\footnote{ビルド自体はnobody権限で行うようです}
\texttt{sudo npm install -g パッケージ名} だと \verb!/usr/lib/node_modules! 以下にインストール
するようですが、権限はnobodyのままです\footnote{挙動としてはおかし
いので操作を間違っているかバグのように思われる}。

npmは開発者視点で便利なように設計されているようで、個人的におもしろいなと思った
のは -g をつけずに \texttt{sudo npm install} だけすると現在のディレクトリにあるプロジェ
クトの依存しているパッケージをカレントディレクトリにインストールするとい
う挙動になることです。依存しているパッケージがどんどん変更されている
熱いプロジェクトであるnodeっぽい感じがします。
npmの作者のウェブサイトを読んでいると、システムワイドでインストールする
のはCLIツールなどに必要な時に限って、ウェブサイトにデプロイする用のコー
ドではモジュールはプロジェクトのディレクトリにインストールすることを推奨
すると説明しています。

\begin{commandline}
# apt-get install nodejs nodejs-dev
# curl http://npmjs.org/install.sh | sh
$ sudo npm install -g express ejs socket.io
npm http GET https://registry.npmjs.org/express
npm http GET https://registry.npmjs.org/ejs
npm http GET https://registry.npmjs.org/socket.io
npm http 304 https://registry.npmjs.org/socket.io
npm http 200 https://registry.npmjs.org/ejs
npm http GET https://registry.npmjs.org/ejs/-/ejs-0.6.1.tgz
npm http 200 https://registry.npmjs.org/express
  .
  .
/usr/bin/express -> /usr/lib/node_modules/express/bin/express
ejs@0.6.1 /usr/lib/node_modules/ejs 
express@2.5.8 /usr/lib/node_modules/express 
├── qs@0.4.2
├── mkdirp@0.3.0
├── mime@1.2.4
└── connect@1.8.6
socket.io@0.9.2 /usr/lib/node_modules/socket.io 
├── policyfile@0.0.4
├── redis@0.6.7
└── socket.io-client@0.9.2
\end{commandline}
%$

ディレクトリ構成をまとめました。

\begin{table}[h]
\caption{Debianパッケージおよびnpm でインストールされる場所}
\begin{center}
 \begin{tabular}{|l|l|}
 \hline
 & ディレクトリ\\
 \hline
 Debian パッケージ & \texttt{/usr/lib/nodejs} \\
 Debian の npm  & \texttt{/usr/local/lib/nodejs}\\
 npm install -g & \texttt{/usr/lib/node\_{}modules} \\
 npm install & \texttt{./node\_{}modules} \\
 \hline
 \end{tabular} 
\end{center}
\end{table}

マニュアルなどはnpm コマンドを実行すると表示されるヘルプが充実しています。
\begin{commandline}
$ npm help
$ npm help npm
$ npm help install
\end{commandline}
%$ -- for emacs

\subsubsection{npm を使っている場合のプログラム実行}

カレントディレクトリにインストールしたときはよいのですが、そうではない場
合は、\texttt{/usr/lib/node\_{}modules}以下にインストールされてもDebianの
nodejs の標準のモジュールパスに含まれていないためモジュールがロードされません。

ひとつの回避策としてはモジュールを探しに行くPATHを追加するという方法があります。
\texttt{NODE\_{}PATH}環境変数を指定すれば追加でロードされるようになりま
す。
\index{NODE\_{}PATH}
\begin{commandline}
$ NODE_PATH=/usr/lib/node_modules node ./program.js 
\end{commandline}
%$ -- for emacs

\subsubsection{パッケージのメタデータ: package.json}

推奨されているのはパッケージに必要なモジュールをpackage.json に記述して、
\index{npm link}
npm link コマンドを実行すればパスの追加は必要なくなります。
\begin{commandline}
$ npm link 
\end{commandline}
%$
とすると必要なモジュールをプロジェクトのディレクトリの
\texttt{./node\_{}modules}にリンクしてくれるということでした。
\footnote{マニュアルにはシンボリックリンクをすると書いているけど、モジュー
ルはハードリンクしてました。}
\footnote{逆方向に現在作業中のパッケージを/usr/lib/node\_{}modules/以下
にシンボリックリンクしてくれます。作業した内容がすぐに反映するので便利と
いえば便利。}

\index{package.json}
npmのメタデータは ./package.json です。
npm help json (man npm-json.1)に詳しく説明されています。
す。とりあえずはname/versionフィールドさえあればよくて、dependenciesを追
加するとnpm install やnpm link コマンドで利用してくれるようです。

インストールに必要なファイルの一覧や、node-waf の実行方法などが記載され
ているのでこれさえあればDebianパッケージを自動で生成することも可能な気が
します。

手元で作成してみた npm linkのためだけの最低限な内容のpackage.jsonを紹介
します

\begin{commandline}
{
    "name": "aptserver",
    "version": "v0.0.1",
    "dependencies": {
	"cli": "",
	"express": "",
	"ejs": ""
    }
} 
\end{commandline}


\subsection{とりあえず簡単なサーバを書いてみた}

apt-cache search をして出力を返すだけの簡単なサーバを書いてみました。
イベントドリブンな部分としては、HTTP requestのハンドラーをapp.get() で登
録している部分と、apt cache の出力を aptCache.stdout.on で登録したハンド
ラーで取得して aptCache.on exit ハンドラーで終了したらHTTPレスポンスを返
すようになっている部分でしょうか。

書いてみて気づきましたが、いまいちnodeを使うメリットが出てないきもしま
す。


\begin{commandline}
/*
 * A simple server which serves apt cache search results.
 */
var child_process = require('child_process');
var cli = require('cli');
var url = require('url');
var ejs = require('ejs');

cli.parse({
    port: ['p', 'HTTP server will listen on this port.', 'number', 8088]
});

cli.main(function cliMain(args, options) {
    var express = require('express');
    var app = express.createServer();
    // set view options.
    app.set('view engine', 'ejs');
    app.set('view options', { layout: false });
    app.set('views', __dirname + '/views');

    // Set up routes.
    app.get('/', getSlash);
    app.get('/search', getSearch);

    console.log('Start listening on http://localhost:' + options.port + '/');
    app.listen(options.port);
});

/** handler for '/' request */
function getSlash(request, response) {
    response.render('index.ejs');
}

/** handler for '/search?' request */
function getSearch(request, response) {
    var query = request.query.q;
    var aptCache = child_process.spawn('apt-cache', 
				       [ 'search', query ]);
    /** Output of apt-cache search, to be used for response. */
    var responseString = '';
    aptCache.stdout.on('data', function handleAptCacheStdout(data) {
	responseString += data;
    });
    aptCache.stderr.on('data', function handleAptCacheStderr(data) {
	responseString += data;
    });
    aptCache.on('exit', function handleAptCacheExit(exitCode) {
	// apt-cache finished executing, send repsponse back to the server.
	response.render('search.ejs',
			{locals:{query: query,
				 response: responseString}});
    });
}
\end{commandline}

ejs HTMLテンプレートファイル\texttt{views/search.ejs}はこんな内容になり
ました。

\begin{commandline}
<!-- -*- html; -*- -->
<html>
  <body>
    <form
      method=GET 
      action='/search'>
      <input type=text name=q></input>
      <button>search</button>
    </form>
    <h3>Search for: <%= query %></h3>
    <pre>
<%= response %>
    </pre>
  </body>
</html> 
\end{commandline}

追加モジュールはexpress, ejs, cli を使いました。それぞれを簡単に紹介する
と以下です

\begin{itemize}
 \item express: ウェブアプリケーションフレームワークとしてnodeで最もポ
       ピュラーなモジュール、リクエストベースのルーティングなどを担当。
 \item ejs: HTMLテンプレートエンジンとしておそらく最もポピュラーなモジュール。
 \item cli: コマンドラインオプションをパースしてくれるモジュール。
\end{itemize}


\subsection{最後に}

今回は node をDebianで使う方法を紹介してみました。モジュールのパッケージ
ングが更新においついていない感じなのでもうしばらくしたらまた良くなってい
るかもしれませんが、そうこうしているうちにnode 0.8がリリースされてしまい
そうです。
node の頻繁な更新とそれによってモジュールが複数バージョン必要になってく
る現状から、nave / nvm などの環境管理ツールで複数バージョンをインストール
して利用するということもよくやられているようです。
この資料がDebianでnodeを活用するきっかけ、およびパッケージ化活動の一助になれば幸いです。

\begin{thebibliography}{0}
\bibitem{nodejslocalhtml}  Node.js v0.6.12 Manual \& Documentation
	\url{/usr/share/doc/nodejs/api/index.html}
\bibitem{pkg-javascript-devel} Alioth の 　pkg-javascript-devel メーリン
	グリスト
	\url{http://lists.alioth.debian.org/pipermail/pkg-javascript-devel/}
\bibitem{npmjs} NPMホームページ \url{http://npmjs.org/}
\bibitem{debiannode} nodejs for Debian
	\url{/usr/share/doc/nodejs-dev/README.Debian}
\bibitem{javascript-mdn} JavaScript \url{https://developer.mozilla.org/ja/JavaScript}
\bibitem{ecmascript} Standard ECMA-262
ECMAScript Language Specification 5.1 
\url{http://www.ecma-international.org/publications/standards/Ecma-262.htm}
\end{thebibliography}

\clearpage

%-------------------------------------------------------------------------------
\dancersection{Android機でDebian}{野島 貴英}
%-------------------------------------------------------------------------------
\index{debiandroid}
\index{Android}

\subsection{はじめに} 
携帯電話、タブレット型PCなど、高性能の情報端末を持ち歩くのが一般的になってきました。
ここでは、これら情報端末のうち、Android OSを搭載した情報端末にDebianを入れ、
Debian開発者の環境を築いてみようとした事について述べます。

\subsection{材料：Android端末 Barnes \& Noble Nook Colorについて}
\index{nook color}

手頃なAndroid端末として、たまたま手元にBarnes \& Noble社(以下B\&N)の
Nook Colorという製品\footnote{\url{http://www.barnesandnoble.com/p/nook-color-barnes-noble/1100437663}}があります
\footnote{製品の写真は権利関係がよく判らないので割愛させてください。詳し
くは先のURL参照。}。
値段も日本で輸入した場合、2万円前半〜後半ぐらいで安く、電子書籍ビューアということもあり
デザインも小型でそれなりに薄く軽量です。これは元々、PDFにした
カラーの本（漫画も）を持ち歩きながら読めればと思って買っていたものでした。

これがDebianの開発環境としても動いたら素敵と思い、こちらを
早速利用する事にします。
\footnote{実は、自分はフィーチャーフォン（ガラケーともいう）しか持っておらず、Android端末はこれしか持ってなかったことは秘密です。}

\subsection{Android端末のDebian動作の方針}

Android端末を利用してDebian関係のディストリビューションのOSを動作させる場合、
後に述べる２つの方針が取れます。

\subsubsection{方針1: Android端末の機能を最大限活用する}

本方針は、Android端末はベースのOSが基本的にLinuxであることを最大限利用します。

ここで、
\begin{enumerate}
\item Android端末のCPUにあわせたDebian関係のLinuxのファイルシステムを/（ルート）ファイルシステムからSDカードや、内臓メモリへ用意します。
\item Android端末にAndroidアプリのVNC Viewer\footnote{\url{http://code.google.com/p/android-vnc-viewer/}}を搭載しておきます。
\item 何らかの方法でAndroid端末上の管理権限を奪取した状態で、先ほど用意した/ファイルシステムをマウントし、chrootします。これでDebianのバイナリが動作できるようになります。
\item 最後にDebianのバイナリを利用してvncserverを立ち上げ、AndroidアプリのVNC Viewerで127.0.0.1:5901に接続し、Debianを利用します。
\end{enumerate}
という方法がよく利用されます。

この方法は、Android端末で管理権限さえ奪取できていればDebian関係のLinuxディストリビューションを動作させる事ができます。
さらに良いことに、本体のAndroid端末が最初から搭載している無線ネットワークもそのまま利用できるるため、非常に都合が良いです。
実際、自分は未評価ですがこれらの諸々の手続きを全部アプリに詰め込んでしまったものに、

\begin{itemize}
\item Ubuntuを動作させるAndroid アプリ：ubuntu instller free \url{https://play.google.com/store/apps/details?id=com.zpwebsites.ubuntuinstall&hl=ja}
\item Debianを動作させるAndroid アプリ: Lil' Debi \url{https://github.com/guardianproject/lildebi/wiki}
\end{itemize}
などがあるようです。

% ubuntu on nook スレ
% http://forum.xda-developers.com/showthread.php?p=10306407
\subsubsection{方針2: Android OSを使わずそのままDebianをブートする}

Android端末は大抵ARMベースのCPUで動いてます。DebianもARMベースのバイナリを
用意しています。これはつまり、うまくカーネル/アプリケーションをAndroid端末の
ハードの仕様に合わせることができ、ブートさせる事ができれば、Android OSの
代わりにDebianをそのままブートさせて使えるはずです。

ただ、Android端末はARMベースのCPUは使っているものの、グラフィックス
（液晶画面出力）、タッチパネル、サウンド、Wi-Fi等は各端末のハード独自のものでかつ、
仕様/設計は未公開であったり、Linuxカーネル本体の機能だけでは対応できなかったりする為、
これらの周辺デバイスを利用できるようにする為のハードルは高い状況です。特に、
Wi-Fiはおろか、通常のデスクトップPCを使っているときにはあまりに基本的な機能で
気にもとめなかったような機能（キー入力、マウス入力、画面に文字を描画）すらも
最初から未対応がほとんどですので、本方針を取るにはそれ相応のスキルが必要です。
（VGA BIOSとか、IBM PC ATのBIOSの規格が大変ありがたく見えてきます）

但し、本方針でもしDebianをそのまま利用できれば、より自由なソフトウェア開発環境を
搭載した携帯端末を手にできる事になる為、非常に魅力的ではあります（よね？）

\subsection{数々の障害と方針変更}

先に述べた方針1が手軽なはずなので、こちらの方針をとって作業を進めていました。
が、実は以下に列挙する問題にあたってしまい、解決出来なかった為、不完全ながらも
方針2を取らざるを得ない状況となってしまいました。

\begin{enumerate}
\item B\&NのNook Colorは、Android 2.1〜2.2 OSを改造して電子書籍端末にした製品のため、通常のAndroid OSとは異なります。
そのため、Android端末でそのまま動作させることができるようなアプリをどうやってもインストールできませんでした。
つまり頼みのVNC Viewerを動作させる事が出来ませんでした。また、こちらの原因を調べようにも、ソース公開義務の発生しない
肝心のライブラリ、アプリケーションフレームワーク、アプリケーション
\footnote{Android OSの用語となります。基本的なAndroid OSの構造：\url{http://developer.android.com/images/system-architecture.jpg}}
が全くの非公開であるため原因追求が困難です。
\item 管理権限を奪取してadbが使えるようにしたのですが、USB経由で利用するNook Color側のadbdの動作が非常に不安定で、
一度でもUSBを外す/PCの電源を落とす/何もせず時間を空けると次からどうやっても端末側adbdに接続できなくなる現象に悩まされました
（管理権限奪取の方法を最初からやり直すと復活できる事がたまにありましたが、なぜか失敗する事が多いです。）
さらに悪い事に、端末側ファームを1.2.2にアップデートすると、もはやどうやってもadbdに接続できなくなってしまいました
\footnote{後の調査でわかったことですが、Wi-Fi経由で端末側adbdに接続すると安定するかも？との情報もあります。しかし、無線LAN環境を自分は持っていない為こちらも未評価です}。
\end{enumerate}

そこで、方針1をあきらめ、方針2を取る事にしました。

\subsection{再考：Nook Color}

DebianをAndroid端末の機能を最大限活用して動作させるのにいろいろてこずる
Nook Colorですが、このやり方を諦めれば、唯一Debianを動作させるのに救いのある機能があります。
Nook ColorはminiSDを挿入して利用できるのですが、ここにOMAP用ブート形式
\footnote{\url{http://processors.wiki.ti.com/index.php/SD/MMC_format_for_OMAP3_boot}。
但しこのページのコマンド通りにそのままfdisk実行しても、Debianではブートイメージは作れないので注意。}
のブートイメージを書きこんでおくと、こちらからそのままブートしてしまう機能（脆弱性？）があります。

そこで、ここにブートイメージを書き込んで、ブートすればDebianを利用できるのでは？
という事を試しました。

\subsection{DebianのNook Color用ブートイメージを作る}

\subsubsection{方針}

ここでは、以下の方針にそってブートイメージを作成します。

\begin{enumerate}
\item qemuを使ってDebianのARM用ディスクイメージを構築します。
\item Nook Colorのroot奪取に使うnooter0.2.zipのカーネル/initrdイメージはNook ColorのUSBをRNDIS用のネットワークI/Fにセットアップする能力を持ちます。これを利用すると、コミュニケーションポートとしてUSBが非常に便利になるのでこれらを拝借します。
\item 以上1,2を合体したOMAP用ブート形式のminiSDカードを作成します。
\end{enumerate}

具体的なやり方を次に述べます。

\subsubsection{やり方}

用意するもの：Debian sidの動くPC,グローバル回線, miniSDカード1枚、必要ならminiSDカー
ドリードライター（USBメモリに変換するタイプのコネクタでも可）

\begin{enumerate}
\item  諸々PC側に取り揃えます。
\begin{commandline}
$ sudo aptitude install debian-installer-6.0-netboot-armel qemu-system util-linux kpartx dump unzip gvncviewer
$ wget http://cgit.openembedded.org/openembedded/plain/contrib/angstrom/omap3-mkcard.sh; chmod 755 omap3-mkcard.sh
\end{commandline}

\item イメージディスクの準備をします。
\begin{commandline}
$ qemu-img create -f raw arm-versatile.img 5G
\end{commandline}
%$

\item インストール作業を行う為、以下のコマンドを実行します\footnote{LXDEデスクトップにする理由は、GNOMEだとメモリの必要量が多すぎてswapが発生してしまい、快適に動作しない為です}。

\begin{commandline}
$ qemu-system-arm -M versatilepb -kernel /usr/lib/debian-installer/images/armel/versatile/vmlinuz-2.6.32-5-versatile \
 -initrd /usr/lib/debian-installer/images/armel/versatile/initrd.gz -m 256 -drive file=./arm-versatile.img,if=scsi,\
 bus=0,unit=0,cache=writeback -append "root=/dev/ram desktop=lxde priority=medium"
\end{commandline}
%$

\item  Debianインストーラがウインドウに立ち上がり、通常のインストーラメニュー形式のDebianのインストールを進める事ができるようになります。ネットワークも自動的に認識(IPアドレスなども)され、qemuの持つネットワークの仕組みでPCに接続されたネットワークがそのままネットワーク経由のインストールに利用されます。表\ref{tab:armsid-ver}を選択しつつインストールを行います。

\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|p{5cm}|p{5cm}|l|}
\hline 
項番&設定項目&指定内容&備考\\
\hline \hline
1&Choose language & Japanese 日本語 &\\
2&ネットワークの設定 & DHCPでネットワークを自動で設定 & \\
3&インストールするDebianバージョン&sid&\\
4&ロードするインストーラコンポーネント&何も選ばない&何も選ばないが、「続ける」だけは選択\\
5&ディスクのパーティショニング&ディスク全体を使う,すべてのファイルを1つのパーティションに&\\
6&ソフトウェアの選択&デスクトップ環境、ラップトップ、標準システムの3つ& お好みで\\
7&インストールするLinuxカーネルのバージョン&3.2.0-2& \\
\hline
\end{tabular}
\caption{\label{tab:armsid-ver}インストーラで選択する項目}
\end{center}
\end{table}

\item インストールが完了し、最後にシャットダウン画面になります。最後Reboot systemの指示が出たのを確認してそのままqemuをCtrl+Cで停止させます。

\item インストール完了後のディスクイメージに内臓されているカーネルイメージ、initrdイメージを取り出します。

\begin{commandline}
$ mkdir debian
$ sudo kpartx -a ./arm-versatile.img 
$ sudo mount -t ext3 /dev/mappoer/loop0p1 ./debian
$ cp debian/boot/initrd.img-3.2.0-2-versatile .
$ cp debian/boot/vmlinuz-3.2.0-2-versatile .
$ sudo umount ./debian
$ sudo kpartx -d ./arm-versatile.img
loop deleted : /dev/loop0
$
\end{commandline}
%$

\item 以下のコマンドで取り出したカーネルイメージ、initrdイメージで再度qemuを立ち上げます。xdmの画面が出るので、そのままログインします。するとLXDEのデスクトップ画面が現れます。

\begin{commandline}
$ qemu-system-arm -M versatilepb -kernel ./vmlinuz-3.2.0-2-versatile \
 -initrd ./initrd.img-3.2.0-2-versatile -m 256 -drive file=./arm-versatile.img,if=scsi,\
 bus=0,unit=0,cache=writeback -append "root=/dev/sda1 "
\end{commandline}
%$

\item LXDEの画面から、lxterminalを開き、パッケージをアップデートします。さらに、vncサーバーの導入を行っておきます。

\begin{commandline}
$ su root
Passwd: インストール時のrootパスワード
# aptitude update;aptitude safe-upgrade;aptitude install tightvncserver
\end{commandline}
%$

\item vncサーバーのインストールが完了したら、LXDE端末画面でシャットダウンします。
\begin{commandline}
$ sudo shutdown -h now
\end{commandline}
%$

\item Power offのメッセージが出力されたら、qemuをCtrl+Cで停止します。

\item miniSDをPCに差し込みます。mountされてしまっているようであれば、{\bf 必ずumount}しておきます。（注：ここでは/dev/sdb1としてマウントされてしまった事を過程します）
\begin{commandline}
$ sudo umount /dev/sdb1
\end{commandline}
%$
Tips:\\
なお、PCのminiSDのリーダ/ライターを搭載している場合、miniSDアクセス用のチップがRicho R5C822を搭載している場合で（よくある）、miniSDを挿入すると''mmc0: error -110 whilst initialising SD card''や、''mmc0: Reset 0x1 never completed''などが大量にdmesgに記録されて全くアクセスできない場合があります。この場合は以下の定義を/etc/modulesに記載してリブートすると、安定してminiSDへアクセスできるようになります。
\begin{commandline}
$ cat /etc/modules
...中略...
# for R5C822
mmc_block
tifm_sd
$ 
\end{commandline}

\item miniSDにOMAP用ブート形式のパーティションを作成します。\\
注：{\bf 必ずminiSDの認識されているデバイスファイルをomap-mkcard.shに指定してください！}ここでは/dev/sdbと仮定しています。間違ったデバイスファイルを指定すると該当ディスクの中身が消えてしまいます！
\begin{commandline}
$ sudo ./omap3-mkcard.sh /dev/sdb
\end{commandline}
%$

\item nooter0.2配布先(\url{http://www.mediafire.com/?cfddu9wt9d8dunl})をepiphanyなどのWEBブラウザでアクセスして、nooter0.2.zipを入手します。

\item 解凍して、ディレクトリnooter/にマウントします。
\begin{commandline}
$ unzip nooter0.2.zip
$ mkdir nooter
$ sudo kpartx -a ./nooter_sdcard_40mb.img
$ sudo mount /dev/mapper/loop0p1 ./nooter
\end{commandline}
%$

\item miniSDカードの1つ目のパーティション(/dev/sdb1)をマウントします。
\begin{commandline}
$ mkdir miniSD
$ sudo mount -t vfat -o rw,uid=your-uid,gid=your-gid /dev/sdb1 ./miniSD
\end{commandline}
%$

\item nooterのu-bootイメージ、カーネルイメージ、initrdイメージをコピーして、miniSD,nooterをアンマウントします。
\begin{commandline}
$ cp nooter/* ./miniSD/
$ sudo umount ./nooter
$ sudo kpartx -d ./nooter_sdcard_40mb.img
loop deleted : /dev/loop0
$ sudo umount ./miniSD
\end{commandline}
%$ 

\item miniSDの２つ目のパーティション(/dev/sdb2)をマウントして、Debianイメージをまるごとコピーします。終わったらアンマウントします。
\begin{commandline}
$ su root
Passwd: 
# kpartx -a ./arm-versatile.img
# mount /dev/mapper/loop0p1 ./debian
# mount /dev/sdb2 ./miniSD
# cd debian
# dump -0 -f- ./ | (cd ../miniSD && restore -rvf- )
# cd ..
# umount ./debian
# umount ./miniSD
\end{commandline}
%$ 
\end{enumerate}

以上となります。

\subsection{動作させる}

早速動作させてみましょう。

\begin{enumerate}
\item Nook Colorの電源ボタンを長押しして電源をOFFにします。
\item Nook ColorのminiSDスロットに作ったminiSDを挿入します。
\item Nook Colorに製品付属のusbケーブルを差し込み、PCのUSBに差し込みます。
\item usbケーブルが橙→緑に変わる。同時にPC側のdmesgを観察すると、cdc\_etherモジュールがロードされ、usbポートがNICに変化するのが観察できます。
\item 以下のコマンドを打ち込んで、Nook Colorへrootでログインします。なお、PC側を192.168.2.10と仮決めします。（Nook Color側はnooter由来のinitrdですと192.168.2.2に決め打ちでセットアップされます。）
\begin{commandline}
$ sudo /sbin/ifconfig usb0 inet 192.168.2.10 netmask 255.255.255.0 up
$ ssh root@192.168.2.2
# 
\end{commandline}
\item miniSDのDebianを動かし、vncserverを立ち上げます。
\begin{commandline}
# mount -t ext3 /dev/mmcblk0p2 /mnt
# mount -t devpts devpts /mnt/dev/pts
# mount -t proc proc /mnt/proc
# mount -t sysfs sysfs /mnt/sys
# chroot /mnt /bin/bash
root@bildroot:/# cd
root@buildroot:~# vncserver -geometry 800x600
Passwd: <適当にパスワード入れる>
Retry : <上と同じパスワード入れる>
...多少エラーメッセージが出てvncserverが立ち上がる気にしない...
root@buildroot:~#
\end{commandline}
\item PC側にてgvncviewerを起動すると、Nook Color上でDebianにログインした状態になる。
\begin{commandline}
$ vncviewer 192.168.2.2:1
\end{commandline}
%$
\item lxterminalをvncviewer上で開き、適当に/etc/resolv.confし、route add default gw 192.168.2.10等して、PC側をNAT設定にすると、
Nook ColorはUSB越しでPC側の持つグローバル側ネットワークを利用できるようになります。aptitudeなどもも全く問題なく出来ます。
\end{enumerate}

\subsection{電源の切り方}

いろいろ試したら、電源をOFFにしたくなるかと思います。この場合の手続きは以下の
通りです。

\begin{enumerate}
\item Nook Colorにsshログインします。
\item sync;sync;haltと打ち込みます。
\item Nook Colorとのsshが切れます。
\item Nook ColorからminiSDを抜きます。
\item Nook Colorの電源ボタンを15秒以上押します。
\item もう一度 Nook Colorの電源ボタンを15秒以上押すと、Nook Color本体がブートします。
あとはいつものNook Colorですので、そのまま電源ボタンを軽く押すなり放置するなりするといつも通りの電源OFF（Sleep?)状態になります。
\end{enumerate}

\subsection{終わりに}

今回手動でchrootすることにより、Nook ColorでDebianを動かしてみました。
これで電池動作で小型軽量ということもあり、Debianを入れたノートパソコンと
組み合わせると、ARM CPUのタブレット開発環境を持ち歩く事ができます。実際、
本記事を書くにあたり、平日は通勤電車の中を主に活用して試行錯誤していました。

今回Nook Colorが持っているLCD/タッチパネル/Audio/Wi-Fiについて一切
Debian側から制御までは到達できませんでした。100％ Debianで動く安価で軽量な
タブレット端末の開発の道は険しそうです。

次はOMAP3用のCPU向けにkernelのクロスコンパイルに挑戦してみようかと思う
この頃でした。

\clearpage


%-------------------------------------------------------------------------------
\dancersection{Python初心者が「Pythonプロフェッショナルプログラミング」を読んでみた}{やまねひでき}
%-------------------------------------------------------------------------------
\label{sec:python-professional-programing}
\index{python}

わたくし、「Pythonプロフェッショナルプログラミング」という書籍を先日購入しました。
私自身はまだ3月末ぐらいにPythonの入門から始めたばかりで本当はPythonビギナーズプログラミングが欲しいのですが、
まだ世の中にはそのような本はありませんし、この書籍自体は評判が良かったので…。

で、実際読んでみて中々実践的というか環境構築などで参考になることが多々ありました。
しかし、もうちょっと突っ込んでみたいなぁ、というところがいくつかあったので、Debianパッケージ方面からの見方として
取り上げてみようと思います。この書籍自体ではUbuntu11.10を使っていますが、私のDebian unstableのやり方でも大体のと
ころはそのまま応用が効くはずです。


\subsection{なるべくディストリビューションのパッケージを使いたい}

PythonにはPythonパッケージがあり、配布サイトPyPIがあります。PerlにCPAN、Rubyにgems、RにCRANみたいなものですね。
で、このPythonパッケージを導入するのにpipというツールを使う旨説明があるのですが(P.4)、githubからwgetして、
インストールスクリプトをsudoで実行しています。\verb!/usr/local! 以下にツールが入るわけです。書籍全体でこのpipを
使ったインストールを勧めていますが、これは美しくない。Debianパッケージにpython-pipがあるので、そちらを入れても
いいんじゃないかと思います
\footnote{pipは若干バージョンが古いですが、そんなに不都合もないかなーと。古いのが嫌ならローカルにアップデートパッケージ作っちゃうのが吉。}。
それからユーザーの HOME 以下にパッケージをインストールするvirtualenvというツールがあります。
これもpython-virtualenvパッケージを入れて対応します。この後は、virtualenvでユーザーのPython環境にpipでパッケージを入れていってもいいかな、と思います。
便利ツールとして紹介されているvirtualenvwrapperもvirtualenvwrapperパッケージがありますのでそれを入れちゃいましょう。

\begin{commandline}
$ sudo apt-get install python-pip python-virtualenv virtualenvwrapper
\end{commandline}
%$

この後でユーザー個人のPython仮想環境下にpipでPythonパッケージをガシガシ入れていくのはありだと思います。

\subsection{複数バージョンのPythonを使う、のはいいけど。}

Python2.5をインストールするのに公式のパッケージリポジトリからだと11.10に入れられないよ、ということが書いてあります(P.11)。
ここでPPAからインストールするか、ソースからインストールするかという選択になっています。業務で使う場合、そのPPAがどれほど
信用できるかを説明するのが難しいように思います。自己責任で、って書いてありますが、大抵盲目的にそのPPA信用しちゃうような…。
古いバージョンを使わなきゃダメ、という場合、私だったら「debootstrapで古い環境を作る」というやり方でやります（debootstrapについては後ほど述べます）。

それからソースからPython2.5を入れる説明ですが、

\begin{commandline}
$ wget http://www.python.org/ftp/python/2.5.6/Python-2.5.6.tgz
$ tar -xvzf Python-2.5.6.tgz
$ cd Python-2.5.6
$ LDFLAGS="-L/usr/lib/x86_64-linux-gnu" ./configure
$ make
$ sudo make install
(「Pythonプロフェッショナルプログラミング」より引用）
\end{commandline}
%$

という説明になっています。i386だとパス変わるよね…というのは読み取れるのか若干心配な所です。プロフェッショナルだからいいのかな？
必要な依存パッケージについては、最初の方のページで

\begin{commandline}
$ sudo aptitude -y install build-essential
$ sudo aptitude -y install libsqlite3-dev
$ sudo aptitude -y install libreadline6-dev
$ sudo aptitude -y install libgdbm-dev
$ sudo aptitude -y install zlib1g-dev
$ sudo aptitude -y install libbz2-dev
$ sudo aptitude -y install sqlite3
$ sudo aptitude -y install tk-dev
$ sudo aptitude -y install zip
(「Pythonプロフェッショナルプログラミング」より引用）
\end{commandline}
%$ -- for emacs

となっていました。あぁ、これはイケてない。パッケージビルド用のパッケージ取得は apt-get build-dep するべきです。
Squeezeではまだ2.5のバイナリパッケージが手に入るので、ここでは2.4をターゲットに作業してみましょう。
こんな風に\footnote{ここのパッケージ名指定は、本当はpython2.4にしたいけど無いので2.5にしています。多少の差は後で修正。}。

\begin{commandline}
$ sudo apt-get build-dep python2.5
\end{commandline}
%$

これでPythonをビルドするときに必要な依存パッケージはすべてインストールされます。あ、apt lineにdeb-srcラインを追加を忘れずに。
このやり方なら、Python以外のソフトウェアパッケージでもバージョンが変わっても大体応用が効きます。

そして「ソースからそのまま入れると\verb!/usr/local!以下に入るから、pythonとだけ打つとPATHの優先度でソースから入れたPython2.5が起動する」…という
説明が…そんな罠作らない方がいいじゃないですかー。私ならソースから入れるのなら「Python2.5のDebianパッケージを利用環境
用にリビルドしていれる」をやります。PTSのPython2.4のページ \footnote{\url{http://packages.qa.debian.org/p/python2.4.html}} 
からソースパッケージのdscファイルが取得できるので、これをdevscriptsパッケージのdgetコマンドで取得します。

\begin{commandline}
$ sudo apt-get install devscripts 
$ dget http://cdn.debian.net/debian//python2.4_2.4.6-1+lenny1.dsc
dget: retrieving http://cdn.debian.net/debian//python2.4_2.4.6-1+lenny1.dsc
--2012-05-04 03:59:21--  http://cdn.debian.net/debian//python2.4_2.4.6-1+lenny1.dsc
Resolving cdn.debian.net... 150.65.7.130
Connecting to cdn.debian.net|150.65.7.130|:80... connected.
HTTP request sent, awaiting response... 404 Not Found
2012-05-04 03:59:22 ERROR 404: Not Found.

dget: wget python2.4_2.4.6-1+lenny1.dsc http://cdn.debian.net/debian//python2.4_2.4.6-1+lenny1.dsc failed
\end{commandline}
%$

あれ、oldstableだとリンクが切れちゃいますか\footnote{これはバグ報告しましょう}。しょうがないので、archive.debian.orgに切り替えてみます。
\begin{commandline}
$ dget http://archive.debian.org/debian/pool/main/p/python2.4/python2.4_2.4.6-1+lenny1.dsc
\end{commandline}
%$ -- for emacs

これでPython2.4のソースパッケージが取得できました。ビルド用の依存パッケージは既に入れているので、ソースパッケージのchangelogに
一言書いてビルドすれば独自リビジョンをつけた deb パッケージが出来上がりますので、dpkgで入れちゃえば良いでしょう（後で述べますがaptを使ってインストールも可能です）。

\begin{commandline}
$ dpkg-source -x python2.4_2.4.6-1+lenny1.dsc
$ cd python2.4-2.4.6/
$ export DEBFULLNAME="Hideki Yamane"
$ export DEBEMAIL="henrich@debian.org"
$ dch --bpo "rebuild package for my own environment"
$ debuild -us -uc
dpkg-checkbuilddeps: Unmet build dependencies: libreadline5-dev tk8.4-dev libdb4.5-dev emacs22
dpkg-buildpackage: warning: Build dependencies/conflicts unsatisfied; aborting.
\end{commandline}
%$

あれ、依存関係が満たせない。python2.5と比較してちゃちゃっと変更しましょうか。apt-get source python2.5 として、diff取ります。

\begin{commandline}
--- python2.4-2.4.6/debian/control	2012-05-04 04:09:00.000000000 +0000
+++ python2.5-2.5.5/debian/control	2012-05-04 04:13:06.000000000 +0000
@@ -1,82 +1,96 @@
-Source: python2.4
+Source: python2.5
 Section: python
 Priority: optional
 Maintainer: Matthias Klose <doko@debian.org>
-Build-Depends: debhelper (>= 5), autoconf, libreadline5-dev, libncursesw5-dev (>= 5.3), tk8.4-dev, libdb4.5-dev, zlib1g-dev, 
libgdbm-dev, blt-dev (>= 2.4z), libssl-dev, sharutils, libbz2-dev, libbluetooth-dev [!hurd-i386 !kfreebsdi386 
!kfreebsd-amd64], locales, mime-support, libgpm2 [!hurd-i386 !kfreebsd-i386 !kfreebsd-amd64], netbase, lsb-release, bzip2
-Build-Depends-Indep: libhtml-tree-perl, texlive-latex-recommended, texinfo, emacs22, debiandoc-sgml
-Build-Conflicts: tcl8.3-dev, tk8.3-dev, python2.4-xml, python-xml
-XS-Python-Version: 2.4
-Standards-Version: 3.8.0
+Build-Depends: debhelper (>= 5), autoconf, libreadline-dev, libncursesw5-dev (>= 5.3), tk8.5-dev, libdb4.8-dev, zlib1g-dev, 
libgdbm-dev, blt-dev (>= 2.4z), libssl-dev, libbz2-dev, libbluetooth-dev [!hurd-i386 !kfreebsd-i386 !kfreebsd-amd64], 
locales [!avr32 !m68k], libsqlite3-dev, libffi-dev (>= 3.0.5-2), mime-support, libgpm2 [!hurd-i386 !kfreebsd-i386
 !kfreebsd-amd64], netbase, lsb-release, bzip2, netbase, sharutils
+Build-Depends-Indep: libhtml-tree-perl, texlive-latex-recommended, texinfo, emacs23, debiandoc-sgml, latex2html
+Build-Conflicts: tcl8.4-dev, tk8.4-dev, tcl8.3-dev, tk8.3-dev, python2.5-xml, python-xml
+XS-Python-Version: 2.5
+Standards-Version: 3.9.1
\end{commandline}

debian/changelog ファイルはこんな感じにしておきましょう。

\begin{commandline}
python2.4 (2.4.6-1+lenny1~bpo60+0.1) squeeze-backports; urgency=low

  * Rebuild for squeeze-backports.
    - debian/control
     + set Build-Depends: libreadline-dev, tk8.5-dev, libdb4.8-dev 
     * set Build-Depends-Indep: emacs23
  * rebuild package for my own environment

 -- Hideki Yamane <henrich@debian.org>  Fri, 04 May 2012 04:16:39 +0000
\end{commandline}

\begin{commandline}
$ debuild -us -uc
$ ls ../*.deb
../idle-python2.4_2.4.6-1+lenny1~bpo60+0.1_all.deb
../python2.4-dev_2.4.6-1+lenny1~bpo60+0.1_amd64.deb 
../python2.4-minimal_2.4.6-1+lenny1~bpo60+0.1_amd64.deb
../python2.4-dbg_2.4.6-1+lenny1~bpo60+0.1_amd64.deb
../python2.4-examples_2.4.6-1+lenny1~bpo60+0.1_all.deb
../python2.4_2.4.6-1+lenny1~bpo60+0.1_amd64.deb
$ sudo dpkg -i ../python2.4_2.4.6-1+lenny1~bpo60+0.1_amd64.deb  ../python2.4-minimal_2.4.6-1+lenny1~bpo60+0.1_amd64.deb
\end{commandline}
%$ -- for emacs

これでpython2.4と打ったときだけ起動するようになります。…結構面倒臭いですね。chroot するのが手っ取り早そう…。

\subsection{ソースからビルドする時、again}

「ソースコードからビルドする」(P.390)では、Python Imaging Libraryをソースからビルドする場合について触れられています。
これもpython-imagingという名前のDebianパッケージは提供されていますが、ソースから入れたいときもあるのでしょう。で、書籍ではビルドする前に

\begin{commandline}
$ sudo aptitude install python-dev build-essential
$ sudo aptitude install libjpeg62-dev libfreetype6-dev zlib1g-dev liblcms1-dev
(「Pythonプロフェッショナルプログラミング」より引用）
\end{commandline}
%$

としています。既にパッケージがあるのなら、ここはもう分かりますね？ apt-get build-dep です。

\begin{commandline}
$ sudo apt-get build-dep python-imaging
\end{commandline}
%$ -- for emacs

これで漏れなく python-imaging をビルドするときに必要なパッケージが一揃いインストールされますし、
ディストリビューションのバージョンが変わってビルド用のパッケージ名が変わったとしても必要となる
依存パッケージは変わりなくインストールされます。

\subsection{さらにさらにソースからビルドする時}

出来れば pbuilder でローカルの環境をなるべくクリーンに保ってビルドする方が良いですね
\footnote{あ、Ubuntuの場合はLaunchpadにアカウント作って独自PPA運用の方がいいのかも?}。

\begin{commandline}
$ sudo apt-get install devscripts 
$ dget http://archive.debian.org/debian/pool/main/p/python2.4/python2.4_2.4.6-1+lenny1.dsc
$ sudo apt-get install pbuilder
$ sudo pbuilder --create
$ sudo pbuilder --build python2.4_2.4.6-1+lenny1.dsc
\end{commandline}
%$ -- for emacs

\subsection{ローカルのdebパッケージのインストールについて}

「閉じた環境のインストール」(P.259)というので、Debianパッケージをaptitudeを使ってダウンロードしたり、
パッケージキャッシュからパッケージを取得したりということが書いてあります。しかし、この書籍では「\texttt{dpkg -i *}」
としてパッケージをインストールしようという説明が。しかもパッケージが足りないとエラーになるけど、地道にやろうなどと
書いてあります。ダメのダメダメです。私なら以下のようにします。

\begin{enumerate}
 \item apt-utils パッケージをインストールする「apt-get install apt-utils」
 \item deb パッケージを集めたディレクトリ（ここでは \texttt{/home/username/packages} としましょうか）で「\texttt{apt-ftparchive package . | gzip -c9 > Packages.gz}」として \texttt{Packages.gz} ファイルを生成します。このファイルにはパッケージ情報がリストアップされています。
 \item \texttt{/etc/apt/sources.list} ファイルを編集して、パッケージの入手ソースとして先ほどのパッケージを集めたディレクトリを追加します。「deb file:///home/username/packages/ ./」などとしておけば良いでしょう。
 \item 「apt-get update」としてパッケージデータベースを更新します。
 \item 必要なパッケージをapt-get installでインストールしましょう。
\end{enumerate}

\begin{commandline}
$ sudo apt-get install apt-utils
$ cd ~/packages
$ apt-ftparchive package . | gzip -c9 > Packages.gz
$ sudo sh -c "echo deb file:///home/username/packages/ ./ > /etc/apt/sources.list"
$ sudo apt-get update
$ sudo apt-get install <package name>
\end{commandline}
%$

これで１個１個依存関係を確認しつつ地道にやるなどということからはおさらばですし、
普段やりなれているパッケージインストール方法ともシームレスです。パッケージが増えたら \texttt{apt-ftparchive} しなおして \texttt{apt-get update} で。

\subsection{パッケージ一覧の取得}

「必要なパッケージを列挙する」(P.256)ではaptitudeでインストールしたパッケージの一覧は dpkg -l でリストを作って活用するとあります。
いちいちパッケージバージョンを記載する必要があるなら別ですが、こんなやり方はどうでしょう?

\begin{commandline}
$ dpkg --get-selections > package-list.txt
\end{commandline}
%$ -- for emacs

これでインストールしてあるパッケージの一覧が取得できます。そしてさらに、この一覧をdpkgに食わせてインストールも可能です。

\begin{commandline}
$ sudo dpkg --set-selections < package-list.txt
$ sudo apt-get dselect-upgrade
\end{commandline}
%$ -- for emacs

これで別のマシンでも同じパッケージを放り込むことが出来ます。

\subsection{検証環境を用意する}

「動作を検証する」(P.264)では、検証環境としてVirtualBoxをインストールすることが触れられています。
それもいいけど、Debianならdebootstrapがあるじゃないですか。debootstrapはローカルに指定したバージョンのまっさらな最小限の
Debian環境を作ることが出来るツールです。適宜chrootして使うことになります。

\begin{commandline}
$ sudo apt-get install debootstrap
$ sudo mkdir -p /srv/chroot/{lenny-i386,squeeze-amd64}
$ sudo debootstrap --arch i386 lenny /srv/chroot/lenny-i386 http://archive.debian.org/debian
$ sudo debootstrap --arch amd64 squeeze /srv/chroot/squeeze-amd64 http://ftp.jp.debian.org/debian
\end{commandline}
%$ -- for emacs

--arch でアーキテクチャを、その次にバージョンのコードネームを、chroot環境を作るディレクトリ、取得先のサーバーと指定すればOKです。
ここではi386環境のDebian5.0とamd64環境のDebian6.0環境を作ります。ミソとしては、Debian5.0は既にミラーサーバーからは移動されているので
古いバージョンの集積場所であるarchive.debian.orgを指定しなければならないのを知っておくことです。

あとはchrootします。実際に構築している環境で先に述べたパッケージ一覧を取得しておき、適当なパッケージ一覧を食わせてやってインストールすれば
楽でしょう。あぁ、アーカイブされていないバージョンだとapt-lineにsecurity.debian.orgを追加しておくのも忘れないように。

\begin{commandline}
$ cp package-list.txt /srv/chroot/lenny-i386/tmp/
$ LANG=C sudo chroot /srv/chroot/lenny-i386 /bin/bash
# dpkg --set-selections < /tmp/package-list.txt
# apt-get dselect-upgrade
\end{commandline}
%$

\begin{commandline}
$ cp package-list.txt /srv/chroot/squeeze-amd64/tmp/
$ LANG=C sudo chroot /srv/chroot/squeeze-amd64 /bin/bash
# echo "deb http://security.debian.org/ squeeze/updates main contrib non-free" >> /etc/apt/sources.list
# apt-get update
# dpkg --set-selections < /tmp/package-list.txt
# apt-get dselect-upgrade
\end{commandline}
%$

まぁ、仮想環境でやるのもいいですが、こういうツールを使うやり方も取り上げてほしいものだなぁ、と思います。

\subsection{最後に}

いかがでしたでしょうか。異論もあろうとは思いますが、こんな見方もできるんだよ、ということで。
それよりもPythonちゃんと使えるようになれよ＞お前　という気もしますが、それは追々。

\clearpage

%-------------------------------------------------------------------------------
\dancersection{coffeescriptを使ってみた}{上川純一}
%-------------------------------------------------------------------------------
\index{coffeescript}

\subsection{はじめに}

Coffeescriptとはjavascriptを使いやすくしたプログラミング言語です。
Coffeescriptはjavascriptに変換されてブラウザなどで実行できます。Node など
を利用してサーバーサイドもクライアントサイドもjavascriptでプログラミング
しているとjavascriptの罠だったり、冗長な部分などが目についてきます。それ
をカバーしてくれるよい言語のようです。入門書\cite{smoothcoffeescript}を読
んだついでにDebianでcoffeescriptを利用する方法について紹介します。

\subsection{coffeescriptを使うと何がうれしいのか}

\subsection{Debianで使うには}

nodeのモジュールの中ではcoffeescriptはポピュラーです。\footnote{2012年
5月7日調べ、npmjs.org の依存関係ランキングではunderscoreの次にcoffee-script。}
node のモジュールとしてcoffeescriptを利用するのがおそらくポピュラーな方
法だと想像しています。

Debianパッケージとしては関連のものがいくつかあります。\footnote{2012年5月16日時点ではwheezyに入っておらず、sidのみ。}
\begin{commandline}
$ apt-cache search coffeescript 
coffeescript - interpreter and compiler for the CoffeeScript language
coffeescript-doc - documentation for the CoffeeScript language
libjs-coffeescript - client-side interpreter for the CoffeeScript language
\end{commandline}
%$ -- for emacs

npm では \texttt{coffee-script} モジュールをインストールすることになります。

\begin{commandline}
$ sudo npm install -g coffee-script
\end{commandline}
%$ -- for emacs

\subsubsection{ブラウザ上での利用}

ブラウザ上で利用する場合はどうするのがよいのでしょうか。
\texttt{libjs-coffeescript}パッケージとして minify されているcoffeescriptの処理系
が配布されているのでこれを利用するのがよいでしょう。

\texttt{coffee-script.js} がコードを一つのファイルにまとめたもの、
\texttt{coffee-script.min.js} が minify (uglify?)されているものです。

\begin{commandline}
/usr/share/javascript/coffeescript/coffee-script.min.js
/usr/share/javascript/coffeescript/coffee-script.js
\end{commandline}

scriptのtype=text/coffeescriptとなっているところを処理してくれるようです。
例としてHTMLはこのようになるようです。minifyされているとはいえ169kB ある
処理系をダウンロードしないといけないのでサーバサイドでcoffeescriptプログラムをコンパイルして一つのjsに変換
してからクライアントサイドで利用するほうが好ましい気がします。

\begin{commandline}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Hello world</title>
    <script type='application/javascript' src='coffee-script.min.js'></script>

    <script type='text/coffeescript' src='./hello.coffee'></script>

    <script type='text/coffeescript' >
console.log 'This is a pen'
    </script>
  </head>
  <body>
    <h1>Hello world</h1>
  </body>
</html>

\end{commandline}

コンパイルするには\texttt{coffee -c }を利用します。
\begin{commandline}
$ coffee -c class.coffee 
\end{commandline}
%$ -- for emacs

\subsubsection{クライアントアプリケーション上での利用}

ローカルマシンで動かす目的のCLIなどのアプリケーションの場合はどうなるで
しょうか。

coffeescriptパッケージにはいっているcoffee コマンドを利用するとスクリプ
トをコンパイル・実行できます。coffeescriptでは\#がコメントとして扱われる
ため、she-bang の指定が可能です。

\begin{commandline}
$ cat shebang.coffee
#!/usr/bin/env coffee
util = require 'util'
util.log 'hello world'
$ ./shebang.coffee
8 May 17:08:25 - hello world
\end{commandline}
%$ -- for emacs

\subsubsection{サーバサイドでの利用}

ウェブアプリケーションのサーバ上でCoffeescriptで書いたものを利用するには
どうしたらよいでしょうか。

サーバは基本的にはCLIプログラムとして実行すれば良いので、Coffeescriptプ
ログラムとしてサーバを書いてしまえばそれでよいです。

また、Coffeescriptで書いたコードをJavascriptに変換してブラウザに送るとい
う仕組みもあると思います。

例を書いてみましょう。

\begin{commandline}
cli = require 'cli'

cli.parse {
    port: ['p', 'port number to listen to', 'number', 8088]
}

http = require 'http'

cli.main (args, options) ->
  http.createServer((req, res) ->
    res.writeHead 200, {'Content-Type': 'text/plain'}
    res.end 'Hello world\n').listen options.port
  console.log 'Server running at http://localhost:' + options.port + '/'
\end{commandline}

\subsection{ソースコードの編集環境}

emacs の場合はcoffeescript用のモードがあるようです\cite{coffee-emacs-mode}。
Debian Packageにはまだなってない気がしています。

\subsection{おわりに}

Debianでの Coffeescript の開発環境について紹介しました。DebianでNodeに挑
戦したい、でもNodeってJavascriptで書かないといけないんでしょ、と尻込みし
ているあなたにお勧め、かもしれません。

\begin{thebibliography}{0}
\bibitem{coffeescriptlocalhtml} coffeescriptのソースコードと解説
	\url{/usr/share/doc/coffeescript/html/}
\bibitem{smoothcoffeescript} Smooth Coffeescript
	\url{http://autotelicum.github.com/Smooth-CoffeeScript/}
\bibitem{coffee-emacs-mode} Emacs Major mode for Coffeescript
	\url{https://github.com/defunkt/coffee-mode}
\end{thebibliography}

%-------------------------------------------------------------------------------                                                                                                                            
\dancersection{Dynamic Kernel Module Support Framework}{岩松 信洋}
%-------------------------------------------------------------------------------                                                                                                                             
\index{dmks}

\subsection{Dynamic Kernel Module Support Frameworkとは}

Dynamic Kernel Module Support Framework（以下、DKMS）は、
マシンにインストールされているカーネル毎に
自動的にドライバモジュールをビルドし管理する仕組みです。

通常、Linuxカーネルが更新されたとき、Linuxカーネルで提供されていない
サードパーティのドライバはそのLinuxカーネル用にデバイスドライバを
再ビルドおよびインストールを行う必要があります。
しかし DKMS を使ってサードパーティのデバイスドライバを管理している場合、
新しいLinuxカーネルで起動された時に対応したデバイスドライバがないことを
チェックし、ドライバモジュールをビルドして
（自動インストールが設定されていれば）インストールします。
もちろんそのドライバはLinuxカーネルに対応している必要がありますが、
ドライバがメンテナンスされていれば、半自動的に新しいカーネルへ移行
できるようになります。

\if 0
メリットが大きい DKMS ですが、起動時にビルドする
ので、規模が大きいドライバモジュールでは起動に時間がかかるという
デメリットもあります。
\fi

DKMS は DELL \url{http://linux.dell.com/dkms/} で開発されており、
DebianやUbuntuなどののディストリビューションで利用できるようになって
います。

ちなみに Fedora は
Kmods2 \url{http://rpmfusion.org/Packaging/KernelModules/Kmods2} と呼ばれる
別のフレームワークを利用しています。Arch Linux と Gentoo も DKMS サポート
パッケージもあるが、独自の実装が中心のようです。

今回は DKMS の仕組みと DKMS に対応したパッケージの作成方法、
Debian の DKMS 対応状況について説明します。

\subsection{DKMS の仕組み}

\begin{multicols}{2}

DKMS の仕組みを理解するために簡単なデバイスドライバを使って
説明します。ドライバをロードすると カーネルデバッグメッセージ
に「Hello, world! from hello\_init」、ドライバをアンロードすると
「Good bye! from hello\_exit」と出力するものです。
以下に実際のソースコード、Makefile、実行結果とディレクトリ構成を示します。

ドライバソースコード:
\begin{commandline}
#include <linux/init.h>
#include <linux/module.h>

static int __init hello_init(void)
{
  pr_info("Hello, world! from %s\n", __func__);
  return 0;
}

static void __exit hello_exit(void)
{
  pr_info("Good bye! from %s\n", __func__);
}

module_init(hello_init);
module_exit(hello_exit);
MODULE_LICENSE("GPL v2");
\end{commandline}
%$

Makefile:
\begin{commandline}
obj-m:= src/
\end{commandline}
%$

src/Makefile:
\begin{commandline}
obj-m:= hello.o 
\end{commandline}
%$


ドライバのコンパイルと実行結果:
\begin{commandline}
$ make -C /lib/modules/`uname -r`/build M=`pwd` modules
$ sudo insmod hello.ko
$ dmesg | tail -1
[5963787.044134] Hello, world! from hello_init
$ sudo rmmod hello.ko
$ dmesg | tail -1
[5963798.420368] Good bye! from hello_exit
\end{commandline}
%$

ディレクトリ構成:
\begin{commandline}
hello-0.0.1
├─Makefile
├── README
├── dkms.conf
└--src
    ├── Makefile
    └── hello.c
\end{commandline}

dkms.conf:
\begin{commandline}
PACKAGE_NAME="hello"
PACKAGE_VERSION="0.0.1"
BUILT_MODULE_NAME="$PACKAGE_NAME"
BUILT_MODULE_LOCATION="src"
DEST_MODULE_LOCATION="/updates"
AUTOINSTALL="yes"
\end{commandline}
%$

\end{multicols}

\subsubsection{DKMS 全体の流れ}

DKMS の全体の流れは以下のようになっています。
各要素はDKMS で提供されているコマンドとスクリプトになっています。

\begin{figure}[ht] 
 \begin{center}
  \includegraphics[width=0.4\hsize]{image201202/dkms.png}
 \end{center}
\label{fig:dkms}\caption{DKMS 全体の流れ}
\end{figure}

dkms\_autoinstaller はシステム起動時に呼ばれる
\footnote{ディストリビューションによって異なる}スクリプトです。
既に DKMS に登録（dkms add）されているドライバモジュールの中で、
現在起動しているカーネル用にドライバモジュールがインストール
（dkms install）されていないものがあれば、
ドライバモジュールのビルドとインストール
（dkms build / dkms install）が実行されます。

\subsubsection{モジュールソースコードの配置位置}

DKMS 対応モジュールのソースコードは
\url{/usr/src/ドライバモジュール名-バージョン/} 以下に配置する必要があります。
先のドライバの場合、\url{/usr/src/hello-0.0.1/} 以下に配置します。

\subsubsection{DKMS 設定ファイル}

DKMS は、各ドライバパッケージ毎に設定ファイルを持つ必要があります。
この設定ファイルでは、どのようなドライバが提供、ビルド、インストールされるのか
記述されている必要があります。以下によく利用する設定項目を示します。
\begin{table}[ht]
 \caption{DKMS 設定ファイル項目}
 \label{tab:dkms-config-file}
\begin{center}
  \begin{tabular}{|l|p{35zw}|}
 \hline
 設定項目 & 内容 \\
 \hline \hline
PACKAGE\_NAME & パッケージ名 \\
PACKAGE\_VERSION & パッケージバージョン \\
CLEAN & キャッシュなどの一時ファイルを削除するためのコマンドを指定する。指定しない場合には "make clean" が実行される。\\
MAKE & モジュールをビルドするコマンドを指定する。\\
BUILT\_MODULE\_NAME & ドライバモジュールの名前を指定する（拡張子は必要なし）。\\
BUILT\_MODULE\_LOCATION &  ビルドされたモジュールが作成されるディレクトリまでの相対パス\\
DEST\_MODULE\_LOCATION & モジュールをインストールするディレクトリを指定する。\\
AUTOINSTALL & モジュールを自動的にインストールするか、"yes" か "no" を指定する。\\
REMAKE\_INITRD & ドライバインストール時にINITRD イメージを再構成するか、"yes" か "no" を指定する。 \\
PATCH & 適用したいパッチを指定する。\\
PATCH\_MATCH & パッチを適用するバージョンの指定する。Linux カーネルが 2.6.38 と 2.6.39 の場合にパッチを適用したい場合には "2\.6\.(38|39)" と指定する。\\
 \hline
 \end{tabular}
\end{center}
\end{table}

BUILT\_MODULE\_LOCATION や BUILT\_MODULE\_NAME などは
配列を使ってドライバモジュール毎に設定できます。
BUILT\_MODULE\_NAME 配列の番号は各要素の番号に紐づいているので、
処理されるときは各々の番号が参照されます。
例えば、一つのドライバパッケージから foo と bar の２つのデバイスドライバ
が提供される場合、以下のように設定することができます。

\begin{commandline}
（省略）
BUILT\_MODULE\_NAME[0] = "foo"
BUILT\_MODULE\_LOCATION[0]  = "foo_build"
DEST\_MODULE\_LOCATION[0] = "/update"
BUILT\_MODULE\_NAME[1] = "bar"
BUILT\_MODULE\_LOCATION[1]  = "bar_build"
DEST\_MODULE\_LOCATION[1] = "/update"
（省略）
\end{commandline}

これにより、ドライバ foo のビルドは foo\_build ディレクトリで行われ、
update ディレクトリ以下にインストール、ドライバ bar のビルドは
bar\_build ディレクトリで行われ、update ディレクトリ以下にインストール
されます。

\subsubsection{DKMS で提供されるコマンド}
DKMS は dkms コマンドで操作します。
以下に利用頻度が高いコマンドを紹介します。

\begin{enumerate}
\item dkms status\\
DKMS で提供されている モジュールのステータスを表示します。
\begin{commandline}
$ dkms status
v4l2loopback, 0.5.0, 3.1.0-1-amd64, x86_64: installed
v4l2loopback, 0.5.0, 3.2.0-1-amd64, x86_64: installed
virtualbox, 4.1.8, 3.1.0-1-amd64, x86_64: installed
virtualbox, 4.1.8, 3.2.0-1-amd64, x86_64: installed
\end{commandline}
%$

\item dkms add \\
モジュールのソースコードを管理対象に追加します。
実行する時に -m オプションで追加するドライバパッケージ名を、
-v オプションでバージョンを指定します。

\begin{commandline}
$ sudo dkms add -m hello -v 0.0.1

Creating symlink /var/lib/dkms/hello/0.0.1/source ->
                 /usr/src/hello-0.0.1

DKMS: add completed.
$ dkms status
hello, 0.0.1: added
\end{commandline}
%$

実行すると/var/lib/dkms 以下に シンボリックリンクを張り、DKMS が管理する
ドライバデータベースに登録されます。

\item dksm build \\
管理対象になっているモジュールをビルドします。
実行する時に -m オプションで追加するドライバパッケージ名を、
-v オプションでバージョンを指定します。

ドライバは \url{/var/lib/dkms/ドライバ名/ドライババージョン/BUILT\_MODULE\_LOCATION} 以下
でビルドされます。                   
作成されたモジュールとビルドログは
\url{/var/lib/dkms/ドライバ名/ドライババージョン/カーネルバージョン/アーキテクチャ}
以下に置かれます。

\begin{commandline}
$ sudo dkms build -m hello -v 0.0.1

Kernel preparation unnecessary for this kernel.  Skipping...

Building module:
cleaning build area....
make KERNELRELEASE=3.0.0-1-amd64 -C /lib/modules/3.0.0-1-amd64/build M=/var/lib/dkms/hello/0.0.1/build....
cleaning build area....
\end{commandline}
% $

\item dksm install\\
dkms build コマンドによってビルドされたモジュールをdkms.conf の 
DEST\_MODULE\_LOCATION で指定されている場所にインストールします。
例えば Linux カーネル 3.2.0-1-amd64 を使っていて、
\begin{commandline}
DEST_MODULE_LOCATION[0]="/updates"
\end{commandline}

と指定されている場合には \url{/lib/modules/3.2.0-1-amd64/updates/dkms/}
以下にインストールされます。

\begin{commandline}
$ sudo dkms install -m hello -v 0.0.1

hello:
Running module version sanity check.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/3.0.0-1-amd64/updates/dkms/

depmod..........

DKMS: install completed.
$ dkms status
hello, 0.0.1: installed
$ sudo modprobe -l | grep hello.ko
updates/dkms/hello.ko
\end{commandline}
%$

\item dkms uninstall\\
モジュールをアンインストールします。
実行する時に -m オプションで追加するドライバパッケージ名を、
-v オプションでバージョンを指定します。
また全てのカーネルから削除する場合には --all オプション、
特定のカーネルモジュールのみを削除する場合には -k オプションでカーネル
バージョンを指定します。

\begin{commandline}
$ sudo dkms uninstall -m hello -v 0.0.1 -k 3.0.0-1-amd64

-------- Uninstall Beginning --------
Module:  hello
Version: 0.0.1
Kernel:  3.0.0-1-amd64 (x86_64)
-------------------------------------
（中略）

depmod....

DKMS: uninstall completed.
\end{commandline}
%$

% 中略部分
\if 0

Status: Before uninstall, this module version was ACTIVE on this kernel.

hello.ko:
 - Uninstallation
   - Deleting from: /lib/modules/3.0.0-1-amd64/updates/dkms/
 - Original module
   - No original module was found for this module on this kernel.
   - Use the dkms install command to reinstall any previous module version.

\fi

\footnote{この資料を作成している時点では、「dkms uninstall」は動作しません。
一部のチェックが未実装なため、uninstall の処理まで行われないためです。
\url{http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=659672}}

\item dkms remove\\
DKMS の管理対象から外します。uninstall と同様のオプションが必要です。
ドライバモジュールがアンインストールされていない場合、アンインストールを実行してから、
管理対象から外れるようになっています。

\begin{commandline}
$ dkms status
hello, 0.0.1, 3.0.0-1-amd64, x86_64: installed
virtualbox, 4.1.6, 3.0.0-1-amd64, x86_64: installed
$ sudo dkms remove  -m hello -v 0.0.1 --all

-------- Uninstall Beginning --------
Module:  hello
Version: 0.0.1
Kernel:  3.0.0-1-amd64 (x86_64)
-------------------------------------
（中略）

depmod....

DKMS: uninstall completed.

------------------------------
Deleting module version: 0.0.1
completely from the DKMS tree.
------------------------------
Done.
$ dkms status
\end{commandline}
%$

% 中略部分
\if 0

Status: Before uninstall, this module version was ACTIVE on this kernel.

hello.ko:
 - Uninstallation
   - Deleting from: /lib/modules/3.0.0-1-amd64/updates/dkms/
 - Original module
   - No original module was found for this module on this kernel.
   - Use the dkms install command to reinstall any previous module version.


\fi

\end{enumerate}

その他、rpm パッケージを作成する mkrpm オプションや Debianパッケージ
を作成する mkdeb オプションなどが用意されています。

\subsection{DKMS 対応Debian パッケージの作り方}

上記での説明のように、DKMS 対応モジュールのソースを規定のディレクトリに
展開しておくと DKMS は処理を行います。Debian の場合もパッケージ化するときは
インストールした時に規定のディレクトリに展開するようにしておきます。
パッケージ名などに関してはルールが決まっており、 DKMS 対応パッケージは 
-dkms というサフィックスがついています。
これはパッケージ名がわかりやすいという理由と、DKMS 用の debhelper 
コマンド、dh\_dkms コマンドが -dkms サフィックスのついたパッケージに
対して処理を行うためです。
debian/パッケージ名.dkms または debian/dkms を dkms.conf に変換して、
適切な dkms 用ディレクトリにコピーし、postinst と prerm に DKMS 用の
処理を追加します。
dh\_dkms コマンドは dkms パッケージで提供されています。
debhelper 7 以降で利用する場合には、アドオンとして読み込ませる必要
があります。 

debian/hello-dkms.dkms:
\begin{commandline}
PACKAGE_NAME="hello"
PACKAGE_VERSION="#MODULE_VERSION#"
BUILT_MODULE_NAME[0]="$PACKAGE_NAME"
BUILT_MODULE_LOCATION="src"
DEST_MODULE_LOCATION[0]="/updates"
AUTOINSTALL="yes"
\end{commandline}
%$

DKMS 用 debian/rules:
\begin{commandline}
#!/usr/bin/make -f

VERSION := $(shell dpkg-parsechangelog | sed -nr '/^Version:/s/Version: (.*:)?(.*)-(.*)/\2/p')

%:
    dh $@ --with dkms
override_dh_install:
    dh_install src/* usr/src/hello-$(VERSION)/src/
    dh_install Makefile usr/src/hello-$(VERSION)/
override_dh_dkms:
    dh_dkms -V $(VERSION)

override_dh_auto_configure override_dh_auto_build override_dh_auto_test override_dh_auto_install override_dh_auto_clean:
\end{commandline}
%$

debian/rules ファイル内で override\_dh\_auto\_configure や 
override\_dh\_auto\_build を呼び出している理由は Makefile がある場合、
make が実行されてしまうのでこれを抑制するためです。

\subsubsection{Debian でのドライバモジュールビルドのタイミング}

Debian では DKMS ドライバパッケージがインストールされた後と、
カーネルヘッダ または カーネルイメージパッケージがインストール
（更新）された後、 dkms が起動してドライバモジュールのコンパイルが行われるよ
うになっています。これらは以下のファイルで処理されます。

\begin{commandline}
/etc/kernel/postinst.d/dkms
/etc/kernel/header_postinst.d/dkms
\end{commandline}

\subsubsection{Debian の DKMS 対応状況}

主要なドライバの殆どは DKMS と module-assistant（m-a）の両方
に対応しています。開発があまり活発ではないドライバは m-a のみ
をサポートした状態が多いようです。
新しくパッケージ化されたドライバはほとんどが両方に対応しています。
DKMS のほうがメリットが多いため、m-a から DKMS に切り替えているユーザ
も多いようです。

\subsection{module-assistant との違い}
Debian には他のドライバパッケージ管理機構に 
module-assistant（m-a）があります。
DKMS と m-a の違いには以下のようになっています。
\begin{itemize}
\item m-a は自動ビルド機構がない。\\
カーネルが更新されると、手動で m-a を実行する必要があります。
\item DKMS はドライバ用のバイナリパッケージを作らない。\\
m-a は カーネル毎バイナリパッケージを作り、それをインストールします。
\item m-a は起動しているカーネルのみのドライバをビルドするが、DKMS は
インストールされているカーネルをビルドできる。
\end{itemize}

\subsection{まとめ}

今回は DKMS の基本的な仕組みと、Debian での DKMS 対応パッケージ作成方法
について説明しました。今までは m-a が主流だったのですが DKMS もサポート
しているドライバパッケージも増え始め、徐々に DKMS に移行しつつあるように
感じました。Debianパッケージ用ツールが用意されているため、
対応パッケージ作成も難しくないと思います。
今後ドライバパッケージを作成する場合には、DKMS をサポートしてみては
いかがでしょうか。

\clearpage

%-------------------------------------------------------------------------------                                                                                                                             
\dancersection{さきが(ry NM 塾}{倉敷悟}
%-------------------------------------------------------------------------------                                                                                                                             
\index{NM}
\index{New Member}

\subsection{NM とは何か}

Debian における NM (New Member) とは、新しく Debian Project の参加メンバーになった人、あるいは Debian Project 
に参加するための手続き、といった意味で使われます。後者の場合は、意味を明確にするために、NM プロセスといったりもします。
少し前までは、New Maintainer の略だったのですが、(パッケージ) メンテナ以外にも門戸を開こう、という方向性に変更されつつあります 
(とはいえ、現時点では NM プロセスはまだパッケージメンテナを念頭においた形のままです)。

\subsection{NMプロセスの紹介}

では、実際のNMプロセスを実例をもとにご紹介します。本当はもう少しプロセスを進めておくつもりだったのですが、あまりスムーズにいってないので途中までになっています。

NM 志願者向けのチェックリスト (http://www.debian.org/devel/join/nm-checklist) がありますので、まずはこれを見てみましょう。

\subsubsection{必要な条件}

まず、Debian Developer（以下DD） 2 名以上とキーサインしていること、さらに NM への応募を推薦してくれる DD が 1 名以上いること、
これは具体的かつ最低限の条件になります。
加えて、すでに Debian に関わるある程度の活動をしてきていることも必要とされますが、これについては明確な線引きがあるわけではありませんし、今後変化してくる部分なので水物といっていいでしょう。

私の例だと、まともに Debian での活動をはじめたのは 2007 年くらいだったと思うので、おおよそ 4 年間、下積みとしてパッケージメンテ、翻訳、ローカルコミュニティ活動をしてきていますが、これはちょっと長かった (NM 応募が遅かった) かなぁ、と思っています。

最近では、DM のステップをふんでいることが推奨されていることもあるので、少なくとも6ヶ月以上特定のパッケージをメンテしていて、スポンサーと良好な関係を築けていれば、そのまま NM に進むことも可能でしょう。

\subsubsection{実例}

\begin{itemize}
\item 2011/11 (事前ネゴ)
\item 2011/12/04 apply
\item 2011/12/04 advocate checked by yyabuki
\item 2011/12/10 activity poll sent
\item 2011/12/11 pass frontdesk precheck
\item 2011/12/13 AM assigned to gwolf
\item 2011/12/16 AM assigned to laney
\item 2011/12/17 ID checked
\item 2011/12/25 (Philosophy and Procedure やりとり中)
\end{itemize}

この後に続く予定は、次のようになっています。

\begin{itemize}
\item Tasks and Skills
\item AM recommends to DAM
\item DAM Approval
\end{itemize}

\subsubsection{NMテンプレート}

NM 担当チームでは、主に AM 担当者向けの資料として、作業ガイドのリポジトリが用意しています(http://anonscm.debian.org/viewvc/nm/trunk/nm-templates/)。実は、ここを見れば、だいたい何を聞かれるのかはわかってしまいますので、予習のための参考書としては最良のものだと思われます。ただし、AM によっては NM テンプレートを使わない、という人もいますので、盲信はしすぎないようにしましょう。

\subsubsection{NM と 勉強会と Debian JP}

Debian 勉強会では、Debian Developer を育成する、を目的としてあげています。ですので、その運営主体である Debian JP としても、支援活動はいろいろとおこなわれています。具体的には、GPG キーサインの推進や、スポンサー探しのサポート、パッケージングスキルの教育、などです。是非有効に活用してください。

\subsubsection{NM と Debian Maintainer}

勉強会でも何度かとりあげていますが、いきなり NM は敷居が高い、という人のために、DM というステップが用意されています。これは、いわば「限定つきの Debian Developer」であり、スポンサーについてもらうことで自分のパッケージを Debian に含めることができる人達のことです。

事前の実績としてわかりやすいことや、内容がサブセットになっていることもあり、NM プロセスにおいても、事前に DM として活動しておくことが強く推奨されています。

\subsection{最後に}

\subsubsection{なぜ NM に？}

NM になることの意義を考えてみましょう。直接的には、次のようなメリットがあります。

\begin{itemize}
\item パッケージを自由にアップロードできる
\item LWN.net の購読権 (sponsored by HP)
\item Project Leader や GR への投票
\item @debian.org メールアカウント
\end{itemize}

あるいは若い人であれば、比較的名前の知られたプロジェクトへの参加自体や、プロジェクトに自分色を持ち込める、といった満足もあるかもしれません。
ただ、NM プロセスやその後の活動は、それなりに手間も気力も必要になります。これじゃ引きが足りない、という人も多いでしょう。

Debian 勉強会としては、前述したとおり、NM に応募しようと思える人材を育成したい、という思いがあるのですが、やはり動機の部分については、皆さんそれぞれの答えを見出していただくしかありません。

スライドの方では、一例として、特に技術的に秀でたものをもっているわけでもなく、業界的には定年に達してしまったおっさんが、一体何を考えて NM に挑戦してみているのか、簡単に紹介してみます。参考になれば。

\clearpage
%-------------------------------------------------------------------------------
\dancersection{t-code のバグレポートをしてみた}{西田孝三}
%-------------------------------------------------------------------------------
\index{t-code}
\index{ばぐれぽーと@バグレポート}

\subsection{はじめに}

ここでは「Debianパッケージのバグを発見した場合にどうすればいいのか」を伝えることを目的とし、
実際のバグ例を挙げながらバグレポートの手順を説明します。
バグレポートするパッケージはEmacsで日本語入力するための拡張Elispであるt-codeパッケージです。
手順の大きな流れは下記の4段階に分けられます。

\begin{enumerate}
  \item バグトラッカーでの報告
  \item 自分で修正パッチを作る(可能であれば)
  \item 自分でDebianパッケージを作る(可能であれば)
  \item DebianDeveloper(DD)に3のパッケージを取り込んでもらう(知り合いのDDがいれば)
\end{enumerate}

実際にはまともにできたのは1だけでした。申し訳ありませんがお付き合いください。
それでは実際のt-codeパッケージのバグを見ながら順を追ってバグレポート、修正を行なっていきましょう。

\subsection{バグトラッカーでの報告}

t-codeのDebianパッケージは2003年のバージョン2.3.1以降更新がなくEmacs23や24で部首合成変換ができないバグがあります。
まずこのバグを報告する前にBug Trackerにすでに報告されていないかどうかウェブブラウザで簡単に確認しましょう。
DebianのBug TrackerのURLは http://www.debian.org/Bugs/ です。
バグの選択というselect boxとinput boxがありますのでそれぞれ「パッケージ名が」、「t-code」と入力しバグ報告情報を確認します。
2011年12月24日時点ではautomakeのバージョンに関するバグしか報告されていなかったので、バグ報告をする必要があることがわかりました。
reportbugというパッケージを用いると便利にバグ報告ができるため、もしこのパッケージがインストールされていなければインストールしてください。

\begin{commandline}
 $ sudo aptitude install reportbug
\end{commandline}

インストールができていればreportbugコマンドを入力します。

\begin{commandline}
kozo2@debian:~$ reportbug
Welcome to reportbug! Since it looks like this is the first time you have used reportbug, we are configuring its
 behavior. These settings will be saved to the file ``/home/kozo2/.reportbugrc'', which you will be
free to edit further.
Please choose the default operating mode for reportbug.

1 novice    Offer simple prompts, bypassing technical questions.

2 standard  Offer more extensive prompts, including asking about things that a moderately sophisticated user would
 be expected to know about Debian.

3 advanced  Like standard, but assumes you know a bit more about Debian, including ``incoming''.

4 expert    Bypass most handholding measures and preliminary triage routines. This mode should not be used by people
 unfamiliar with Debian's policies and operating procedures.

Select mode: [novice]
\end{commandline}

最初なので novice でいいと思います。

\begin{commandline}
Will reportbug often have direct Internet access? (You should answer yes to this question unless you know what you
 are doing and plan to check whether duplicate reports have been filed via some other channel.)
[Y|n|q|?]?
\end{commandline}

よくわからないので説明に従いYにします。

\begin{commandline}
What real name should be used for sending bug reports?
[kozo2]> Kozo Nishida
\end{commandline}

名前を入力します。

\begin{commandline}
Which of your email addresses should be used when sending bug reports? (Note that this address will be visible in
 the bug tracking system, so you may want to use a webmail address or another address with
spam filtering capabilities.)
[kozo2@debian]> knishida@riken.jp
\end{commandline}

メールアドレスを書きます。

\begin{commandline}
Do you have a ``mail transport agent'' (MTA) like Exim, Postfix or SSMTP configured on this computer to send mail
 to the Internet? [Y|n|q|?]? n
\end{commandline}

メールを送るプログラムの設定をしていなければnにします。

\begin{commandline}
Please enter the name of your SMTP host. Usually it's called something like ``mail.example.org'' or
 ``smtp.example.org''. If you need to use a different port than default, use the <host>:<port> alternative f
Just press ENTER if you don't have one or don't know, and so a Debian SMTP host will be used.
>
\end{commandline}

これもSMTP設定を知らないのでそのままENTERします。

\begin{commandline}
Please enter the name of your proxy server. It should only use this parameter if you are behind a firewall.
 The PROXY argument should be formatted as a valid HTTP URL, including (if necessary) a port num
example, http://192.168.1.1:3128/. Just press ENTER if you don't have one or don't know.
>
\end{commandline}

プロキシサーバも知らないのでそのままENTERします。

\begin{commandline}
Dear Maintainer,
*** Please consider answering these questions, where appropriate ***

   * What led up to the situation?
   * What exactly did you do (or not do) that was effective (or
     ineffective)?
   * What was the outcome of this action?
   * What outcome did you expect instead?

*** End of the template - remove these lines ***


-- System Information:
Debian Release: wheezy/sid
  APT prefers unstable
  APT policy: (500, 'unstable')
Architecture: amd64 (x86_64)

Kernel: Linux 3.1.0-1-amd64 (SMP w/2 CPU cores)
Locale: LANG=ja_JP.UTF-8, LC_CTYPE=ja_JP.UTF-8 (charmap=UTF-8)
Shell: /bin/sh linked to /bin/dash

Versions of packages t-code depends on:
ii  emacs-snapshot-nox [emacs-snapshot]  1:20111219-1

t-code recommends no packages.

t-code suggests no packages.

-- no debconf information
\end{commandline}

こういうひな形が表示されますのでこれを編集します。
以下が編集後のレポートです。

\begin{commandline}
Subject: t-code version 2.3.1 fails bushu-convert
Package: t-code
Version: 2:2.3.1-3
Severity: normal

Dear Maintainer,
*** Please consider answering these questions, where appropriate ***

   * T-code pre bushu-convert doesn't work
   * pre bushu-convert error message is tcode-self-insert-command: Wrong type argument: characterp, nil
   * T-code post bushu-convert doesn't work(There is no error message).

-- System Information:
Debian Release: wheezy/sid
  APT prefers unstable
  APT policy: (500, 'unstable')
Architecture: amd64 (x86_64)

Kernel: Linux 3.1.0-1-amd64 (SMP w/2 CPU cores)
Locale: LANG=ja_JP.UTF-8, LC_CTYPE=ja_JP.UTF-8 (charmap=UTF-8)
Shell: /bin/sh linked to /bin/dash

Versions of packages t-code depends on:
ii  emacs-snapshot-nox [emacs-snapshot]  1:20111219-1

t-code recommends no packages.

t-code suggests no packages.

-- no debconf information
\end{commandline}

ま、こんなとこでしょう。
編集を終えると下記の確認をしてきます。

\begin{commandline}
Report will be sent to ``Debian Bug Tracking System'' <submit@bugs.debian.org>''--configure'' option.
Submit this report on t-code (e to edit) [Y|n|a|c|e|i|l|m|p|q|d|t|s|?]? Y
\end{commandline}

これでよいのでYを入力します。もう一度編集したければeを入力します。

\begin{commandline}
Connecting to reportbug.debian.org via SMTP...

Bug report submitted to: ``Debian Bug Tracking System'' <submit@bugs.debian.org>
Copies will be sent after processing to:
  knishida@riken.jp

If you want to provide additional information, please wait to receive the bug tracking number via email;
 you may then send any extra information to n@bugs.debian.org (e.g. 999999@bugs.debian.org), where n is the
bug number. Normally you will receive an acknowledgement via email including the bug report number within
 an hour; if you haven't received a confirmation, then the bug reporting process failed at some point
(reportbug or MTA failure, BTS maintenance, etc.).
\end{commandline}

これでバグレポートは終わりです。
入力した自分のメールアドレスにバグレポートしたことを確認するメールが届いていることを確認してください。
もしメールが届いていたらバグレポートの番号を確認して
http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=653167
のようにbug=の後にバグIDを入力してウェブページでも内容を確認してみてください。

\subsection{自分で修正パッチを作る}

もし可能であればDebianのルールに従い修正パッチを作ってみましょう。
t-codeは安宅正之さんが中心となりGoogle codeで開発を引き継がれており(http://code.google.com/p/tcode/)、このリポジトリのtrunkのt-codeはEmacs23、24で使えることを確認しています。
また青田直大さんが個人的に修正をされたgithubのリポジトリ(https://github.com/naota/tc)もEmacs23,24で使えることを確認しています。

どちらのリポジトリのコードをどのようにパッケージ化していけばよいか(これまでのコードとの差分情報の記述など)わからなかったためこの部分については次回への宿題ということにさせてください。
申し訳ありません。
と、いうわけで次回は「バグ修正リポジトリコードの取り込みとdpatchの使い方」で発表させてください。

\subsection{自分でDebianパッケージを作る}

本来ならこれまでのパッケージからの変更をDebianのルールに従って記述したファイルを作成する必要があるかと思いますが、ここではその手続をすっとばして
前述のリポジトリのソースコードの内、安宅さんのリポジトリのソースコードを用いてDebianパッケージを作ることを試みます。

まずt-codeパッケージのソースコードを取得します。

\begin{commandline}
$ apt-get source t-code
$ svn checkout http://tcode.googlecode.com/svn/trunk/ tcode-read-only
$ ls
t-code-2.3.1  t-code_2.3.1-3.diff.gz  t-code_2.3.1-3.dsc  t-code_2.3.1.orig.tar.gz
\end{commandline}
%$

次にソース中のdebianディレクトリを安宅さんのリポジトリのソースコード中にコピーします。

\begin{commandline}
$ cp -r t-code-2.3.1/debian tcode-read-only/tc/
\end{commandline}
%$

それではこれでDebian packageが作れるか試してみましょう。
Debian packageはdebuildコマンドで作成できます。
debuildコマンドはdevscriptsパッケージをインストールすると使えるようになります。

\begin{commandline}
$ sudo aptitude install devscripts
$ cd tcode-read-only/tc
$ sudo debuild -us -uc
This package has a Debian revision number but there does not seem to be
an appropriate original tar file or .orig directory in the parent directory;
(expected one of t-code_2.3.1.orig.tar.gz, t-code_2.3.1.orig.tar.bz2,
t-code_2.3.1.orig.tar.lzma,  t-code_2.3.1.orig.tar.xz or tc.orig)
continue anyway? (y/n) y
\end{commandline}
%$

親ディレクトリにソースのtar.gzがないと言われますが無視してbuildを試みます。

\begin{commandline}
make[2]: `install-exec-am' に対して行うべき事はありません.
/bin/sh ../mkinstalldirs /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc
 /usr/bin/install -c -m 644 ./pd_kihon.yom /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/pd_kihon.yom
 /usr/bin/install -c -m 644 ./greece.maz /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/greece.maz
 /usr/bin/install -c -m 644 ./jukujiku.maz /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/jukujiku.maz
 /usr/bin/install -c -m 644 ./t225.dat /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/t225.dat
 /usr/bin/install -c -m 644 ./t300.dat /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/t300.dat
 /usr/bin/install -c -m 644 ./t400.dat /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/t400.dat
 /usr/bin/install -c -m 644 ./t450.dat /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/t450.dat
 /usr/bin/install -c -m 644 ./t575.dat /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/t575.dat
 /usr/bin/install -c -m 644 ./t675.dat /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/t675.dat
 /usr/bin/install -c -m 644 ./t900.dat /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/t900.dat
 /usr/bin/install -c -m 644 ./t1200.dat /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/t1200.dat
 /usr/bin/install -c -m 644 ./t1353.dat /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/t1353.dat
 /usr/bin/install -c -m 644 ./itaiji.maz /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/itaiji.maz
 /usr/bin/install -c -m 644 ./mazegaki.dic /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/mazegaki.dic
 /usr/bin/install -c -m 644 ./mkcertain.pl /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/mkcertain.pl
make[2]: ディレクトリ `/home/kozo2/tcode-read-only/tc/mazegaki' から出ます
make[1]: ディレクトリ `/home/kozo2/tcode-read-only/tc/mazegaki' から出ます
/usr/bin/make -C skkinput3  DESTDIR=/home/kozo2/tcode-read-only/tc/debian/t-code install
make[1]: ディレクトリ `/home/kozo2/tcode-read-only/tc/skkinput3' に入ります
make[2]: ディレクトリ `/home/kozo2/tcode-read-only/tc/skkinput3' に入ります
/bin/sh ../mkinstalldirs /home/kozo2/tcode-read-only/tc/debian/t-code/usr/bin
mkdir /home/kozo2/tcode-read-only/tc/debian/t-code/usr/bin
 /usr/bin/install -c tcinput /home/kozo2/tcode-read-only/tc/debian/t-code/usr/bin/tcinput
/bin/sh ../mkinstalldirs /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc
 /usr/bin/install -c -m 644 ./init.el /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/init.el
 /usr/bin/install -c -m 644 ./skk-startup.el /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/skk-startup.el
 /usr/bin/install -c -m 644 ./tc-skki.el /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/tc-skki.el
 /usr/bin/install -c -m 644 ./load-path.el /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/tc/load-path.el
make[2]: ディレクトリ `/home/kozo2/tcode-read-only/tc/skkinput3' から出ます
make[1]: ディレクトリ `/home/kozo2/tcode-read-only/tc/skkinput3' から出ます
cd /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/t-code && \
                chmod +x bushu2canna where mkcertain.pl
/bin/sh: 1: cd: can't cd to /home/kozo2/tcode-read-only/tc/debian/t-code/usr/share/t-code
make: *** [install] エラー 2
dpkg-buildpackage: error: fakeroot debian/rules binary gave error exit status 2
debuild: fatal error at line 1348:
dpkg-buildpackage -rfakeroot -D -us -uc failed
\end{commandline}
%$

失敗でした!
今回はここまででお許しください。パッケージ作成成功は次回の発表までの宿題ということで!

\subsection{DDにパッケージをDebianのリポジトリに取り込んでもらう}

Debianパッケージができたら、関西のDDにビールでも飲みながら話しかけてみましょう。

\subsection{おわりに}

おもいっきり尻切れトンボで申し訳ありません!
ただ、最初のバグレポートをするだけでもそれはそれで結構Debianに貢献していることになると思います。
何事も最初のとっかかりさえ掴めれば後は楽かと思いますので皆さんもどんどんバグ報告をして残りのパッチ作成や、パッケージ作成も一緒にやってみませんか。
それではまた次回!(土下座)

%-------------------------------------------------------------------------------
\dancersection{emacs24で問題なく使える t-code.deb を作った話}{西田 孝三}
%------------------------------------------------------------------------------- 
\index{t-code}
\index{emacs}

第54回関西Debian勉強会では「t-codeのバグレポートをしてみた」という題で発表しました。
前回の発表ではDebianのバグトラッキングシステムを使ってt-codeパッケージのバグレポートから
Debianパッケージの作成を試み、失敗するところで止まっていました。
今回はまず問題なく動作するパッケージを作成すると共に、とりあえずパッケージを作成する
(いわゆるオレオレパッケージ)にはどのようなことを行えばよいかを下記の4点に分けてお伝えします。

\begin{enumerate}
\item (バグを含む)現在のDebianパッケージのソースコードの取得と、ビルド方法の確認
\item バグ修正を含むソースコードへの置き換えとビルド、オレオレパッケージの作成
\item オレオレパッケージの動作確認
\item (修正が必要な場合)Debianディレクトリ下のファイルの変更
\end{enumerate}

\subsection{現在のDebianパッケージのソースコードの取得と、ビルド方法の確認}
まず既存のDebianパッケージのソースコードを取得し、ビルドすることでパッケージ作成方法の確認をします。
パッケージのソースコードの取得を行うにはapt-getコマンドにsourceオプションを付けパッケージを指定します。

\begin{commandline}
kozo2@debian:~/sandbox$ apt-get source t-code
kozo2@debian:~/sandbox$ ls
t-code-2.3.1            t-code_2.3.1-3.dsc
t-code_2.3.1-3.diff.gz  t-code_2.3.1.orig.tar.gz
\end{commandline}

これでソースが取得できます。今回はとにかくパッケージを作ることが目的ですので*.dsc, *.diff.gz, *.orig.tar.gzの意味は説明せず、t-code-2.3.1へ移動し、まずこのソースを用いてビルドを行いパッケージ(.debファイル)を作成してみます。これにはdebuildコマンドを用います。

\begin{commandline}
kozo2@debian:~/sandbox$ cd t-code-2.3.1/
kozo2@debian:~/sandbox/t-code-2.3.1$ ls
acinclude.m4  ChangeLog.old  COPYING  install-sh   mazegaki       skkinput3
aclocal.m4    config.guess   debian   kinput2      missing
AUTHORS       config.sub     doc      lisp         mkinstalldirs
bushu-util    configure      etc      Makefile.am  NEWS
ChangeLog     configure.in   INSTALL  Makefile.in  README
kozo2@debian:~/sandbox/t-code-2.3.1$ debuild -us -uc
\end{commandline}

debuildコマンドのオプション -us -ucは署名はせずに単にpackageにbuildする時に用います。
これで一つ上のdirectoryに.debファイルができます。

\begin{commandline}
kozo2@debian:~/sandbox/t-code-2.3.1$ ls ..
t-code-2.3.1            t-code_2.3.1-3_amd64.build    t-code_2.3.1-3.diff.gz  t-code_2.3.1.orig.tar.gz
t-code_2.3.1-3_all.deb  t-code_2.3.1-3_amd64.changes  t-code_2.3.1-3.dsc
\end{commandline}

\subsection{バグ修正を含むソースコードへの置き換えとビルド、オレオレパッケージの作成}

次にバグのあるソースコードを新しいソースコードに置き換え、ビルドができるかどうか試してみます。新しいソースコードはhttp://code.google.com/p/tcode/から取得します。

\begin{commandline}
kozo2@debian:~/sandbox/t-code-2.3.1$ cd ..
kozo2@debian:~/sandbox$ svn co http://tcode.googlecode.com/svn/trunk/ tcode-read-only
\end{commandline}

置き換えが必要なファイルを新しいソースコードをコピーすることで上書きします。

\begin{commandline}
kozo2@debian:~/sandbox$ cp tcode-read-only/tc/bushu-util/* t-code-2.3.1/bushu-util/
kozo2@debian:~/sandbox$ cp tcode-read-only/tc/etc/* t-code-2.3.1/etc/
kozo2@debian:~/sandbox$ cp tcode-read-only/tc/lisp/* t-code-2.3.1/lisp/
kozo2@debian:~/sandbox$ cp tcode-read-only/tc/mazegaki/* t-code-2.3.1/mazegaki/
\end{commandline}

これでビルドが通るか試します。(通ります)

\begin{commandline}
kozo2@debian:~/sandbox$ cd t-code-2.3.1
kozo2@debian:~/sandbox$ debuild -us -uc
\end{commandline}

とりあえず、置き換えたソースコードでパッケージができました。次はこれをインストールし動作確認してみます。

\subsection{オレオレパッケージの動作確認}
先程作成した用いるソースコードに変更を加えたDebianパッケージをインストールし、動作に問題がないか確認します。インストールするにはdpkgコマンドに-iオプションをつけてインストールしたい.debファイルを指定します。

\begin{commandline}
kozo2@debian:~/sandbox$ sudo dpkg -i t-code_2.3.1-3_all.deb 
Selecting previously unselected package t-code.
(Reading database ... 97587 files and directories currently installed.)
Unpacking t-code (from t-code_2.3.1-3_all.deb) ...
Setting up t-code (2:2.3.1-3) ...
install/t-code: Handling install for emacsen flavor emacs23
Processing triggers for install-info ...
kozo2@debian:~/sandbox$ 
\end{commandline}

インストールは問題ないようです。それではt-codeが問題ないかemacsを起動し試してみます。試しにt-code練習プログラムeelllの起動を試みるとemacsが下記のメッセージを出し、何か問題があることがわかります。

\begin{commandline}
Debugger entered--Lisp error: (error ``ファイル /usr/share/tc/EELLLTXT が存在しません。'')
  signal(error (``ファイル /usr/share/tc/EELLLTXT が存在しません。''))
  error(``ファイル %s が存在しません。'' ``/usr/share/tc/EELLLTXT'')
  tcode-set-work-buffer(`` *eelll: text*'' ``EELLLTXT'')
  eelll-completing-read()
  call-interactively(eelll t nil)
  execute-extended-command(nil)
  call-interactively(execute-extended-command nil nil)
\end{commandline}

\subsection{Debianディレクトリ下のファイルの変更}
先程の問題はt-codeが用いる交ぜ書き、部首合成変換用データがインストールされているディレクトリを指定するemacsの変数tcode-site-data-directoryの設定によるものです。このtcode-site-data-directoryを指定し直すにはパッケージ作成用directory下のdebian/emacsen-startupに下記の設定を追加しビルドし直します。

\begin{commandline}
;;; 50t-code.el --- Debian t-code startup file  -*-mode: emacs-lisp;-*-                                                            

;;; Code:                                                                                                                          

(let ((lispdir (concat ``/usr/share/'' (symbol-name flavor) ``/site-lisp/t-code'')))
  (when (and (featurep 'mule) (file-exists-p (concat lispdir ``/tc.elc'')))
    (if (fboundp 'debian-pkg-add-load-path-item)
        (debian-pkg-add-load-path-item lispdir)
      (setq load-path (cons lispdir load-path)))
    ;;                                                                                                                             
    (require 'tc-setup)
    (defconst tcode-site-data-directory ``/usr/share/t-code/'')
    ;;                                                                                                                             
    ))

;;; 50t-code.el ends here
\end{commandline}

\begin{commandline}
kozo2@debian:~/sandbox/t-code-2.3.1$ debuild -us -uc
kozo2@debian:~/sandbox/t-code-2.3.1$ sudo aptitude purge t-code
kozo2@debian:~/sandbox/t-code-2.3.1$ sudo dpkg -i ../t-code_2.3.1-3_all.deb 
\end{commandline}
%$

これでemacs23や24といった新しいemacsでt-codeの交ぜ書き、部首合成変換が問題なく使えるようになっていると思います。ちなみにこのemacsen-startupのelispの内容はDebianパッケージのインストールによって/etc/emacs/site-start.d/50t-code.elにコピーされます。

\subsection{おわりに}

いかがでしたでしょうか。今回はとりあえずDebianパッケージを作るという目的でソースコードは変更を上書きしただけですが、本来は差分の変更などを記録する必要があるためまだまだやらねばならないことはあります。upstreamのt-codeの継続開発を行なっている方、これまでのt-code Debianパッケージメンテナの方への連絡といったこともそうです。そういったことに関してはまた次回の関西Debian勉強会で発表させて頂ければと思っています。

\clearpage


%-------------------------------------------------------------------------------
\dancersection{月刊 t-code パッケージ修正}{西田 孝三}
%-------------------------------------------------------------------------------
\index{t-code}

第56回関西Debian勉強会では「emacs24で問題なく使えるt-code.debを作った話」という題で発表しました。前回の発表ではとりあえず問題なく動作するオレオレパッケージを作成するところで終わっていました。今回は最近のEmacsでも動作するようにパッケージに加えた変更の管理をしっかりしていこうと思います。

\subsection{前回のおさらいと今回の作業方針}
前回とりあえず動くパッケージを作るために行ったことは派生リポジトリ(\url{http://code.google.com/p/tcode})で変更が加えられたコードを既存のパッケージのソースに上書きコピーした上でbuildを行うというものでした。今後行うべきことのひとつとして、どのような変更を加えたかを管理していくことがあります。今後の変更を管理していく場合、下記のような方針が考えられます。

\begin{enumerate}
\item 派生リポジトリが今後のt-codeパッケージのupstreamだと言い張る。これまでのdebianディレクトリを派生リポジトリの方にコピーしてビルドが通るようにする。これは前回のオレオレパッケージ作成方法とは異なる。このままもしビルドが通ればpatchを用意する必要は無い。
\item 既存のt-codeパッケージのupstreamのコードに直接変更を加える(前回はコピー上書きした)ことはせず、パッチ管理ツール(dpatchやquilt)を用いて変更を管理する。
\end{enumerate}

1.には下記の理由があり、2.の方針をとることにしました。

\begin{itemize}
\item 既存のt-codeパッケージのdebianディレクトリをコピーしただけではdebuildが通らない。結局パッチ変更必要。
\item Subversionの変更履歴の記録が他のソフトウェアも含むものとなっている(Windows用のIMEである漢直Winのソースも共に管理している)
\end{itemize}

\subsection{quiltを用いたパッチ作成}
それでは前回行った変更に応じたパッチを作成してみましょう。
\begin{enumerate}
\item 既存Debianパッケージのソース取得と派生リポジトリのソースを取得
\item 派生リポジトリのソースで既存Debianパッケージのソースに変更を加え
\item debian/source/formatを追加しquiltを使うことを宣言し
\item dpkg-source --commitコマンドでパッチを作成しています
\end{enumerate}

\begin{commandline}
kozo2@debian:~$ mkdir debsrc
kozo2@debian:~$ cd debsrc; apt-get source t-code
kozo2@debian:~/debsrc$ cd; svn co http://tcode.googlecode.com/svn/trunk/tc
kozo2@debian:~$ cp tc/bushu-util/* debsrc/t-code-2.3.1/bushu-util/
kozo2@debian:~$ cp tc/etc/* debsrc/t-code-2.3.1/etc/
kozo2@debian:~$ cp tc/lisp/* debsrc/t-code-2.3.1/lisp/
kozo2@debian:~$ cp tc/mazegaki/* debsrc/t-code-2.3.1/mazegaki/
kozo2@debian:~$ cd debsrc/t-code-2.3.1
kozo2@debian:~/debsrc/t-code-2.3.1$ mkdir debian/source
kozo2@debian:~/debsrc/t-code-2.3.1$ echo '3.0 (quilt)' > debian/source/format
kozo2@debian:~/debsrc/t-code-2.3.1$ dpkg-source --commit
\end{commandline}

これでdebian/patches下にseriesというファイルと共にパッチファイルが作成されます。
パッチファイル名は先程のコマンド入力後に指定します。
ここではgooglecodeとしました。
seriesという名のファイルには複数のパッチファイルを用いる場合にそれらのファイル名を記すようです。

\begin{commandline}
kozo2@debian:~/debsrc/t-code-2.3.1$ ls debian/patches/
googlecode series
kozo2@debian:~/debsrc/t-code-2.3.1$ cat debian/patches/series
googlecode
\end{commandline}

\subsection{ビルド時にパッチを用いるための設定}

次に先程生成したdebian/patches以下のパッチファイルをバイナリパッケージをビルドする際にパッチを当てた状態になるようにdebian/rulesのmakeコマンドのshebangの下に下記の1行を加えます。

\begin{commandline}
kozo2@debian:~/debsrc/t-code-2.3.1$ head debian/rules
#!/usr/bin/make -f
include /usr/share/cdbs/1/rules/patchsys-quilt.mk

（省略）
\end{commandline}

このpatchsys-quilt.mkはcdbsというパッケージをinstallすると用いることができます。
CDBSはCommon Debian Build Systemの略で、debパッケージビルド用のdebian/rulesファイルを短く書けるようにrulesで行うことの汎用的な内容の集まりのようです。
今回はこの1行でうまくpatchが当たり、ビルドできるかどうかまで試行を行いました。

\begin{commandline}
kozo2@debian:~/debsrc/t-code-2.3.1$ debuild -us -uc
...
patching file lisp/eelll.el
Reversed (or previously applied) patch detected!  Skipping patch.
22 out of 22 hunks ignored -- saving rejects to file lisp/eelll.el.rej
patching file lisp/guess
Reversed (or previously applied) patch detected!  Skipping patch.
1 out of 1 hunk ignored -- saving rejects to file lisp/guess.rej
patching file lisp/Makefile.am
Reversed (or previously applied) patch detected!  Skipping patch.
1 out of 1 hunk ignored -- saving rejects to file lisp/Makefile.am.rej
patching file lisp/tc-bitmap.el
Reversed (or previously applied) patch detected!  Skipping patch.
2 out of 2 hunks ignored -- saving rejects to file lisp/tc-bitmap.el.rej
patching file lisp/tc-help.el
Reversed (or previously applied) patch detected!  Skipping patch.
10 out of 10 hunks ignored -- saving rejects to file lisp/tc-help.el.rej
patching file kinput2/Makefile.in
Reversed (or previously applied) patch detected!  Skipping patch.
3 out of 3 hunks ignored -- saving rejects to file kinput2/Makefile.in.rej
dpkg-source: error: LC_ALL=C patch -t -F 0 -N -p1 -u -V never -g0 -E -b -B .pc/midnight/ < t-code-2.3.1.orig.iRO91G/
debian/patches/midnight gave error exit status 1
dpkg-buildpackage: error: dpkg-source -b t-code-2.3.1 gave error exit status 2
\end{commandline}
%$

どうも何らかの問題がありpatchを当てることができずbuildに失敗しました。
今回はこの問題の解決まではできませんでした。

\subsection{おわりに}
パッチの適用ができなかった問題については勉強会会場で参加者の方々に伺い、解決の糸口を得たいと思っています。
他に懸念すべき事項としてライセンスがあるかと思いますが、ソースを通して見ても GPL v2以外のライセンスを用いている部分は無いように思ったので後は変更管理さえしっかりできれば正式にパッケージを採用して頂くための連絡へと進めるかと思っています。
次回の勉強会までに何とかそこまで持っていきたいと思います。

\clearpage

%-------------------------------------------------------------------------------
\dancersection{Konoha の Debianパッケージ化について}{酒井 忠紀}
%-------------------------------------------------------------------------------
\index{konoha}

\subsection{はじめに}
Konoha を Debian パッケージにして sid にコミットしたいと考えています。
今回は、以下について説明します。
\begin{itemize}
\item Konoha の概要
\item パッケージ化の内容確認
\item スポンサーになってくださる方の相談
\end{itemize}

\subsection{Konoha の概要}

\subsubsection{Konoha とは}
Konoha は、静的型付けによるオブジェクト指向スクリプト言語です。
横浜国立大学と JST/DEOS プロジェクトを中心にオープンソースで開発されて
います。
\footnote{私は Konoha プロジェクト内部の人間ではないので、以下の記述は正しくない場合があるかもしれません。}

\begin{quote}
開発サイト: \url{http://konoha.sourceforge.jp}
\end{quote}

Konoha は、静的言語の言語技術を基盤として、その上に動的な振る舞いをモデ
ル化しています。

以下に記述するように、スクリプトとして実行することや、コンパイラ言語の
ように実行前に型検査を行うことができます。

\begin{itemize}
\item スクリプトとして実行

関数を書き始めた時点では型やクラス階層は明確に決まっておらず、後から
頻繁に書き換えて、アイデアが固まってから型やクラス階層を決めたい場合
があります。

Konoha は静的言語でありながら可能な限り動的言語の振る舞いをエミュレー
ションし、関数が最初に呼び出される直前にパラメータから型を推論し、遅
延コンパイルします。

したがって、静的言語でありながらスクリプト言語のように型定義などを省
略して実行することができ、柔軟に開発を進めることができます。

\item 実行前の型検査

従来のスクリプト言語のように、動的な型検査をベースにしていると、型エ
ラーが含まれるスクリプトでも実行しないとエラーが発見できません。

そのため、全ての実行パスをひとつひとつテスト実行しながら、型エラーを
探し、修正する必要があります。

Konoha は静的な型付け言語であるため、プログラムを動作させることなく、
型検査を行うことができ、初歩的なエラーを検証することができます。

そのため、ケアレスミスのために、ファイル操作やデータベースが中途半端
な状態になり、プログラムが停止する弊害もありません。

\end{itemize}

Konoha を状況に合わせて使用方法を使い分けることで、ひとつの言語で静的言
語とスクリプト言語の特徴を生かした開発を行うことができます。

これは、次のような場合に有効に活用できると考えます。

アプリケーション開発において、以下のような手順で行われる場合があると思
います。

\begin{itemize}
\item STEP1: スクリプト言語を用いたプロトタイプの作成

型宣言やクラス設計は後回しにして、俊敏にアイデアをコード化する

\item STEP2: 静的言語で書き直し

品質保証、メンテナンス性の向上
\end{itemize}

しかし、一旦静的言語で書き直してしまうと、スクリプト言語のように柔軟に
書き直しができなくなります。

Konoha を使用すれば、上記の STEP1 と STEP2 を繰り替えして開発を進めるこ
とができます。

Konoha はスクリプト言語が提供する柔軟さと静的言語が持つ品質保証を両立さ
せることを目指しています。

\subsubsection{Konoha の使い方}
\begin{enumerate}
\item 対話モード
Konoha はターミナルから Konoha コマンドを実行すると、対話シェルとして起
動します。

\begin{commandline}
$ konoha
konoha 1.0(beta) svn (rev:933, Mar 23 2012 05:37:24)
options: iconv bmgc thcode sqlite3 syslog thread used\_memory:2191 kb
SECURITY ALERT: ** FOR EVALUATION/DEVELOPMENT USE ONLY **

>>>
\end{commandline}
%$ for emacs font-lock

"$>>>$" は、対話シェルのプロンプトです。この状態で実行したいプログラムを
入力すると、次の行に実行結果が表示されます。

\begin{commandline}
>>> print "hello, Konoha!"
((eval):1) hello, Konoha!
\end{commandline}

対話シェルを終了したい場合は、"bye" もしくは (Conrol-D) を入力します。

\begin{commandline}
>>> bye
\end{commandline}

\item スクリプトモード
Konoha はプログラムをファイルに保存すれば、スクリプトとして実行できます。

\begin{commandline}
$ cat <<EOF > fact.k
int factorial(int n) {
  if(n == 1) return 1;
  return n * factorial(n - 1);
}
print factorial(10);
EOF

$ konoha fact.k
(fact.k:5) 3628800
\end{commandline}

また、-iオプションを付けて Konoha を起動すれば、スクリプトファイルを読
み込んだ後、対話シェルから定義された関数を利用できます。

\clearpage

\item スクリプトの実行前の型検査
型検査のみ実行する場合は、-cオプションを付けて Konoha を起動します。

\begin{commandline}
$ cat <<EOF > type-error.k
s = 'ever';
i = 4;
str = i + s;    // 型推論
print str;      // "4ever" と評価される

int x = i + s;  // 型エラーとなる
print x;
EOF

$ konoha -c type-error.k
- (type-error.k:1) (info) suppose s has String type
- (type-error.k:2) (info) suppose i has int type
- (type-error.k:3) (info) suppose str has String type
- (type-error.k:6) (error) x has type int, not String
- (type-error.k:7) (error) undefined variable: x
\end{commandline}
%$

\end{enumerate}

\subsubsection{Konoha の特徴}
Konoha の主な特徴を以下に記述します。
\begin{enumerate}
\item 静的型付け

型の妥当性が保証されています。
スクリプト実行前に型検査のみ行うことができます。

\item 型宣言の省略(型推論や遅延コンパイル)

以下の場合、最初に呼び出されるのが dsucc(1.0) なので引数と戻り値は
float型に決定されます。

\begin{commandline}
function dsucc(n) {
  return n + 1;
}

dsucc(dsucc(1.0) + 1);
\end{commandline}

Konoha は一旦、型が決定したら型の一貫性を保証します。
つまり、次に dsucc("Konoha") のような異なる型の呼び出しは型エラーとな
ります。
これにより静的言語と同じように型エラーの管理ができます。
\\
\item 制御された動的型付け(dynamic type)

Konoha はスクリプト言語のようなダックタイピングをサポートしています。

以下のように、dynamic型を用いると、+演算子をサポートした任意の値を処
理できます。

\begin{commandline}
function dsucc(dynamic n) {
  return n + 1;
}
\end{commandline}

+演算子をサポートしていない値が与えられると、実行時のエラーとなります。
dynamic型を宣言する/しないでエラーの発生を制御できます。
\\
\item 軽量なオブジェクト

Konoha はコンストラクタがなくてもオブジェクトの生成ができます。
また、setter/getterは自動的に生成されます。
\\
\item 汎用性の高い集約データ構造(Array, Map, Tuple)

\begin{commandline}
  Array(リスト)   ["naruto", 17]
  Map(辞書)       {name:"naruto", age:17}
  Tuple          ("naruto", 17)
\end{commandline}

\item 実行時のコンパイルと評価(eval)

スクリプト言語として実行できます。

\clearpage

\item 実行時のクラスの改変

メソッドは、既にオブジェクトが生成してあっても、実行時にクラスに追加
することができます。
\\
\item 不完全コードの部分的な実行

従来のコンパイラ技術では、実行前に型検査を行うため、次のような型エラー
がある場合、コード生成が完了せず、プログラムも実行できませんでした。

\begin{commandline}
int serial(int n) {
  if(n == 0) {
    InputStream in = new ("serial.txt");
    n = in.readLine(); // 型エラーがここにある
    in.close();
  }
  return n + 1;
}
\end{commandline}

Konoha では、コンパイル時にエラーが発生しても、その部分を実行時例外に
書き換えることができます。
例えば、上記の型エラーは次のコードに変換されます。

\begin{commandline}
int serial(int n) {
  if(n == 0) { // 例外になる
    throw new Script!!("");
  }
  return n + 1;
}
\end{commandline}

エラー箇所を実行しなければ、そのまま実行が可能であり、もしも
serial(0) を実行しても、実行時例外として処理できます。

\begin{commandline}
>>> serial(1)
2

>>> serian(0)
Script!!:
\end{commandline}

\item 統一的なデータ変換操作
Konoha には、キャスト演算子を拡張したトランスキャットと呼ばれるデータ
変換を統一操作で行う演算子があります。

\begin{commandline}
>>> (to String)1
"1"

>>> (to int)1
1

>>> (to int)"naruto"
null
\end{commandline}

文字列への変換は、フォーマッタの機能を用いると、様々な書式の文字列に
変換できます。

\begin{commandline}
>>> "%x"(-1)
"ffffffffffffffff"

>>> "%bits"(-1)
"11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111"
\end{commandline}

他にも色々な変換機能があります。
\\
\item リンク演算子と外部リソースの扱い

Konoha には外部リソースの識別子を直接扱う URN があります。

\begin{quote}
    http://konohascript.org/\\
    file:/etc/passwd\\
    isbn:978-4-06-372988-7
\end{quote}

また、Konoha は URN から直接リソースを得ることができます。
"file:" や "http:" などの URN スキームは、ストリームに型強制されます。
URN を用いれば、次のように書けます。

\begin{commandline}
foreach(String line from file:/etc/hosts) {
  print line;
}
\end{commandline}

\item 非共有データモデル(アクター)による並行処理

申し訳ないですが、この部分は私の勉強不足で説明できません。


\item ライブラリ
Konoha では、パッケージ化された以下のようなライブラリを使用することがで
きます。
\begin{commandline}
konoha.cairo konoha.compiler konoha.compiler.cpp konoha.compiler.java konoha.compiler.js konoha.compiler.optllvm konoha.curl 
konoha.dffi konoha.dscript konoha.gsl konoha.gwt konoha.i konoha.io konoha.json konoha.kinect konoha.lang konoha.liboauth
konoha.llvm konoha.math konoha.memcached konoha.mpi konoha.nfc konoha.ntrace konoha.opengl konoha.posix konoha.proc
konoha.qt4 konoha.qt4.kinect konoha.qt4.opencv konoha.qt4.physics konoha.signal konoha.socket konoha.sql konoha.sugar
konoha.thread konoha.xml
\end{commandline}
\footnote{Subversion Revision 954 時点のものです。Linux版において、全てがビルド/動作することを確認していません。}

ライブラリを使用するときは、using文を使用します。
以下に Math ライブラリを呼び出した例を記述します。
\begin{commandline}
>>> using konoha.math.Math;
>>> Math.PI 3.141593
>>> Math.pow(1.23, 3.45)
2.042550
\end{commandline}

\item 性能
JIT コンパイラや LLVM コンパイラの採用も進められており、「世界最高水準
と誇れる性能」を記録しているらしいです。

\end{enumerate}

\subsection{パッケージ化の内容確認}
\subsubsection{開発環境}
\begin{itemize}
\item マシン

    CPU   : Intel(R) Core(TM) i3-2367M CPU @ 1.40GHz\\
    メモリ: 4GB
\item OS

    Kernel   : Linux 3.2.0-0.bpo.2-amd64\\
    Userland : Debian sid (cowbuilder)
\end{itemize}
\subsubsection{upsterem からの承認}
承認を頂いております。

\subsubsection{ライセンス}
Konoha は GPLv3 です。

Konoha core は、build-essential 以外の依存パッケージは必要ないのです
が、Konoha Extra Package は、それぞれ依存パッケージが必要になります。
\footnote{Konoha Extra Package は dynamic link library と Konohaスクリプトのラッパーから構成されています。}

/usr/share/doc/*/copyright から、関連する依存パッケージのライセンスを
表\ref{tab:konoha-licenses}にまとめました。

\begin{table}[ht]
 \caption{関連する依存パッケージのライセンス}
 \label{tab:konoha-licenses}
\begin{center}
  \begin{tabular}{|l|l|}
 \hline
 パッケージ名 & ライセンス \\
 \hline
  libffi-dev        & GPLv2 or later \\
  libmemcached-dev  & RSA Data Security License, Public Domain, BSD-TangentOrg, BSD-Sun, BSD\\
  libsqlite3-dev    & public domain\\
  libqt4-dev        & LGPLv2.1, GPLv2, GPLv3\\
  libqt4-opengl-dev & LGPLv2.1, GPLv2, GPLv3\\
  libqtwebkit-dev   & LGPLv2 or later\\
  libcairo2-dev     & LGPLv2, MPLv1.1\\
  libopenmpi-dev    & LGPLv2\\
  libjson0-dev      & MIT \\
  libcurl4-nss-dev  & curl, BSD-4-Clause, BSD-3-Clause, ISC\\
  libxml2-dev       & MIT \\
  libreadline-dev   & GPLv3 or later\\
 \hline
 \end{tabular}
\end{center}
\end{table}
\footnote{libmemcached-dev,libcurl4-nss-dev:ファイルにより異なるみたい}

\begin{itemize}
\item Q1: Konoha core は、GPLv3 で問題ないと認識してよいでしょうか？\\
dynamic link するライブラリがどのようなライセンスでも問題ない？
\item Q2: Konoha extra Package は GPLv3 以外のライブラリに依存するので、
別の Debian パッケージにする必要があるのでしょうか？
\end{itemize}

\subsubsection{Debian パッケージ化の方針}
とりあえず現状はシングルパッケージにしています。

本来は、以下のような3種類に分ける必要があることは理解しています。

\begin{enumerate}
\item core
\item libray(extra package)
\item その他(document and sampleなど)
\end{enumerate}

\begin{itemize}
\item Q1: ライブラリはどのような精度で分割するのがよいでしょうか？
  \begin{itemize}
  \item 各ライブラリごと
  \item グループ分け(Graphic や DB など)
  \end{itemize}
\item Q2: 64bit版と32bit版の切り分けは？
\end{itemize}

\subsubsection{パッケージ名}
\begin{screen}
  konoha-1.0.0\~{}954
\end{screen}

1.0.0 は upstream のバージョン、954 はパッケージ化したときの
Subversion Revision です。

\subsubsection{オリジナルのビルド手順}
\begin{commandline}
$ sudo apt-get install cmake libffi-dev libmemcached-dev libsqlite3-dev libqt4-dev libqt4-opengl-dev libqtwebkit-dev \
libcairo2-dev libopenmpi-dev libjson0-dev libcurl4-nss-dev libxml2-dev libreadline-dev openjdk-6-jdk ant
$ svn export http://konoha.googlecode.com/svn/trunk/ konoha-read-only
$ cd konoha-read-only/konoha/build/
$ cmake ../ -DCMAKE_INSTALL_PREFIX=/usr \
-DMPI_ROOT_DIR=/usr/lib/openmpi -DUSE_QT4=ON -DK_REVISION=954 2>&1 | tee cmake.log
$ make 2>&1 | tee make.log
$ mkdir tmp
$ DESTDIR=tmp make install 2>&1 | tee make-install.log
\end{commandline}

\if0
$ tree tmp
tmp
└── usr
    ├── bin
    │   ├── jkonoha
    │   ├── konoha
    │   ├── konoha2js
    │   ├── konohac
    │   └── mpikonoha
    ├── include
    │   ├── konoha1
    │   │   ├── inlinelibs.h
    │   │   ├── konoha_api.h
    │   │   ├── konoha_class.h
    │   │   ├── konoha_code_.h
    │   │   ├── konoha_config.h
    │   │   ├── konoha_debug.h
    │   │   ├── konoha_gc.h
    │   │   ├── konoha_glue.h
    │   │   ├── konoha_name.h
    │   │   ├── konoha_t.h
    │   │   ├── konoha_vm.h
    │   │   ├── konohalang.h
    │   │   └── license.h
    │   └── konoha1.h
    ├── konoha
    │   ├── package
    │   │   └── 1.0
    │   │       ├── js.dom
    │   │       │   └── dom.k
    │   │       ├── js.jquery
    │   │       │   └── jquery.k
    │   │       ├── konoha.actor
    │   │       │   └── actor.k
    │   │       ├── konoha.cairo
    │   │       │   ├── cairo.k
    │   │       │   └── cairo.so
    │   │       ├── konoha.compiler
    │   │       │   ├── compiler.k
    │   │       │   └── compiler.so
    │   │       ├── konoha.compiler.java
    │   │       │   ├── java.k
    │   │       │   └── jkonoha.jar
    │   │       ├── konoha.compiler.js
    │   │       │   └── js.k
    │   │       ├── konoha.curl
    │   │       │   ├── curl.k
    │   │       │   └── curl.so
    │   │       ├── konoha.i
    │   │       │   ├── i.k
    │   │       │   └── i.so
    │   │       ├── konoha.io
    │   │       │   ├── io.k
    │   │       │   └── io.so
    │   │       ├── konoha.json
    │   │       │   ├── json.k
    │   │       │   └── json.so
    │   │       ├── konoha.lang
    │   │       │   ├── lang.k
    │   │       │   └── lang.so
    │   │       ├── konoha.math
    │   │       │   ├── math.k
    │   │       │   └── math.so
    │   │       ├── konoha.memcached
    │   │       │   ├── memcached.k
    │   │       │   └── memcached.so
    │   │       ├── konoha.mpi
    │   │       │   ├── mpi.k
    │   │       │   └── mpi.so
    │   │       ├── konoha.ntrace
    │   │       │   ├── ntrace.k
    │   │       │   └── ntrace.so
    │   │       ├── konoha.posix
    │   │       │   ├── posix.k
    │   │       │   └── posix.so
\end{commandline}
\begin{commandline}
    │   │       ├── konoha.proc
    │   │       │   ├── proc.k
    │   │       │   └── proc.so
    │   │       ├── konoha.qt4
    │   │       │   ├── qt4.k
    │   │       │   └── qt4.so
    │   │       ├── konoha.signal
    │   │       │   ├── signal.k
    │   │       │   └── signal.so
    │   │       ├── konoha.socket
    │   │       │   ├── socket.k
    │   │       │   └── socket.so
    │   │       ├── konoha.sugar
    │   │       │   └── sugar.k
    │   │       ├── konoha.thread
    │   │       │   ├── thread.k
    │   │       │   └── thread.so
    │   │       └── konoha.xml
    │   │           ├── xml.k
    │   │           └── xml.so
    │   └── script
    │       └── 1.0
    │           ├── actsrv
    │           ├── actsrv2
    │           ├── mailbox.k
    │           ├── man
    │           └── status
    └── lib
        ├── libkonoha.so -> libkonoha.so.1.0
        ├── libkonoha.so.1.0 -> libkonoha.so.1.0.0
        └── libkonoha.so.1.0.0

34 directories, 70 files
----------------------------------------------------------------
\end{commandline}
\fi

\begin{itemize}
\item Q1: Konoha Extra Package のインストール先は、/usr/konoha以下ではなく、
/usr/lib/konoha以下に修正する必要はありますでしょうか？
lintian のチェックで warning になります。
\end{itemize}

\subsubsection{環境変数の設定}
\begin{commandline}
$ export DEBEMAIL="stadaki.dev@gmail.com"
$ export DEBFULLNAME="Tadaki SAKAI"
\end{commandline}
%$ for emacs font-lock

\subsubsection{制御ファイルのテンプレート作成}
\begin{commandline}
$ svn export http://konoha.googlecode.com/svn/trunk/ konoha-read-only
$ konoha-read-only
$ tar cvfz konoha.tar.gz konoha
$ mv konoha konoha-1.0.0~954
$ cd konoha-1.0.0~954
$ dh_make --single --copyright gpl3 --file=../konoha.tar.gz
$ rm -f debian/*.ex
$ rm -f debian/*.Ex
\end{commandline}

\subsubsection{debian/control ファイル修正}
\begin{commandline}
Source: konoha
Section: interpreters
Priority: optional
Maintainer: Tadaki SAKAI <stadaki.dev@gmail.com>
Build-Depends: debhelper (>= 7.0.50~), cmake, libffi-dev, libmemcached-dev,
  libsqlite3-dev, libqt4-dev, libqt4-opengl-dev, libqtwebkit-dev, libcairo2-dev,
  libopenmpi-dev, libjson0-dev, libcurl4-nss-dev, libxml2-dev, openjdk-6-jdk, ant,
  libreadline-dev
Standards-Version: 3.8.4
Homepage: http://konoha.sourceforge.jp/
Vcs-Svn: http://konoha.googlecode.com/svn/trunk/
Vcs-Browser: http://code.google.com/p/konoha/downloads/list

Package: konoha
Architecture: amd64
Depends: ${shlibs:Depends}, ${misc:Depends}
Description: statically-typed scripting language
 Konoha scripting language has a Java-like syntax, multiplatform
 virtual machine, and static typing system.
\end{commandline}


\subsubsection{debian/copyright ファイル修正}
\begin{commandline}
Format: http://dep.debian.net/deps/dep5
Upstream-Name: konoha
Source: http://konoha.sourceforge.jp/

Files: *
Copyright: Kimio Kuramitsu <kkuramitsu@gmail.com>
           Shinpai Nakata <shinpei.nakata@gmail.com>
           Masahiro Ide <masa.ide.on@gmail.com>
License: GPL-3.0+

Files: debian/*
Copyright: 2012 Tadaki SAKAI <stadaki.dev@gmail.com>
License: GPL-3.0+

License: GPL-3.0+
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 .
 This package is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 .
 You should have received a copy of the GNU General Public License
 along with this program. If not, see <http://www.gnu.org/licenses/>.
 .
 On Debian systems, the complete text of the GNU General
 Public License version 3 can be found in "/usr/share/common-licenses/GPL-3".

# Please also look if there are files or directories which have a
# different copyright/license attached and list them here.
\end{commandline}

\subsubsection{debian/rules ファイル修正}
\begin{commandline}
#!/usr/bin/make -f
# Sample debian/rules that uses debhelper.

# Uncomment this to turn on verbose mode.
#export DH_VERBOSE=1

DESTDIR=$(CURDIR)/debian/konoha

clean:
	dh_testdir
	dh_auto_clean
	dh_clean
	rm -rf configure-stamp build-stamp
	rm -rf $(DESTDIR)
	rm -f debian/files

configure: configure-stamp
configure-stamp:
	dh_testdir
#	dh_auto_configure
	cd build && cmake ../ -DCMAKE_INSTALL_PREFIX=/usr -DMPI_ROOT_DIR=/usr/lib/openmpi -DUSE_QT4=ON -DK_REVISION=954
	touch $@

build: configure build-stamp
build-stamp:
	dh_testdir
#	dh_auto_build
	cd build && $(MAKE)
#	dh_auto_test
	touch $@

binary: binary-arch binary-indep

binary-arch:
	dh_testdir
	dh_testroot
	dh_prep
	dh_installdirs
#	dh_auto_install
	cd build && $(MAKE) install prefix= DESTDIR=$(DESTDIR)
	dh_install
	dh_installdocs
	dh_installchangelogs
	dh_installexamples
	dh_installman
#	dh_installcatalogs
#	dh_installcron
#	dh_installdebconf
#	dh_installemacsen
#	dh_installifupdown
	dh_installinfo
#	dh_installinit
#	dh_installmenu
#	dh_installmime
#	dh_installmodules
#	dh_installlogcheck
#	dh_installlogrotate
#	dh_installpam
#	dh_installppp
#	dh_installudev
#	dh_installwm
#	dh_installxfonts
#	dh_bugfiles
#	dh_lintian
#	dh_gconf
#	dh_icons
#	dh_perl
#	dh_usrlocal
	dh_link
	dh_compress
	dh_fixperms
	dh_strip
	dh_makeshlibs
	dh_shlibdeps
	dh_installdeb
	dh_gencontrol
	dh_md5sums
	dh_builddeb

binary-indep:
\end{commandline}
%$ for emacs font-lock

\subsubsection{Debianパッケージの作成}
\begin{commandline}
$ dpkg-buildpackage -us -uc
\end{commandline}
%$ for emacs font-lock

親ディレクトリに以下が作成される
\begin{commandline}
konoha_1.0.0~954-1.debian.tar.gz
konoha_1.0.0~954-1.dsc
konoha_1.0.0~954-1_amd64.changes
konoha_1.0.0~954-1_amd64.deb
konoha_1.0.0~954.orig.tar.gz
\end{commandline}

\subsubsection{動作確認}
\begin{enumerate}
\item lintian
  \begin{commandline}
$ lintian konoha_1.0.0~954-1_amd64.deb
W: konoha: package-name-doesnt-match-sonames libkonoha1.0
W: konoha: new-package-should-close-itp-bug
W: konoha: wrong-bug-number-in-closes l3:#nnnn
E: konoha: copyright-contains-dh_make-todo-boilerplate
W: konoha: readme-debian-contains-debmake-template
W: konoha: non-standard-dir-in-usr usr/konoha/
W: konoha: file-in-unusual-dir usr/konoha/package/1.0/js.dom/dom.k
（中略）
W: konoha: file-in-unusual-dir usr/konoha/script/1.0/actsrv
W: konoha: file-in-unusual-dir usr/konoha/script/1.0/actsrv2
W: konoha: file-in-unusual-dir usr/konoha/script/1.0/mailbox.k
W: konoha: file-in-unusual-dir usr/konoha/script/1.0/man
W: konoha: file-in-unusual-dir usr/konoha/script/1.0/status
W: konoha: jar-not-in-usr-share usr/konoha/package/1.0/konoha.compiler.java/jkonoha.jar
W: konoha: binary-without-manpage usr/bin/jkonoha
W: konoha: binary-without-manpage usr/bin/konoha
W: konoha: binary-without-manpage usr/bin/konoha2js
W: konoha: binary-without-manpage usr/bin/konohac
W: konoha: binary-without-manpage usr/bin/mpikonoha
W: konoha: non-dev-pkg-with-shlib-symlink usr/lib/libkonoha.so.1.0.0 usr/lib/libkonoha.so
  \end{commandline}
%$ for emacs font-lock
以下の対応が必要だと考えています。
\begin{enumerate}
\item ITP して changelog に number を記述する
\item Konoha Extra Pacage のインストール先を /usr/konoha から
/usr/lib/konoha に変更する
\item TODO, manpage を作成する
\end{enumerate}
\item ビルド時の依存チェック
  \begin{commandline}
$ sudo pbuilder build konoha_1.0.0~954-1.dsc \
--basetgz /var/cache/pbuilder/base-amd64.tgz
  \end{commandline}
%$ for emacs font-lock
/var/cache/pbuilder/result/ 以下に Konoha のバイナリ/ソースパッケージが
作成されることを確認しました。
\end{enumerate}

\clearpage

%-------------------------------------------------------------------------------
\dancersection{スクリプティング言語 Konoha の Debian パッケージ化について}{酒井 忠紀}
%-------------------------------------------------------------------------------
\index{konoha}

\subsection{はじめに}
前回は Konoha の概要説明とその Debian パッケージの内容確認をしました。
今回は、以下について説明します。
\begin{itemize}
\item upstream との調整経緯
\item debian/rules 修正とパッケージ分割について
\end{itemize}

\subsection{upstream との調整経緯}
\subsubsection{ライセンス問題について}
前回、ご指摘を頂いた以下のライセンス問題を upstream の方に報告しました。
\begin{itemize}
\item Web サイトでは GPLv3 と記述されているが、配布物の COPYING ファイルは LGPLv3 になっている
\item 配布物の中に "third-party" というディレクトリがあり、その中に jar ファイルや Apache Linense 2.0 ライセンスのソースの tar アーカイブがある
\end{itemize}

現在、ライセンスに関しては upsteam 側で再検討を行っているようです。

また、"Konoha Non-Disclosure License 1.0" とは、有償サポート付きのライセンスを検討していたということでした。

\begin{itembox}[l]{質問}
  \begin{enumerate}
  \item ユーザの視点から、扱いやすいライセンスの組み合わせなどはありますでしょうか？\\
    GPLv2 or Later と New BSD のデュアルライセンスなど
  \item 言語によって相性の良いライセンスなどがありますでしょうか？\\
    例えば、Qt は言語バインディングによって以下のようにライセンスが異なるようです。
    \begin{itemize}
    \item Ada ... GPL
    \item C++ ... LGPL
    \item C\# \& .NET(qt4dotnet) ... LGPL
    \item Java ... LGPL
    \item Lisp ... BSD
    \item Lua ... MIT
    \item Perl ... GPL
    \item PHP ... LGPL
    \item Python(PyQt) ... GPL
    \item Ruby ... LGPL
    \item Tcl ... GPL
    \end{itemize}
  \end{enumerate}
\end{itembox}

\subsubsection{upstream の Konoha 開発状況について}
現在公開されている Konoha は Konoha 1.0 ですが、upsteam では試作的な扱いとなっているようです。

正規のものは現在開発中の Konoha 2.0 になり、6月頃のリリースを目標に作業が進められているようです。

upstream において、Konoha 1.0 はもうサポートする気がないようなので、ITP するのは Konoha 2.0 がリリースされてからにしようと考えています。

また、Debian 7.0(Wheezy) への新規パッケージの取り込みは 6月で閉じてしまうので、時期的に断念し、次の Debian 8.0? を目標にしようと考えています。

\subsubsection{Konoha 2.0 について}
現在開発中の Konoha 2.0 について、特徴を簡単に説明します。

\begin{enumerate}
\item 最小限の構文\\
  if, int, String, void, boolean, array, 関数定義 のみサポートする。(代入がない)\\
  POSIX lowlevel bind と呼ばれている。
\item Konoha Assignment\\
  言語のシンタックスをスクリプトで追加できる。
\item ライブラリ\\
  既存の Konoha 1.0 の機能は、ライブラリとして提供する。\\
  必要な機能のみ、インポートして使用できる。
\item 言語バインディング\\
  C, Java, JavaScript, C\#, その他を検討している。
\item ドキュメントの自動生成
\end{enumerate}

Konoha 2.0 は、以下に記述する4つのモジュールから構成されます。
\begin{itemize}
\item konoha (コマンド本体)
\item sugar (パーサー)
\item gc (Garbage Collection)
\item vm (Virtual Machine)
\end{itemize}

バイナリサイズが 約1/10 (100KB) になったので、組み込み機器やアプリケーションなどに容易に組み込むことが可能になるようです。

\subsection{debian/rules 修正とパッケージ分割について}
Konoha 2.0 はまだ公開されていないので、Konoha 1.0 のままになりますが、前回指摘を受けた以下の2つを修正しました。

\subsubsection{debian/rules 修正}
前回は debhelper を使用して記述していましたが、今回は dh を使用して記述し直しました。

記述内容をかなり省略することができ、行数が 43行 から 7行 になりました。
(コメントと空行は除く)

修正した debian/rules を以下に記述します。
\begin{commandline}
#!/usr/bin/make -f
# -*- makefile -*-
# Uncomment this to turn on verbose mode.
#export DH_VERBOSE=1

%:
        dh $@ --buildsystem cmake --builddirectory=build

override_dh_auto_configure :
        dh_auto_configure -- -DCMAKE_INSTALL_PREFIX=/usr -DMPI_ROOT_DIR=/usr/lib/openmpi -DUSE_QT4=ON -DK_REVISION=961

override_dh_auto_test :

\end{commandline}
%$ for emacs font-lock

--buildsystemオプションで、ビルドシステムに cmake を指定しました。
前回は configure ターゲットを自前で記述していました。

ビルドシステムは、以下が指定できるようです。
\begin{itemize}
\item autoconf ... GNU Autoconf (configure)
\item perl\_makemaker ... Perl MakeMaker (Makefile.PL)
\item makefile ... simple Makefile
\item python\_distutils ... Python Distutils (setup.py)
\item perl\_build ... Perl Module::Build (Build.PL)
\item cmake ... Cmake (CmakeLists.txt)
\item ant ... Ant (build.xml)
\end{itemize}

--builddirectoryオプションで、ビルドディレクトリを指定しました。
前回は configure, build, clear, install ターゲットで、'cd build \&\&' を記述していました。

override\_dh\_auto\_configure ターゲットで、cmake のオプションをオーバライドしました。

override\_dh\_auto\_test ターゲットで、make test を実行しないようにしました。

debian/rules の書き方は、以下を参考にしました。\\
\url{http://www.debian.org/doc/manuals/packaging-tutorial/packaging-tutorial.pdf}\\
\url{http://kitenet.net/~joey/talks/debhelper/debhelper-slides.pdf}

\subsubsection{パッケージ分割}
前回はシングルパッケージにしていましたが、Debian ポリシーに従い、以下の3つのパッケージに分割しました。

\begin{itemize}
\item konoha パッケージ (実行バイナリ)\\
  konoha\_1.0.0+svn961-1\_amd64.deb
\item libkonoha1 パッケージ (ライブラリ + シンボリックリンク(SONAME))\\
  libkonoha1\_1.0.0+svn961-1\_amd64.deb
\item konoha-dev パッケージ (ヘッダファイル + シンボリックリンク)\\
  konoha-dev\_1.0.0+svn961-1\_amd64.deb
\end{itemize}

konoha パッケージ と konoha-dev パッケージは、libkonoha1 パッケージに依存するように定義しました。

修正した debian/control を以下に記述します。
ruby1.9.1 のソースパッケージを参考にしました。
\begin{commandline}
Source: konoha
Section: interpreters
Priority: optional
Maintainer: Tadaki SAKAI <stadaki.dev@gmail.com>
Build-Depends: debhelper (>= 7.0.50~), cmake, libffi-dev, libmemcached-dev, libsqlite3-dev, libqt4-dev,
  libqt4-opengl-dev, libqtwebkit-dev, libcairo2-dev, libopenmpi-dev, libjson0-dev, libcurl4-nss-dev,
  libxml2-dev, openjdk-6-jdk, ant, libreadline-dev
Standards-Version: 3.9.3
Homepage: http://konoha.sourceforge.jp/
Vcs-Svn: http://konoha.googlecode.com/svn/trunk/
Vcs-Browser: http://code.google.com/p/konoha/downloads/list

Package: konoha
Architecture: amd64
Depends: libkonoha1 (= ${binary:Version}), ${shlibs:Depends}, ${misc:Depends}
Suggests: konoha-dev
Description: Interpreter of statically-typed scripting language Konoha
 Konoha scripting language has a Java-like syntax, multiplatform
 virtual machine, and static typing system.

Package: libkonoha1
Section: libs
Architecture: amd64
Depends: ${shlibs:Depends}, ${misc:Depends}
Description: Libraries necessary to run Konoha
 Konoha scripting language has a Java-like syntax, multiplatform
 virtual machine, and static typing system.

Package: konoha-dev
Architecture: amd64
Depends: libkonoha1 (= ${binary:Version}), ${shlibs:Depends}, ${misc:Depends}
Recommends: konoha (= ${binary:Version})
Description: Header files for compiling extension modules for the Konoha
 Konoha scripting language has a Java-like syntax, multiplatform
 virtual machine, and static typing system
\end{commandline}
%$ for emacs font-lock


konoha パッケージ でインストールするファイルは debian/konoha.install で定義しました。\\
debian/konoha.install を以下に記述します。
\begin{commandline}
debian/tmp/usr/bin/*
\end{commandline}

libkonoha1 パッケージ でインストールするファイルは debian/libkonoha1.install で定義しました。\\
 debian/libkonoha1.install を以下に記述します。
\begin{commandline}
debian/tmp/usr/lib/libkonoha.so.1.0
debian/tmp/usr/lib/libkonoha.so.1.0.0
debian/tmp/usr/konoha/*
\end{commandline}

konoha-dev パッケージ でインストールするファイルは debian/konoha-dev.install で定義しました。\\
debian/konoha-dev.install を以下に記述します。
\begin{commandline}
debian/tmp/usr/include/*
debian/tmp/usr/lib/libkonoha.so
\end{commandline}

\subsection{Konoha 1.0 Debian パッケージの作成手順}

sid で以下の実行する。
\begin{commandline}
$ sudo apt-get install cmake libffi-dev libmemcached-dev \
libsqlite3-dev libqt4-dev libqt4-opengl-dev libqtwebkit-dev \
libcairo2-dev libopenmpi-dev libjson0-dev libcurl4-nss-dev \
libxml2-dev libreadline-dev openjdk-6-jdk ant
$ svn export http://konoha.googlecode.com/svn/trunk/ konoha-read-only
$ cd konoha-read-only
$ tar cvfz konoha.tar.gz konoha
$ mv konoha konoha-1.0.0+svn961
$ cd konoha-1.0.0+svn961
$ dh_make --copyright gpl3 --file=../konoha.tar.gz
\end{commandline}
%$ for emacs font-lock
前章に記述した内容で、以下のファイルを編集する。\\
(copyright, changelog に関しては、第57回関西 Debian 勉強会の資料を参照。)
\begin{commandline}
  debian/rules
  debian/control
  debian/konoha.install
  debian/libkonoha1.install
  debian/konoha-dev.install
  debian/copyright
  debian/changelog
\end{commandline}
ビルドを実行。
\begin{commandline}
$ debuild -us -uc
\end{commandline}
%$ for emacs font-lock

親ディレクトリに以下が作成される。
\begin{commandline}
libkonoha1_1.0.0+svn961-1_amd64.deb
konoha-dev_1.0.0+svn961-1_amd64.deb
konoha_1.0.0+svn961-1_amd64.deb
konoha_1.0.0+svn961-1.dsc
konoha_1.0.0+svn961.orig.tar.gz
konoha_1.0.0+svn961-1.debian.tar.gz
konoha_1.0.0+svn961-1_amd64.build
konoha_1.0.0+svn961-1_amd64.changes
\end{commandline}

lintian では、まだ Warning などが出力されています。
ITP number や、man ファイル、Konoha Extra Package の格納位置などを修正する必要があります。

\clearpage

\clearpage

%-------------------------------------------------------------------------------
\dancersection{月刊 Debian Policy「パッケージの依存関係についてのルール」}{倉敷 悟}
%-------------------------------------------------------------------------------                                                                                                                             
\index{Debian Policy}

分量も多くてなかなか読み辛いのが Debian Policy。敬遠している方もいると思います。
とはいえ、「ポリシー」と大仰な名前がついてはいますが、結局のところ書かれている内容は

「パッケージの作り方についてのルール、ガイド、ベストプラクティス」

を集めたものです。パッケージの開発をしていないとしても、ファイルの配置や依存関係に
不可解なものを感じたことがあれば、その答えがきっと見つかるはずです。


というわけで、勉強会で連続コマとして少しずつ読んでいってみることにします。いろいろ
含めて、おおよそ 1 年かけて終了することになると思います。
担当した人は、まだ担当していない人から次回の担当者を指名します。指名された人は、
まだ読まれていない章から順不同で好きな部分を選んでください。

さて、今回読むのは、パッケージの依存関係のポリシーについて記載されている 7 章です。

依存関係といって思い浮かぶのは Depends に代表される「前提として事前に必要」
ですが、dpkg では他にも色々な形で「そのパッケージと他のパッケージの関係」を
表現することができます。

さて、ポリシー本文は事前課題として当然\footnote{実は事前課題を指定した時点では、
日本語訳の存在をすっかり忘れていました}読み終わっているはずですが、簡単に
おさらいしていきましょう。空いた時間は四方山話として、フリーディスカッションの
ような形で、皆さんが舐めてきた辛酸を肴にして頂こうと思います。

\subsection{おさらい}
\subsubsection{debian/control の書式}

依存関係の指定は、debian/control ファイルに、依存関係の種類に応じたフィールドと
その値をセットすることで行います。

\begin{commandline}
Depends: libqdbm14, libestraier
\end{commandline}

必要があれば、カンマで区切って複数のパッケージ名を列挙することができます。これに
バージョン指定が入ると、

\begin{commandline}
Depends: libqdbm14 (>> 1.8.77 ), libestraier
\end{commandline}

となります。この場合、libqdbm14 の 1.8.77 では依存を満たせません。

同類がいくつかあって、そのうちどれかがあればよい、という場合はパイプ(\verb+|+)を使って

\begin{commandline}
Depends: emacs23 | emacs22 | emacs21
\end{commandline}

と書くことができます。

\subsubsection{バイナリパッケージ用フィールド}

バイナリパッケージでは、そのパッケージをインストールするために必要な情報として
依存関係が使われます。まずは基本的なものから。

\begin{description}
\item[Depends] なくては動かないパッケージを指定します。
\item[Recommends] なくても動きはするけれど、できれば一緒に使った方がいいパッケージを指定します。
\item[Suggests] 一緒に使うと便利なパッケージを指定します。主体はこのパッケージです。
\item[Enhances] 一緒に使うと便利なパッケージを指定します。主体は指定されたパッケージです。
\item[Pre-Depends] 通常の Depends よりも前の段階で依存先のパッケージがチェックされます。非推奨なので、使われている場合は何か地雷があるのかもしれません
\end{description}

一方で、少しややこしい関係性として、次のようなものがあります。

\begin{description}
\item[Breaks] 比較的最近追加されました。このパッケージをインストールすることで動作しなくなるパッケージを指定します。通常は、自パッケージの再編成で使われるようです
\item[Conflicts]完全に両立不可能なパッケージを指定します。システムにはそのうち 1 つしかインストールできません
\item[Replace] 指定したパッケージ全体、もしくは一部のファイルを、このパッケージで置き替えます
\item[Provides] (存在する場合) このパッケージが代替し得る、特定の仮想パッケージを指定します
\end{description}


\subsubsection{ソースパッケージ用フィールド}

ソースパッケージは、いわゆるインストールをして使うものではないので、Depends は
意味を持ちません。
ソースパッケージの依存関係では、そのソースパッケージをビルドするために必要な情報として
依存関係が使われます。

\begin{description}
\item[Build-Depends] ビルドするために必要なパッケージを指定します
\item[Build-Conflicts] ビルドする時にインストールされていてはいけないパッケージを指定します
\item[Build-Depends-Indep] build-indep ターゲットをビルドするために必要なパッケージを指定します
\item[Build-Conflicts-Indep] build-indep ターゲットをビルドする時にインストールされていてはいけないパッケージを指定します
\end{description}


\subsection{四方山話}

時間次第ですが、ここでは次のような話をざっくりとする予定です。

\begin{itemize}
\item Depends と Recommends と Suggests の違い
\item Provides と仮想パッケージ
\end{itemize}

会場で特にこれといって話題が出なさそうであれば、抜きうちで
事前課題の理解度テスト、みたいなことをするかも知れません。

\subsection{次号予告}

次回の担当は、yyatuo さんにお願いします (本人承諾済み)。

%-------------------------------------------------------------------------------
\dancersection{月刊 Debian Policy 第2回 「Controlファイルについて 」}{八津尾 雄介}
%-------------------------------------------------------------------------------
\index{Debian Policy}

先月倉敷さんの指名で今回の担当となりました八津尾です。今回はパッケージ作成の要で
ある {\it control} ファイルについてです。詳細はDebianポリシーマニュアルを読めば
わかるはずですので、あまりだらだらと説明せずに概要のみの説明とさせていただきます。

\subsection{Debian Policy 3.9.3.0 での変更点}
先頃 {\it Debian Policy 3.9.3.0} がリリースされ、著作権表記のフォーマット
を中心にいくつかの変更がありました。現在の日本語訳 3.9.1.0 と若干変わっています
ので、まずはその変更点を抑えておきましょう。\\
第5章に関しての変更点は、5.6.8 の{\it *.dsc}ファイルについての変更のみとなってい
ます。 {\it Archtecture} フィールドにアーキテクチャに依存するしないに関わらず
{\it "any all"} という値を指定できるようになりました。
\begin{quote}
"Specifying {\it any all} indicates that the source package isn't dependent on any
particular architecture. The set of produced binary packages will include at
least one architecture-dependant package and one architecture-independent
package."\\
{\it Debian Policy Manual. version 3.9.3.1, Chapter 5.6.8 "Archtecture":
Ian Jackson and Christian Schwarz, 2012-03-04}
\end{quote}
\begin{quote}
"{\it any all}を指定すると、ソースパッケージが特定のアーキテクチャに依存しない
事を意味します。生成されたバイナリパッケージには、アーキテクチャ依存パッケージ
とアーキテクチャ非依存パッケージが、少なくとも1つずつ含まれます。" (訳：八津尾)
\end{quote}
また、先月の第7章(7.1)に関しては、
\begin{quote}
{\bf "もし特定のアーキテクチャに依存している場合は、アーキテクチャのリストは空
白にしてはならない"}
\end{quote}
といった内容が追加されておりますので、日本語訳のみしか読んでいない方は確認をし
ておきましょう。その他の変更点については、それぞれの章の担当者にお任せします。

\subsection{debian/control ファイル}
{\it control}ファイルとはパッケージのメタ情報を扱うファイルです。{\it debian/
control}ファイルは2つの段落から成っており、最初の段落が全般的な情報を扱う {\it
"general paragraph"}、次の段落がバイナリパッケージで使用する情報を扱う {\it
"binary package paragraph"} と呼ばれています。{\it control} ファイルの書式は非常
に単純です。
\begin{screen}
フィールド名: フィールド値
\end{screen}
と記述するだけです。細かいルールは {\it debian policy} 第5章を読みましょう。
\begin{screen}
\$dh\_make -f (パッケージ名)
\end{screen}
というコマンドを使えば {\it debian/} 以下に必要なファイルが作成されます。以下は
私が {\it lpc21isp} という {\it arm} マイコン書込み用 {\it ISP}ツールをパッケー
ジ化してみた時に、{\it dh\_make} が自動的に生成した {\it control} ファイルです。
{\it dh\_make}コマンドを使えば、いくつかの質問に答えるだけで、{\it control}
ファイルを以下の状態まで持っていく事ができます。{\it dh\_make} についての詳細は
{\it dh\_make(8)} をご参照下さい。{\it dh\_make} を使ったパッケージ化の大まかな
流れは"Debian パッケージ化入門"
\footnote{パッケージ "packaging-tutorial"}
または"新メンテナガイド"
\footnote{http://www.debian.org/doc/manuals/maint-guide/index.ja.html\\
またはパッケージ "maint-guide-ja"}
が参考になります。
\begin{itembox}[l]{debian/control ファイルの例}
\begin{verbatim}
Source: lpc21isp
Section: utils
Priority: optional
Maintainer: Your Name <mail@address.here>
Build-Depends: debhelper (>= 8.0.0)
Standards-Version: 3.9.2
Homepage: http://www.aeolusdevelopment.com

Package: lpc21isp
Architecture: any
Depends:
Description: Portable command line ISP
 Portable command line ISP for NXP LPC1000 / LPC2000 family
  and Analog Devices ADUC70xx.
\end{verbatim}
\end{itembox}
ここでは使用されていないフィールド名もありますので、フィールド名の一覧は5.2章を
各フィールドが取る値とその意味については5.6章を参照して下さい。

\subsection{DEBIAN/control ファイル}
{\it debian/(パッケージ名)/DEBIAN/} 以下にも {\it control} ファイルが存在します。
このファイルは先述の {\it debian/control} ファイルを元に {\it dh\_gencontrol(1)} が生成します。
詳細は {\it man} を参照して下さい。\\
\begin{screen}
\$man dh\_gencontrol
\end{screen}
先に示した {\it control} ファイルからは以下のような {\it DEBIAN/control} ファイルが生成されます。

\begin{itembox}[l]{DEBIAN/control ファイルの例}
\begin{verbatim}
package: lpc21isp
Version: 1.8.3-1
Architecture: i386
Maintainer: Your Name <main@address.here>
Installed-Size: 588
Section: utils
Priority: optional
Homepage: http://www.aeolusdevelopment.com
Description: Portable command line ISP
 Portable command line ISP for NXP LPC1000 / LPC2000 family
 and Analog Devices ADUC70xx.
\end{verbatim}
\end{itembox}

\subsection{*.dsc ファイル}
{\it debuild} などを実行すると {\it *.deb} ファイルと同じディレクトリに {\it *.dsc}
ファイルが生成されます。
書式は {\it control} ファイルと同じ形態で、{\it control}ファイルを元に生成します。
{\it dpkg-source(1)} によって、ソースを展開する時に使われます。
パッケージの展開時に整合性のチェックをします。

\subsection{*.changes ファイル}
{\it .changes}ファイルは{\it Debian}アーカイブを管理するソフトウェアによって使用されます。
このファイルは{\it debian/control}、{\it debian/changelog}、{\it debian/rules} などから
抽出したソースパッケージの情報が含まれています
\clearpage
\subsection{各ファイルの関係}
\begin{figure}[h]
    \centering
    \includegraphics[width=.9\textwidth]{image201203/control.eps}
\end{figure}


%-------------------------------------------------------------------------------
\dancersection{月刊 Debian Policy 第3回 「Debian アーカイブ」}{かわだ てつたろう}
%-------------------------------------------------------------------------------
\index{Debian Policy}

諸般の事情で今回の担当となりました かわだ です。

今回読むのは第2章の「Debian のアーカイブ」についてです。
Debian Policy はパッケージについて書かれているわけですが、この章ではパッケージの集りであるアーカイブをどのように管理、配布するのかについて説明されています。
Debian Policy は読んだことの無い方でも Debian を使っていれば聞いたことのある内容でしょう。

さて、事前課題で内容は読んで理解していただいていると思いますのでざっと内容をみていきましょう。

\subsection{Debian フリーソフトウェアガイドライン}
Debian がフリーであると考えるソフトウェアの定義です。原文の Debian Free Software Guidelines を略した DFSG という単語もよく使われます。
「DFSG フリー」や「DFSG に準拠」という言い方はこのガイドラインに準拠したソフトウェアである、Debian が認めるフリーなソフトウェアであるということです。

DFSG は Debian 社会契約\footnote{http://www.debian.org/social\_contract}の一部であり Debian の根幹ですので一度じっくりと読んでみてください。

\subsection{アーカイブエリア}
\subsubsection{main}
Debian ディストリビューションといえばこの main アーカイブエリアのことを指します。

main に収録されるパッケージは DFSG に準拠していなければならず、コンパイル時や実行時にアーカイブエリア外のソフトウェアを必要としないこと、メンテナンスできること、Debian Policyに適合していることが求められます。

このアーカイブエリアのパッケージは誰でも自由\footnote{http://www.debian.org/intro/free}に使用、共有、修正、配布することができます。

\subsubsection{contrib}
contrib アーカイブエリアには、DFSG に準拠しているがコンパイル時や実行時にアーカイブエリア外のソフトウェアを要求するため main アーカイブエリアに置けないパッケージが収録されます。

\subsubsection{non-free}
non-free アーカイブエリアには、DFSG に準拠しないか配布に問題があるパッケージが収録されています。このアーカイブエリアのパッケージは自由に使用、共有、修正、配布することができません。

\subsection{著作権に関する考慮}
著作権について疑義があるソフトウェアはアーカイブに収録されることが留保されます。また、著作権が明示されていない作品の配布や変更は{\large 認められていません}ので注意してください。

パッケージは著作権情報と配布ライセンスの無修正コピーを /usr/share/doc/{\it package}/copyright ファイルとして同封し配布しなければなりません。


\subsection{セクションとプライオリティ}
セクションは Debian アーカイブメンテナによって公式に提供されており、勝手に追加することはできません。

プライオリティは高い順に required、important、standard、optional、extra があり、大半のパッケージは optional に属します。
また、プライオリティの高いパッケージはビルド時を除いてプライオリティの低いパッケージに依存してはいけません。

\begin{itembox}[l]{プライオリティ}
\begin{description}
\item [required] システムが適切に機能するために必要なパッケージ
\item [important] Unix ライクなシステムに必ず入っていることが期待されるプログラムのパッケージ
\item [standard] ほどよく小規模ながらキャラクタベースのシステムを提供するパッケージ
\item [optional] インストールしておく価値のある全てのパッケージ
\item [extra] 上記いずれかが指定されているパッケージと衝突するパッケージ
\end{description}
\end{itembox}


\subsection{最近の変更点}
日本語訳版がある Version 3.9.1.0 から Version 3.9.3.1 までに加えられた変更点を押さえておきましょう。

Version 3.9.2.0
\begin{itemize}
\item 「Debian GNU/Linux ディストリビューション」が「Debian ディストリビューション」と改められました。
\item main、contrib、non-free アーカイブエリアとは、が追記されています。
\end{itemize}

Version 3.9.3.0
\begin{itemize}
\item main アーカイブエリアのパッケージがアーカイブエリア外のパッケージを必要とする(required)だけでなく推奨する(recommend)ことも明記されました。
  ("Depends"、"Recommends"、"Build-Depends" に加えて "Pre-Depends" と "Build-Depends-Indep" が明記されています。)
\item セクションに education、introspection、metapackages の3つが追加されました。
\end{itemize}

\subsection{最後に}
次回の月刊 Debian Policy は。。。

%% -*-tex-*-
%%
%% Copyright (C) 2012 Hiroshi Kubo  all rights reserved.
%% 本資料の著作権は、著者である久保博 <h-kubo@geisya.or.jp> にあります。
%% Debian Policy とその日本語訳の引用があります。
%%
%% This document material is licensed under the GNU General Public License version 2.0.
%% This document is originally in the form of LaTeX source code. This shall be referenced as the ``Corresponding Source''
%% Any compiled forms including DVI, Postscript, and PDF from the original source code shall be reference as the ``Object code''.
%%
%%
%% Debian Policy は、
%%  1996, 1997, 1998, Ian Jackson and Christian Schwarz
%%   1999, Software in the Public Interest, Inc.
%%   1999-2012, many other Debian contributors
%% による著作です。
%% 取得元は : git://git.debian.org/git/dbnpolicy/policy.git です。
%%
%% Debian Policy 日本語訳は八田真行氏 mhatta@debian.or.jp 、かねこ氏 skanek@a2.mbn.or.jp、 森本氏 odin@sleipnir.dice.cache.waseda.ac.jp 
%% による著作です。
%% 取得元は : https://svn.debian.or.jp/repos/www/trunk/src/community/devel/debian-policy-ja/policy.ja.sgml  です。

%-------------------------------------------------------------------------------
\dancersection{月刊 Debian Policy 第4回 「バイナリパッケージ」}{山城国の住人 久保博}
%-------------------------------------------------------------------------------
\index{Debian Policy}

%% 今回は、 ``Chapter 3 - Binary Package'' です。

\subsection{内容の概観}
３章には、日本語訳で「バイナリパッケージ」というタイトルがついて、バイナリパッケージの論理的な構造や約束毎について述べています。

バイナリパッケージは .deb ファイル形式で提供されています。
.deb 形式はアーカイブファイルの一種で、展開すると複数のファイルが取り出されます。
そうして取り出されるファイルをまず二種類に大別しています。

\begin{itemize}
\item A set of files to install on the system when the package is installed \\
  （パッケージインストールの際にシステムにインストールされる一連のファイル群）
\item second set of files: control information files \\
  （制御情報ファイル）
\end{itemize}

続いて、割と細かく節毎に記述があるのですが、流れるような文章ではなく、 節一つ一つが箇条書の項目のようで、割と唐突な印象が拭えません。
そこで、全体像をあぶり出して見ようと思います。

まず、この章で述べられている範囲の概念を図\ref{fig:binary-package-class}に示すUMLのクラス図に書いてみました。
\begin{figure}[hbt]
\caption{３章のバイナリパッケージの概念的なクラス図}\label{fig:binary-package-class}
\hfil
\begin{picture}(420,220)(-10,-10)
\put(10,200){\makebox(0,0)[lt]{
\begin{tabular}{|ll|}
\hline
\multicolumn{2}{|c|}{バイナリパッケージ} \\ \hline
+パッケージ名 &  \\ 
+バージョン & \\
+メンテナ & \\
+説明 & \\
+依存関係[*] & \\
+仮想パッケージ[*] & \\
+プライオリティ評価 & \\
 \hline
\end{tabular}
}}
\put(130,170){
\begin{picture}(140,10)
\put(5,5){1\ldots{}*}
\put(40,5){Provides}
\put(100,5){*}
\put(0,0){\line(1,0){140}}
\end{picture}
}
\put(130,70){
\begin{picture}(30,30)
%%\put(0,-30){\framebox(200,30){}}
\put(5,15){*}
\put(0,0){\oval(30,30)[r]}
\put(0,0){\oval(30,30)[b]}
\put(21,-5){Depends, Pre-Depends, Conflicts, \ldots}
\put(-23,-10){*}
\end{picture}
}
\put(250,170){\makebox(0,0)[l]{
\begin{tabular}{|ll|}
\hline
\multicolumn{2}{|c|}{仮想パッケージ} \\ \hline
+パッケージ名 &  \\ 
 \hline
\end{tabular}
}}
\put(130,110){
\begin{picture}(80,10)
\put(5,5){1}
\put(60,5){*}
\put(0,0){\line(1,0){70}}
\end{picture}
}
\put(200,110){
\begin{tabular}{|ll|}
\hline
\multicolumn{2}{|c|}{メンテナスクリプト} \\ \hline
-スクリプトを解釈するインタープリタ & \\
\hline
+プロンプト表示() &  \\ 
 \hline
\end{tabular}
}
\put(20,35){
\begin{picture}(50,40)
\put(50,35){\line(-1,-1){10}}
\put(50,35){\line(1,-1){10}}
\put(50,0){\line(0,1){25}}
\put(40,25){\line(1,0){20}}
\end{picture}
}
\put(000,000){\makebox(0,0)[bl]{
\begin{tabular}{|ll|}
\hline
\multicolumn{2}{|c|}{Essential バイナリパッケージ} \\ \hline
+Essential &  \\ 
 \hline
\end{tabular}
}}
\put(-10,-10){\framebox(420,220){ }}
\end{picture}
\hfil
\end{figure}

図\ref{fig:binary-package-class}から、次に掲げる事がが読みとれるでしょうか。
\begin{itemize}
\item 「バイナリパッケージ」は、ひとつのクラスとみなせる
\item 「バイナリパッケージ」には、いくつかの属性がある
\item 「バイナリパッケージ」クラスの特別なもの（派生クラス）として、「Essential なバイナリパッケージ」クラスがある。
\item 「バイナリパッケージ」には、複数の「メンテナスクリプト」が含まれる。
\end{itemize}

これを手がかりに３章を読んでみると、ここではバイナリパッケージが守るべき決め事をを次のような三つの側面から論じているように読みとることが出来るように思います。
\begin{enumerate}
\item パッケージ一つ一つの性質に応じてつける属性の決め事
\begin{itemize}
\item 3.1節 パッケージ名
\item 3.2節 パッケージのバージョン
\item 3.3節 パッケージのメンテナ
\item 3.4節 パッケージの説明
\item 3.5節 依存関係
\item 3.6節 仮想パッケージ
\end{itemize}
\item Debian システム全体の中で特別な地位を占めるパッケージにつける属性についての決め事
\begin{itemize}
\item 3.7節 Base システム
\item 3.8節 Essential パッケージ
\end{itemize}
\item パッケージに含まれるメンテナスクリプトが守るべき決め事
\begin{itemize}
\item 3.9節 メンテナスクリプト
\end{itemize}
\end{enumerate}

また、3.1節から3.8節までは、「5.3 バイナリパッケージコントロールファイル -- DEBIAN/control」で解説されている、コントロールフィールドに記述する内容に関するガイドラインになっています。
3.9節 「メンテナスクリプト」だけは、バイナリパッケージの属性ではなく、パッケージに含まれるスクリプトが守るべき決め事が書かれています。

\subsection{最近の変更点}
次に、日本語訳版がある Version 3.9.1.0 から Version 3.9.3.1 までに加えられた変更点を押さえておきましょう。

\begin{itemize}
\item 「Debian GNU/Linux ディストリビューション」が「Debian ディストリビューション」と改められました。
%% \item 「The maintainer of a package」の節の sect タグに id 属性値 ``maintainer'' が追加されました。
\item メンテナの責任について、詳しく具体的な記述が追加されました。
\item メンテナのメールアドレスについて、詳しく具体的な記述が追加されました。
\item Uploader コントロールフィールドについての記述が追加されしました。
\item みなしごパッケージについての記述が書き改められました。
%% \item 「Dependencies」の節の sect タグに id 属性値 ``dependencies'' が追加されました。
\item Pre-Depends コントロールフィールドについての記述が書き改められました。
\end{itemize}

以下では、左に元の英文、右に日本語訳を並べて、バージョン間での変化を比べてみます。

\clearpage

\subsubsection{ 「Debian GNU/Linux ディストリビューション」が「Debian ディストリビューション」と改められました。}

\vspace{1ex}
\hrule
\subsubsubsection{Version 3.9.1.0 policy.sgml:799}\par
\parbox{0.48\linewidth}{
	  The Debian GNU/Linux distribution is based on the Debian
	  package management system, called {\tt dpkg}. Thus,
	  all packages in the Debian distribution must be provided
	  in the {\tt .deb} file format.
}\hfil 
\parbox{0.48\linewidth}{
	  Debian ディストリビューションは {\tt dpkg}
	  と呼ばれる Debian パッケージ管理システムに基礎を置いています。
	  このため、Debian ディストリビューションに含まれる全てのパッケージは
	   {\tt .deb}ファイル形式で提供されなければなりません。
}
\hrule

\subsubsubsection{Version 3.9.3.1 policy.sgml:836}\par
\parbox{0.48\linewidth}{
	  The Debian distribution is based on the Debian
	  package management system, called {\tt dpkg}. Thus,
	  all packages in the Debian distribution must be provided
	  in the {\tt .deb} file format.
}\hfil 
\parbox{0.48\linewidth}{
	  Debian ディストリビューションは {\tt dpkg}
	  と呼ばれる Debian パッケージ管理システムに基礎を置いています。
	  このため、Debian ディストリビューションに含まれる全てのパッケージは
	   {\tt .deb}ファイル形式で提供されなければなりません。
}
\hrule
\vspace{1ex}

\subsubsection{メンテナの責任について、詳しく具体的な記述が追加されました。}
\vspace{1ex}
\hrule
\subsubsubsection{Version 3.9.1.0 policy.sgml:914}\par
\parbox[t]{0.46\linewidth}{
	    Every package must have a Debian maintainer (the
	    maintainer may be one person or a group of people
	    reachable from a common email address, such as a mailing
	    list).  The maintainer is responsible for ensuring that
	    the package is placed in the appropriate distributions.
}\hfil 
\parbox[t]{0.46\linewidth}{
	    全てのパッケージには一人または一グループの Debian メンテナ
	    (一名の個人であっても、メーリングリストなどの共通の一つのメールアドレスで連絡の取れるグループであってもかまいません) 
	    を持たなければなりません。
	    この人物は、そのパッケージが適切なディストリビューションに収録されていることに対する責任を持ちます。
}
\hrule

\subsubsubsection{Version 3.9.3.1 policy.sgml:951}\par
\parbox[t]{0.46\linewidth}{
	  Every package must have a maintainer, except for orphaned
	  packages as described below.  The maintainer may be one person
	  or a group of people reachable from a common email address, such
	  as a mailing list.  The maintainer is responsible for
	  maintaining the Debian packaging files, evaluating and
	  responding appropriately to reported bugs, uploading new
	  versions of the package (either directly or through a sponsor),
	  ensuring that the package is placed in the appropriate archive
	  area and included in Debian releases as appropriate for the
	  stability and utility of the package, and requesting removal of
	  the package from the Debian distribution if it is no longer
	  useful or maintainable.
}\hfil 
\parbox[t]{0.46\linewidth}{
	    後ほど述べるようなみなしごパッケージを除いて、全てのパッケージには一人または一グループの Debian メンテナを持たなければなりません。
メンテナは一名の個人であっても、メーリングリストなどの共通の一つのメールアドレスで連絡の取れるグループであってもかまいません。
	    この人物は、そのDebianパッケージファイルを保守すること、
	    不具合報告を評価して適切に応答すること、そのパッケージの新しいバージョンを（直接あるいはスポンサーを介して）アップロードすること、そのパッケージが適切なアーカイブ領域に設置されて、そのパッケージの安定性や利便性の観点で適切にDebianのリリースに含められることを保証すること、もはや役に立たないか保守できなくなったらDebian配布物からそのパッケージを削除する要求を出すことに対する責任を負います。
}
\hrule

\clearpage

\subsubsection{メンテナのメールアドレスについて、詳しく具体的な記述が追加されました。}

\vspace{1ex}
\hrule
\subsubsubsection{Version 3.9.1.0 policy.sgml:922}\par
\parbox[t]{0.48\linewidth}{
 	    The maintainer must be specified in the
	    {\tt Maintainer} control field with their correct name
	    and a working email address.  If one person maintains
	    several packages, they should try to avoid having
	    different forms of their name and email address in
	    the {\tt Maintainer} fields of those packages.
}\hfil 
\parbox[t]{0.48\linewidth}{
	    Debian パッケージのメンテナは各パッケージの {\tt Maintainer}
	    コントロールフィールドに、正しい名前と有効な電子メールアドレスの両方により指定されていなければなりません。
	    もしその人がいくつかのパッケージを管理している場合、個々のパッケージの
	    {\tt Maintainer} フィールドに異なった形式の名前と電子メールアドレスを記入することは避けるべきです。
}
\hrule

\subsubsubsection{Version 3.9.3.1 policy.sgml:966}\par
\parbox[t]{0.48\linewidth}{
	  The maintainer must be specified in the {\tt Maintainer}
	  control field with their correct name and a working email
	  address.  The email address given in the {\tt Maintainer}
	  control field must accept mail from those role accounts in
	  Debian used to send automated mails regarding the package.  This
	  includes non-spam mail from the bug-tracking system, all mail
	  from the Debian archive maintenance software, and other role
	  accounts or automated processes that are commonly agreed on by
	  the project.$<$footnote$>$
	    A sample implementation of such a whitelist written for the
	    Mailman mailing list management software is used for mailing
	    lists hosted by alioth.debian.org.
	  $<$/footnote$>$
	  If one person or team maintains several packages, they should
	  use the same form of their name and email address in
	  the {\tt Maintainer} fields of those packages.
}\hfil 
\parbox[t]{0.48\linewidth}{
	    Debian パッケージのメンテナは各パッケージの {\tt Maintainer}
	    コントロールフィールドに、正しい名前と有効な電子メールアドレスの両方により指定されていなければなりません。
	    {\tt Maintainer}コントロールフィールドに書かれた電子メールアドレスは、
	    そのパッケージに関する自動送信メールに使われるDebian内の役割に応じたアカウントの
	    メールを受領できないといけません。
	    これにはバグ追跡システムからの迷惑メールでないメール、Debianアーカイブ保守用ソフトウェアや
	    そのプロジェクトで共通に認められた役割に応じたアカウントもしくは自動処理からのすべてのメールを含みます。
	    $<$footnote$>$
		そのような一例として Mailman メーリングリスト管理ソフトウェア用のホワイトリストが
	      alioth.debian.org でホストされているメーリングリストで使われています。
	    $<$/footnote$>$
	    もし一人の人もしくは一つのチームがいくつかのパッケージを管理している場合、それぞれのパッケージの
	    {\tt Maintainer} フィールドでは同じ形式の名前と電子メールアドレスを記入するべきです。
}
\hrule
\vspace{1ex}

\clearpage

\subsubsection{Uploader コントロールフィールドについての記述が追加されしました。}

\vspace{1ex}
\hrule
\subsubsubsection{Version 3.9.1.0 policy.sgml:}\par
\parbox[t]{0.48\linewidth}{
}\hfil 
\parbox[t]{0.48\linewidth}{
}
\hrule

\subsubsubsection{Version 3.9.3.1 policy.sgml:990}\par
\parbox[t]{0.48\linewidth}{
	  If the maintainer of the package is a team of people with a
	  shared email address, the {\tt Uploaders} control field must
	  be present and must contain at least one human with their
	  personal email address.  See $<$ref id$=$"f-Uploaders"$>$ for the
	  syntax of that field.
}\hfil 
\parbox[t]{0.48\linewidth}{
	    もしパッケージのメンテナが共通のメールアドレスを持つ人々からなるチームなら、
	    少なくとも一人の人物とその人の個人用のメールアドレスが書かれた
	    {\tt Uploaders} コントロールフィールドが必要です。
	    このフィールドの書式については、$<$ref id$=$"f-Uploaders"$>$ を参照してください。
}
\hrule
\vspace{1ex}


\subsubsection{みなしごパッケージについての記述が書き改められました。}

\vspace*{1ex}
\hrule
\subsubsubsection{Version 3.9.1.0 policy.sgml:936}\par
\parbox[t]{0.48\linewidth}{
	  If the maintainer of a package quits from the Debian
	  project, "Debian QA Group"
	  {\it packages@qa.debian.org} takes over the
	  maintainer-ship of the package until someone else
	  volunteers for that task. These packages are called
	  {\em orphaned packages}.$<$footnote$>$
		The detailed procedure for doing this gracefully can
		be found in the Debian Developer's Reference,
		see $<$ref id$=$"related"$>$.
	  $<$/footnote$>$
}\hfil 
\parbox[t]{0.48\linewidth}{
	    もしあるパッケージのメンテナが Debian プロジェクトを辞めたなら、
	    誰か他の人がその仕事に志願するまで Debian QA グループ
	    {\it packages@qa.debian.org}
	    がパッケージの管理を引き継ぎます
	    $<$footnote$>$
		これを丁寧に行うやり方の詳細は Debian Developer's
		Reference (開発者の手引き) に書かれています。
		$<$ref id$=$"related"$>$ を参照ください。
	    $<$/footnote$>$ 。
	    このようなパッケージは {\em orphaned パッケージ}
	    と呼ばれます。
}
\hrule

\subsubsubsection{Version 3.9.3.1 policy.sgml:}\par
\parbox[t]{0.48\linewidth}{
	  An orphaned package is one with no current maintainer.  Orphaned
	  packages should have their {\tt Maintainer} control field set
	  to {\tt Debian QA Group $<$packages@qa.debian.org$>$}.
	  These packages are considered maintained by the Debian project
	  as a whole until someone else volunteers to take over
	  maintenance.$<$footnote$>$
	    The detailed procedure for gracefully orphaning a package can
	    be found in the Debian Developer's Reference
	    (see $<$ref id$=$"related"$>$).
	  $<$/footnote$>$
}\hfil 
\parbox[t]{0.48\linewidth}{
	  みなしごパッケージというのは、現在メンテナが不在のパッケージのことを言います。
	  みなしごパッケージは、その{\tt Maintainer} コントロールフィールドを
	   {\tt Debian QA Group $<$packages@qa.debian.org$>$} に設定することになっています。
          これらのパッケージは、誰が別の人が保守を引き継ぐことを志願するまでは
	   Debian プロジェクト全体で面倒を見ているとみなされます$<$footnote$>$パッケージを丁重にみなしご化するための詳しい手順は Debian Developer's Reference (開発者の手引き)に載っています（$<$ref id$=$"related"$>$を参照のこと）。$<$/footnote$>$。  
}
\hrule
\vspace{1ex}

\clearpage

\subsubsection{Pre-Depends コントロールフィールドについての記述が書き改められました。}

\vspace*{1ex}
\hrule
\subsubsubsection{Version 3.9.1.0 policy.sgml:1082}\par
\parbox[t]{0.48\linewidth}{
	    Sometimes, a package requires another package to be
	    installed {\em and} configured before it can be
	    installed. In this case, you must specify a
	    {\tt Pre-Depends} entry for the package.
            }\hfil 
\parbox[t]{0.48\linewidth}{
	    時々、あるパッケージが、それをインストールする前にもう一つのパッケージがインストールされ
	    {\em かつ} 設定されていることを必要とすることがあります。
	    この場合、そのパッケージには
	    {\tt Pre-Depends} エントリを指定しなければなりません。
}
\hrule

\subsubsubsection{Version 3.9.3.1 policy.sgml:1144}\par
\parbox[t]{0.48\linewidth}{
	  Sometimes, unpacking one package requires that another package
	  be first unpacked {\em and} configured.  In this case, the
	  depending package must specify this dependency in
	  the {\tt Pre-Depends} control field.
}\hfil 
\parbox[t]{0.48\linewidth}{
	    時々、あるパッケージを展開するためには、先に別のもう一つのパッケージが展開され
	    {\em かつ} 設定されていないといけない場合があります。
	    この場合、依存する側のパッケージに {\tt Pre-Depends} コントロールフィールドで
	    この依存関係を指定しなければなりません。
}
\hrule
\vspace{1ex}



\subsection{引用元}

\begin{list}{}{\setlength{\itemindent}{-2em}\setlength{\itemsep}{1ex plus 1ex}}
\item ``Debian Policy Manual '', Ian Jackson ,  Christian Schwarz, and other contributors,\hfill \\  {\it git://git.debian.org/git/dbnpolicy/policy.git} ,Debian Project, 1996-

\item ``Debian ポリシーマニュアル'', 八田真行, かねこ, 森本\hfill \\ {\it https://svn.debian.or.jp/repos/www/trunk/src/community/devel/debian-policy-ja/policy.ja.sgml} , Debian JP Project, 
\end{list}

\subsection{最後に}
次回の月刊 Debian Policy は。。。


%% -*-tex-*-
%%
%% Copyright (C) 2012 Hiroshi Kubo  all rights reserved.
%% 本資料の著作権は、著者である久保博 <h-kubo@geisya.or.jp> にあります。
%%
%% This document material is licensed under the GNU General Public License version 2.0.
%% This document is originally in the form of LaTeX source code. This shall be referenced as the ``Corresponding Source''
%% Any compiled forms including DVI, Postscript, and PDF from the original source code shall be reference as the ``Object code''.
%%

%-------------------------------------------------------------------------------
\dancersection{フリーソフトウェアと戯れるための著作権入門}{山城国の住人 \  久保博}
%-------------------------------------------------------------------------------
\index{Free software}
\index{ちょさくけん@著作権}

\subsection{前書き}

人生のいきがかり上、割と最近になって著作権の勉強を始めることになりました。
法律の専門家ではありませんので、自信を持っての発表ではないですが、
みなさんと一緒に考えていくきっかけになればと思います。

\subsection{はじめに}

日本を含む多くの国で、ソフトウェアは、生み出された時から著作権という権利の対象になっています。

ですから、フリーソフトウェアも、生まれた時から誰かのもの、ということになっています。
フリーであっても誰かのものである、という点では、登記された土地は空き地であっても誰かのものであるのとにているかも知れません。

フリーソフトウェアの精神は、一介の利用者が自分自身のためにソフトウェアを使うことを
妨げるようなことは最大限避けるようにしていますから、自分自身のためにフリーソフトウェアを使う限り、
知らなくても困ったことにはなりません。

でも、そこから一歩踏み出そうとすれば、誰かのものであるということを尊重することが求められることになります。
この要請は、著作権法と、それを前提とする契約に基づいています。

そこで、Debian Project が配布しているようなフリーソフトウェアを扱う場面をいくつか想定して、
そこに著作権と契約がどのように関わってくるのか、解き明かしてみます。なお、日本の著作権法を元にしてお話します。



\subsection{知的財産権}

ソフトウェアが誰かのものである、とは、どういうことでしょう。

知的な作業を通して創り出された、無体物（プログラムを含む）には、
創り出した人の努力や労力に報いるために、さまざまな制度を定める法律が整備されています。
その中でも、知的な創造によってつくり出された無体物に対して、
財産権の対象となる有体物の物権に良く似た権利を設定する仕組みが法律で定められています。
この物権に似た権利を知的財産権といいます。
そして、知的財産権は、創造した人あるいは登録した人が享受する権利なのです。

これが、ソフトウェアが誰かのものである、ということの、現代社会における意味です。

ソフトウェアが関係する知的財産権には、次のものがあります。

\begin{itemize}
\item[{\bf{著作権}}] 「思想又は感情を創作的に表現したものであつて、文芸、学術、美術又は音楽の範囲に属するもの」に対する独占的な保護をもたらす権利
\item[{\bf{特許権}}]  発明（自然法則を利用した技術的思想の創作のうち、高度なもの）を登録することによって独占的な保護をもたらす権利
\item[{\bf{実用新案権}}] 考案（自然法則を利用した技術的思想の創作）を登録することによって独占的な保護をもたらす権利
\item[{\bf{意匠権}}] 意匠（物品の形状、模様若しくは色彩またはこれらの結合であって、視覚を通じて美感を起こさせるもの）を登録することによって独占的な保護をもたらす権利
\item[{\bf{商標権}}] 商標を登録することによって独占的な保護をもたらす権利
\end{itemize}

プログラムそのものは、著作権の対象になります。
また、プログラムで実装されたアルゴリズムは特許や実用新案の保護の対象になり得る場合がありますし、プログラムの名称やロゴは商標としての保護の対象になり得ます\footnote{Debian も電子計算機などの指定商品での商標登録がされており、登録番号は 第４５９５２８８号です。ちなみに、指定商品「菓子、パン」で「デビアン」という称呼の登録番号第１７０８０３２号の登録商標があります。面白いですね。}。
GUIの画面のデザインは海外では意匠登録の対象となり得る場合もあるようですが、日本では今のところ対象ではありません。

この中でも、ソフトウェアについて一番よく問題になるのは、著作権です。

\subsection{著作権}
\subsubsection{著作権の性質}

正確ではないですが端的に言えば、著作権法は、著作物を作った人に著作物に対する独占的な権利を与える法律です。
その著作権法で定められている著作権には次のような性質があります。

\begin{itemize}
\item 著作物を作ったら、発生します。
\item 著作物を公表しなくても発生します。
\item （特許と違って、）役所に登録しなくても発生します\footnote{このような権利の発生のさせ方を無方式主義と言います。なお、かつてアメリカは、無方式主義ではありませんでした。}。
\item 著作物が生まれてから、著作者の死後50年間、著作権の保護は続きます。
\item 他人が著作物を勝手に利用した場合、差止請求権、損害賠償請求権を行使するという方法で対抗できます\footnote{著作権法第百十四条に基づいて損害額を推定しても、フリーソフトウェアの場合、0円にしかならないですが…。}。
\end{itemize}
ですから、新しいプログラムが作られれば、必ずと言っていいほど著作権が関係してきます。

逆に言えば、著作物をパブリックドメインとするためには、著作権を放棄する手続きなどが必要になるわけです。
また、著作物を利用するには、著作権者から利用許諾をもらうべし、というのが著作権法に則った正しい方法です。

したがって、ソフトウェアとともに
\begin{itemize}
\item 著作権に基づく利用許諾契約書
\item 著作権を放棄する宣言あるいは放棄済であることの明示的な説明
\end{itemize}
のどちらかを手に入れないと、著作権法に違反していない確信を持ってソフトウェアを使うことが難しい、ということになります。
Debian Project は、社会契約\cite{DebianSocialContract}に基づいて行動しており、この点に関して厳密に考えてパッケージを作っているわけです。

\subsubsection{著作権の存続期間}

権利が有効である時間の範囲を存続期間と言います。

「著作者が死んでも著作権の保護が続くってどういうこと?」と不思議に思うかも知れませんね。
 著作権は相続できるのです。相続する人があれば、続くんです。
相続を含めて、権利を引き継ぐことを「承継」と言います。
承継する人がなければ、著作権は消滅します。

\par
\begin{center}
\fbox{
\parbox{0.8\linewidth}{
\begin{center}{\Large\bf 筆者からお願い！}\\
あなたが作って公開しているプログラム、\linebreak[1]あなたの死後に誰が著作権を相続するか予め周りの人に教えておいて下さい。
\end{center}
}
}
\end{center}
\par


なお、FSF\footnote{Free Sofware Foundation. ウェブサイトは {\url http://www.fsf.org/}}は、FSFへ著作権を譲渡することを勧めています\cite{FSFassign}。著作者の死後、GPL\footnote{GNU General Public License}で公開したフリーソフトウェアの行く末を託すこともできますね\footnote{著作権の譲渡に関しては、日本の著作権法には第三者対抗要件に登録が必要などの難しい話が関係するので、筆者はどうしたらいいのか、理解できていません。}。

\subsubsection{著作権の内訳}

著作権とは、権利の束みたいなものです。著作物を利用する方法などによって、細かい権利が定められています。

それらは大別すると、「著作人格権」と「著作財産権」に分かれ、それぞれの下に次のような権利が条文で定められています。

\begin{description}
\item[著作人格権]「公表権」「氏名表示権」「同一性保持権」
\item[著作権（著作財産権）]「複製権」「上演権」「演奏権」「上映権」「公衆送信権」「伝達権」「口述権」「展示権」「頒布権」「譲渡権」「貸与権」「翻訳権」「翻案権」「二次的著作物の利用に関する権利 」
\end{description}

この中には、ソフトウェアが関係しないものもあります。

\subsection{Debian Project が配布しているものの何が著作物?}

さて、著作物とはどんなものがあるか、著作権法を読んでみると、次のようなことが書いてあります。

著作物とは、「思想又は感情を創作的に表現したものであつて、文芸、学術、美術又は音楽の範囲に属するものをいう。」
（著作権法第二条）


更に、著作権法では、例を挙げて著作物を定義しています。

\begin{verbatim}
第十条　この法律にいう著作物を例示すると、おおむね次のとおりである。
　 	一　小説、脚本、論文、講演その他の言語の著作物
　 	二　音楽の著作物
　 	三　舞踊又は無言劇の著作物
　 	四　絵画、版画、彫刻その他の美術の著作物
　 	五　建築の著作物
　 	六　地図又は学術的な性質を有する図面、図表、模型その他の図形の著作物
　 	七　映画の著作物
　 	八　写真の著作物
　 	九　プログラムの著作物

2　事実の伝達にすぎない雑報及び時事の報道は、前項第一号に掲げる著作物に該当しない。

3　第一項第九号に掲げる著作物に対するこの法律による保護は、その著作物を作成するために用いるプログラム言語、規約及び解法に及ばない。この場合において、これらの用語の意義は、次の各号に定めるところによる。
　 	一　プログラム言語 プログラムを表現する手段としての文字その他の記号及びその体系をいう。
　 	二　規約 特定のプログラムにおける前号のプログラム言語の用法についての特別の約束をいう。
　 	三　解法 プログラムにおける電子計算機に対する指令の組合せの方法をいう。
\end{verbatim}

ということで、プログラムは、プログラム著作物です。オブジェクトコードもプログラム著作物である、という判例もあるようです\footnote{東京地判昭和60年3月8日判タ 561号 169頁「ディグダグ」事件 という判例があるそうです\cite{saito}。}。

また、Debian Project が配布するものにはプログラム以外にも、文章、写真画像、地図データなどありますが、著作物です。


\subsection{著作権を踏まえた Debian Project からの配布物とのおつき合い}


\subsubsection{著作権のことを気にせずに Debian のシステムをインストールしました。何かまずいことをしていないでしょうか?}

自分で使う目的でインストールしたのですよね?

インストールする前に利用許諾契約を読んで、同意して、それからインストールするのが理想的ですが、そうでない場合もよくあるかと思います。

Debian Project が配っているインストーラーを使って普通にインストールしたなら、
インストールしたソフトウェアの利用許諾契約に同意したことにしましょう。
インストーラーでインストールしたソフトウェアはすべて DFSG\footnote{The Debian Free Software Guidelines\cite{DFSG}} に準拠しているので、ほとんどあなたは不利益を被っていません。

\begin{itemize}
\item 金銭的な対価は要求されません。
\item 使うだけなら無償の貢献も要求されません。
\item あなたの某かの権利を放棄したり断念したり譲渡したりすることもありません。
\end{itemize}

なにか気をつけることがあるとすれば、免責条項くらいでしょうか。

 ほぼすべてのフリーソフトウェアの利用許諾では、その動作に関して無保証で、免責条項が盛り込まれています\footnote{フリーでなくても、無保証である場合が多いですし、保証はあっても賠償額の上限をソフトウェア購入代金とすることも珍しくありません。}。
無保証であることに関する同意は、ほとんどのソフトウェアが採用している利用許諾の契約の条項の一部です。同意できないなら、利用する権利はありません。

したがって、著作者に対して、次に掲げることについて何の文句をつける筋合いもありません。
\begin{itemize}
\item  期待通りに動かない
\item  そもそも動かない
\item  ソフトウェアを使ったせいで、地位や財産を失った
\item  ソフトウェアを信じたせいで、地位や財産を失った
%%\item  ソフトウェアを使ったせいで、心が傷ついた
\end{itemize}

%% ここで BTS の話を一席
でも、多くのフリーソフトウェアの開発元や Debian Project には、バグ報告の窓口がありますね。
あれは、義務でやっているのでないのです。大いなる親切以外の何物でもありません。


%% \subsubsection{知合いのパソコンに Debian のシステムをインストールしました。}

%% そのパソコンを利用する持ち主の方に、利用許諾書に同意してもらいましょう。
%% 別に、書類に判子をつくような手続きは必要ありません。

%% 全部を理解してもらうのはなかなか困難だとは思いますが、
%% 自分のために使って、うまくいかなくても作者の方々に文句をいう筋合いはないことに納得してもらえれば実際上は十分です。


\subsubsection{Debian のフリーソフトウェアを使わないけど配ります。}

ちょっと待って! あなたは、著作者と契約を結ばなくてはなりません!

著作権には「複製権」「自動公衆送信権」「送信可能化権」という権利が含まれているのです。
極めて簡単に分かりやすくいうと
\begin{description}
\item[複製権 ] 簡単にいうと、コピーする権利。
\item[自動公衆送信権] 公衆に送信する権利。
\item[送信可能化権] 公衆がアクセスしてダウンロードできるサーバーに著作物を置く権利。
\end{description}
です。
著作者が独占的に保持する権利ですから、あなたは、ソフトウェアを配ったり、公開されているサイトにアップロードする前には、著作者の許可が必要です。


でも実は、Debian アーカイブの main セクションと contrib セクションに含まれるソフトウェアのソースコードを
{\em そのまま}無料で配布する場合は、利用許諾に同意する必要はあるものの、
実質的には何らかの義務や制約に縛られることはありませんので、
ほとんど気にかける必要はないです。

というのも、main と contrib に含まれるソフトウェアは、すべて DFSG\cite{DFSG} に準拠してます。
DFSG に準拠しているこということは、ソースコードの自由な配布が利用許諾契約上、認められていることになるのです。

これに対して、バイナリパッケージを配布する場合は、配布先でソースコードが手に入れることができるように配慮しないといけないライセンスが多いです\footnote{GPL や LGPL (GNU Lesser General Public License)  が典型的な例です。}。
ソースコードが入手できるような配布を強制することで、ソフトウェアの自由を担保しようとしているわけです。
注意しましょう。


また、利用許諾の内容を理解する前に、適当に一部を削ったり、一部を抜き出して配らないようにしましょう。
というのも、著作権には「同一性保持権」という権利があります。
勝手に削ることも含めて、著作物を勝手に改変することは著作権法が禁じています。
改変に際しては許諾が必要で、許諾された範囲での改変しか許されません。

幸い、 DFSG準拠なら改変は許されますし、改変されたソフトウェアの複製を配布することも許されますが、
契約毎に許されるための条件はあります。

それから、勝手に著作者の氏名を削ってはいけません。
「氏名表示権」を侵害することになります。

\par\begin{center}{\Large そのまま配るのが一番無難です。}\end{center}

\subsubsection{Debian をインストールされてるパソコンをもらいました}

一般的に、正規の方法で入手したソフトウェアを手元にコピーを残さずに誰かに譲り渡すことは構わないのですが、
パソコンをもらっただけでは、そのパソコンにインストールされているソフトウェアを無条件に使っていいことにはなりません。
くれた人は「好きにしていいよ」と言ってくれていても、利用許諾の契約には同意して利用しましょう。

物品の譲渡と一緒に著作権の利用許諾がなされたとみなせる場合というのは、
特別に著作権法に明記されています\footnote{美術品の展示権など。}。
原則として、物品の譲渡とそこに宿っている著作物の利用許諾とは、別ものなのです。

ちなみに、ソフトウェアの利用許諾書にはしばしば non-transferable という言葉で、
利用権の譲渡を明示的に禁止する文言が現れますが、その場合は、契約上利用権を譲渡できないことになっています。

\subsection{特許との関係}

利用許諾書には、著作権ではない別の知的財産権に基づく利用許諾が含まれる場合があります。
よく使われる「ライセンス」と言う言葉に含まれる、利用許諾の根拠になる権利は著作権だけとは限らないわけです。

例えば、DFSG準拠の利用許諾の中には、特許に関する条項が含まれているものがあり、
その代表的なものには、 Apache License 2.0 と、 GPL 3.0 があります。

この二つの利用許諾には、ともに、「ソースコードの貢献者が保有する特許のうち、ある範囲のものは、無償で利用を許諾する、」という趣旨の条項が含まれています。
Apache License 2.0 は、貢献者が自分の貢献したコードに含まれる特許を利用許諾するのに対し、
 GPL 3.0 では、貢献者が配布したコードに含まれる特許を利用許諾する点が違います。


\subsection{その他関係する法律}

最後に、ソフトウェアが関係しそうな法律をいくつか挙げておきます。

\begin{itemize}
\item 不正アクセス禁止法
\item 不正競争防止法
\item 刑法のいわゆるウィルス作成罪
\item 関税法
\item 民法
%% \item PL法
\end{itemize}


\subsection{宿題}

次の問題に答えてみましょう。

\begin{itemize}
\item 「アルゴリズム体操」の振付けは、著作権法第十条の何の著作物でしょうか?
\item GCC (GNU Compiler Collection) は、プログラムの著作物として保護されるでしょうか?
\item 著作権（著作財産権）のうち、ソフトウェアに関係あるものを挙げてみましょう。
\item かつて特許によって自由な配布が制限されたソフトウェアがありました。どんなものがあるか、調べてみましょう。
\end{itemize}



\subsection{まとめ}


フリーソフトウェアに関わる著作権の仕組みを簡単に解説しました。

\begin{thebibliography}{99}
    \bibitem{DebianSocialContract} Debian 社会契約,
                    \url{http://www.debian.org/social\_contract}

    \bibitem{DFSG} The Debian Free Software Guidelines,
    \url{http://www.debian.org/social\_contract\#guidelines}

    \bibitem{CopyrightLaw} 著作件法 ,
                    {\url http://law.e-gov.go.jp/htmldata/S45/S45HO048.html}

    \bibitem{FSFassign} なぜFSFは貢献者に著作権の譲渡をお願いしているのか {\url http://www.gnu.org/licenses/why-assign.html}

    \bibitem{GPLv3chikujou} GPLv3 逐条解説
      \url{http://ossipedia.ipa.go.jp/DL/doc/187/5/0904/ON/}

    \bibitem{saito} 著作権法 , 斉藤博, 2000年, 有斐閣

\end{thebibliography}

\clearpage

\clearpage
%-------------------------------------------------------------------------------
\dancersection{ITP から始めるパッケージメンテナへの道}{よしだ ともひろ}
%-------------------------------------------------------------------------------
\index{ITP}
\index{Package Maintainer}
\index{ぱっけーじめんてな@パッケージメンテナ}

\subsection{はじめに}
とある便利なソフトウェアを見つけて、それがまだDebianパッケージになっていなかった
とき、RFP(Request For Package:パッケージ化の要求)をしてもよいのですが、自分でパッ
ケージ化してDebianの一部として提供することもできます。そこで、ITP(Intent To Package:
パッケージ化の宣言)〜アップロードまでの流れをまとめてみました。

\subsection{まずはITP}
\subsubsection{ITPの前に必要なこと}
\subsubsubsection{既にパッケージ化されていないか？}
\url{http://www.debian.org/distrib/packages}で探してみたり、aptitude searchや
apt-cache searchで確認してみましょう。

\subsubsubsection{既にITPされていないか？}
他の誰かが同じようにパッケージ化しようと思って、ITPしているかもしれません。

\url{http://www.debian.org/devel/wnpp/being\_packaged}をチェックしてみましょう。

\subsubsubsection{既にRFPされていないか？}
他の誰かが、パッケージ化して欲しいと思って、RFPしているかもしれません。
RFPされている場合は、ITPすることでパッケージ化の宣言を行います。

\url{http://www.debian.org/devel/wnpp/requested}をチェックしてみましょう。

\subsection{ITPの仕方}
パッケージをITPするのはreportbug(apt-get|aptitude install reportbug)で行う方法が
\url{http://www.debian.org/devel/wnpp/}で紹介されています。また、電子メールでも
行うことができます。ここでは、電子メールでITPを行う方法の一つ、Mewを使う方法を
紹介します。

まず、debian-elパッケージをインストールします。

\begin{commandline}
   $ sudo aptitude install debian-el
\end{commandline}
%$ for emacs font-lock
 
   次に~/.emacsに以下を追加します。

\begin{commandline}
(autoload 'mew "mew" nil t)
(autoload 'mew-send "mew" nil t)

(if (boundp 'read-mail-command)
	(setq read-mail-command 'mew))
(autoload 'mew-user-agent-compose "mew" nil t)
(if (boundp 'mail-user-agent)
	(setq mail-user-agent 'mew-user-agent))
(if (fboundp 'define-mail-user-agent)
	(define-mail-user-agent
		'mew-user-agent
		'mew-user-agent-compose
		'mew-draft-send-message
		'mew-draft-kill
		'mew-send-hook))
\end{commandline}

こうしておいてemacsを起動し、M-x debian-bug RETとします。
ミニバッファに

\begin{commandline}
Report a bug for a [P]ackage or [F]ile: (default P) 
\end{commandline}

と表示されるので"P"を入力します。

パッケージ名を聞いてきますのでwnppと入力します。wnppというのはWork-Needing and
Prospective Packages(作業が望まれるパッケージ)という擬似パッケージのことで、ITP
やRFPを行うときに使用する他、RFH(Request For Help:助力の要求)、RFA(Request For
Adoption:養子引き取りの要求)、O(Orphan:みなしご)、ITA(Intent To Adopt:養子引き
取りの表明)にも使います。

次にActionを聞かれます。TABを押すと候補が表示されますのでITPとします。

あとは、パッケージ名、パッケージの簡単な説明を入力します。debian-develへCCするか？
も聞かれますので"y"と入力するとメールの雛形が表示されますので、残りのVersion、
Upstream Author、URL or Web page、Licenseを入力してメールを送信します。

\subsection{GnuPGキーサイン}
Debian公式パッケージにするにはdscファイルとchangesファイルに署名が必要です。
GnuPG(GPG)で署名しますが、信頼された鍵でないと意味がないのでキーサインパーティな
どでDebian開発者の方とキーサインをしておきましょう。GPG公開鍵は後に説明する
mentors.debian.netを使う時にも必要ですので、まだ、作成していない方は作っておくこ
とをおすすめします。

6月23日(土)の大統一Debian勉強会でもキーサインパーティが予定されていますので、
是非参加しましょう。

\subsection{パッケージ作成}
パッケージの作成方法は過去のDebian勉強会などでも何度か紹介されていますので、
ここでは詳細は割愛し注意する箇所のみとします。

\subsubsection{lintian cleanにする}
lintianはDebianパッケージを精査し、バグやポリシー違反を報告します。アップロードす
る前に、必ずそのパッケージに対してlintianを実行してください。lintianを実行する際
はオプションの -v を付けてchangesファイルを指定します。lintianが出力する情報がわ
かりにくければ -i オプションを追加しましょう。出力される情報に "E:" や "W:"がなく
なるように修正し、lintian cleanにしましょう。

\subsubsection{パッケージに署名する}
お試しでパッケージを作ったりする場合はパッケージへの署名を省略しますが、公式パッ
ケージにするにはちゃんと署名することが必要です。debuildやdpkg-buildpackageで-us -uc
オプションをつけずにパッケージ作成すると、dscファイルとchangesファイルにGnuPGで署
名すためのパスフレーズを聞いてきますので入力すればOKです。

\subsection{mentors.debian.netへ登録}
\subsubsection{mentors.debian.netとは}
Debianへのパッケージアップロード権限はDebian開発者のみが持っているのですが、Debian
開発者でない人もアップーロードできる仕組みがあります。Debian開発者の方にスポンサー
になっていただいて、助言をいただきながら修正していく場、といった感じです。

\subsubsection{サインアップ}
\url{http://mentors.debian.net/}に"Sign me up"という
\url{http://mentors.debian.net/register/register}へのリンクがありますのでクリック
します。

Full name, E-mail, Password, Confirm passwordを入力し、Account typeはMaintainerを
選択してSubmitを押下します。入力したE-mail Addressへ確認のメールが飛んできますの
で、記載されたURLへアクセスしてActivateするとアカウントが使用可能になります。

ログインして、My accountページのChange GPG keyでGPGキーを登録できますのでアスキー
形式でエクスポートした公開鍵のファイルを選択して登録しておきます。

\subsubsection{アップロード}
mentors.debian.netにアップロードする方法は、duploadやdputなどのツールで行えます。
今回はdputで行う方法をご紹介します。

\begin{enumerate}
\item 準備

\textasciitilde/.dput.cfを作ります。内容は\url{http://mentors.debian.net/intro-maintainers}を
参考にしました。httpとftpの設定が記載されているのですが、httpの設定としました。
こんな感じです。

\begin{commandline}
[mentors]
fqdn = mentors.debian.net
incoming = /upload
method = http
allow_unsigned_uploads = 0
progress_indicator = 2
# Allow uploads for UNRELEASED packages
allowed_distributions = .*
\end{commandline}

\item さあ、アップロード

いよいよアップロードです。dput mentors changesファイル で行います。ここまでのパッ
ケージ作成で問題がなければmentors.debian.netへのアップロードは成功するはずです。

しばらくするとmentors.debian.netからメールが飛んできます。メールの内容は「スポン
サーが必要ならスポンサーを探してるにしろ」とか、「RFS(request for sponsorship)で
スポンサーを募集できるよ」というような内容ですので従います。
\end{enumerate}

\subsection{スポンサーを探す}
無事 mentors.debian.net へアップロードできたら debian-mentors@lists.debian.org や
debian-devel@debian.or.jp にRFS(request for sponsorship)を投げて、スポンサーになっ
てくれる方を探しましょう。

\subsection{おわりに}
今回、はじめてITPして、mentors.debian.netにアップロードしてみました。色々調べたり
しながらでしたので時間はかかりましたが、それほど難しくはないと思います。Debianパッ
ケージになっていないソフトウェアを見つけたら是非ITPしましょう！

\clearpage

%-------------------------------------------------------------------------------
% 執筆者紹介。ページが足りていれば追加。ないなら消す。調整用として使う。
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\dancersection{執筆者紹介}{}
%-------------------------------------------------------------------------------

本号の執筆に参加したメンバを紹介します。
\begin{multicols}{2}
 \begin{description}
  \item[名前]
             ひとこと
 \end{description}
\end{multicols}

% FIXME: quizを追加すること
\dancersection{Debian Trivia Quiz}{上川 純一}

ところで、みなさん Debian 関連の話題においついていますか？Debian関連の話
題はメーリングリストをよんでいると追跡できます。ただよんでいるだけではは
りあいがないので、理解度のテストをします。特に一人だけでは意味がわからな
いところもあるかも知れません。みんなで一緒に読んでみましょう。


\begin{multicols}{2}
 \input{image2012-natsu/quiz.tex}
\end{multicols}

% 問題と回答が同じみひらきにならないようにする
\cleartoevenpage
\dancersection{Debian Trivia Quiz 問題回答}{上川 純一}

 Debian Trivia Quiz の問題回答です。
 あなたは何問わかりましたか？
 \\
 %回答はdebianmeetingresume2010-natsu.jqzというファイルに生成されるので、
 %それを手動でコピペして使う。
 % ここからコピペ
 % FIXME 問題が全部はいったらコピペすること
 %(progn (next-line 1)(insert-file "debianmeetingresume2011-natsu.jqz") )

%-------------------------------------------------------------------------------------
%% Footer
%-------------------------------------------------------------------------------------

\printindex

% add page to even number multiple of 4.
%\newpage
%\thispagestyle{empty}\mbox{}
\newpage
\thispagestyle{empty}\mbox{}%裏表紙の裏側のページ、色紙
\newpage
\cleartoevenpage

\thispagestyle{empty}
{
\large
\begin{itembox}{\bf 『あんどきゅめんてっど でびあん』について}
本書は、東京および関西周辺で毎月行なわれている『東京エリア Debian 勉強会』（第83回から第88回）および
『関西 Debian 勉強会』（第54回から第58回）、福岡で行われた『福岡Debian勉強会』、そして『大統一Debian勉強会』で
使用された資料・小ネタ・必殺技などを一冊にまとめたものです。
% FIXME: 回数を修正すること。
内容は無保証、つっこみなどがあれば勉強会にて。
\end{itembox}
}

\vspace*{15cm}
{\color{dancerlightblue}\rule{\hsize}{1mm}}
\vspace{2mm}
\includegraphics[width=2cm]{image200502/openlogo-nd.eps}
\noindent \Large \bf あんどきゅめんてっど でびあん 2012年夏号\\
\noindent \normalfont 2012年06月23日 \hspace{5mm}  初版第1刷発行\\
\noindent \normalfont 東京エリア Debian 勉強会/関西エリア Debian 勉強会 （編集・印刷・発行）\\
{\color{dancerdarkblue}\rule{\hsize}{1mm}}

\end{document}
