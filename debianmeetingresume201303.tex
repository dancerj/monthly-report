%; whizzy chapter　-dvi
% -initex iniptex -latex platex -format platex -bibtex jbibtex -fmt fmt
% 以上 whizzytex を使用する場合の設定。

%     Tokyo Debian Meeting resources
%     Copyright (C) 2012 Junichi Uekawa
%     Copyright (C) 2011 Nobuhiro Iwamatsu

%     This program is free software; you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation; either version 2 of the License, or
%     (at your option) any later version.

%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.

%     You should have received a copy of the GNU General Public License
%     along with this program; if not, write to the Free Software
%     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

%  preview (shell-command (concat "evince " (replace-regexp-in-string "tex$" "pdf"(buffer-file-name)) "&"))
% 画像ファイルを処理するためにはebbを利用してboundingboxを作成。
%(shell-command "cd image201201; ebb *.png")

%%ここからヘッダ開始。

\documentclass[mingoth,a4paper]{jsarticle}
\usepackage{monthlyreport}

% 日付を定義する、毎月変わります。
\newcommand{\debmtgyear}{2013}
\newcommand{\debmtgmonth}{3}
\newcommand{\debmtgdate}{16}
% started from zero:
% (let ((year 2013) (month 3)) (+ (* (- year 2005) 12) month -1))
\newcommand{\debmtgnumber}{98}

\begin{document}

\begin{titlepage}
\thispagestyle{empty}
% タイトルページ:編集必要な部分は最初のマクロに飛ばすこと

\vspace*{-2cm}
第\debmtgnumber{}回 東京エリア Debian 勉強会資料\\
\hspace*{-2cm}
\includegraphics{image2012-natsu/dotdeb.pdf}\\
\hfill{}\debmtgyear{}年\debmtgmonth{}月\debmtgdate{}日

% ここはアップデートすること
% 全角文字にしないとフォントのサイズが合わないので注意
\rotatebox{10}{\fontsize{32}{32} {\gt 特集１：　ＸＹＺ}}

\rotatebox{10}{\fontsize{32}{32} {\gt 特集２： }}

\vspace*{-2cm}
\hfill{}\includegraphics[height=6cm]{image200502/openlogo-nd.eps}
\end{titlepage}

\dancersection{Introduction}{上川 純一}

\begin{multicols}{2}
 

 今月のDebian勉強会へようこそ。これからDebianの世界にあしを踏み入れると
 いう方も、すでにどっぷりとつかっているという方も、月に一回Debianについ
 て語りませんか？

 Debian勉強会の目的は下記です。

 \begin{itemize}
 \item \underline{Debian Developer} (開発者)の育成。
 \item 日本語での「\underline{開発に関する情報}」を整理してまとめ、アップデートする。
 \item \underline{場}の提供。
 \begin{itemize}
  \item 普段ばらばらな場所にいる人々が face-to-face で出会える場を提供
	する。
  \item Debian のためになることを語る場を提供する。
  \item Debianについて語る場を提供する。
 \end{itemize}
 \end{itemize}		

 Debianの勉強会ということで究極的には参加者全員がDebian Packageをがりがり
 と作るスーパーハッカーになった姿を妄想しています。情報の共有・活用を通し
 て Debianの今後の能動的な展開への土台として、「場」としての空間を提供す
 るのが目的です。

２０１３年の計画は下記です：
\begin{enumerate}
  \item 2013年の計画立案
 \item OSC 東京 nojima 
 \item UEFI・セキュアブートをDebianでどうやるか
 \item セキュアOS再入門
 \item Debianで自動化の夢は見れるか -- データセンターで OS のインストールからアプリのデプ
       ロイ、サービス公開まで
 \item amazon AWS での Debian 入門
 \item スイスでキャンプ
 \item Debian でスクリプト言語のパッケージ： perl, ruby, python
 \item Debian で apache 2.4: サーバ構築、Apache module プログラミング
 \item Raspberry Pi 、 SheevaBox、Freedombox は今
 \item 自由なFPGA
 \item 一年間の反省
\end{enumerate}


\end{multicols}

\newpage

\begin{minipage}[b]{0.2\hsize}
 \definecolor{titleback}{gray}{0.9}
 \colorbox{titleback}{\rotatebox{90}{\fontsize{80}{80} {\gt デビアン勉強会} }}
\end{minipage}
\begin{minipage}[b]{0.8\hsize}
\hrule
\vspace{2mm}
\hrule
\begin{multicols}{2}
\tableofcontents
\end{multicols}
\vspace{2mm}
\hrule
\end{minipage}

\dancersection{事前課題}{上川 純一}

今回の事前課題は以下です:
\begin{enumerate}
 \item Debianでここがバグってるかも？という事について列挙ください。
 \item 使ったことのある/使ってみたいデバッガについて語って下さい。
 \item LDAPのシステムを管理していますか？している場合は、slapd.confとslapd-configどちらを使っていますか？その理由は？
\end{enumerate}
この課題に対して提出いただいた内容は以下です。
\begin{multicols}{2}
{\small
 \input{image201303/prework.tex}
}
\end{multicols}

\dancersection{Debian Trivia Quiz}{上川純一}

ところで、みなさん Debian 関連の話題においついていますか？Debian関連の話
題はメーリングリストをよんでいると追跡できます。ただよんでいるだけではは
りあいがないので、理解度のテストをします。特に一人だけでは意味がわからな
いところもあるかも知れません。みんなで一緒に読んでみましょう。

今回の出題範囲は\url{debian-devel-announce@lists.debian.org} や \url{debian-devel@lists.debian.org}に投稿された
内容とDebian Project Newsからです。

\begin{multicols}{2}
% \input{image201303/quiz.tex}
\end{multicols}

\dancersection{最近のDebian関連のミーティング報告}{上川純一}
\subsection{東京エリアDebian勉強会96回目報告}

２０１３年最初の東京エリアDebian勉強会はスクエアエニックスさんのオフィス
を間借りして開催しました。
参加者は
yy\_y\_ja\_jpさん、キタハラさん、dictossさん、koedoyoshidaさん、daiさん、
yamamotoさん、まえださん、上川さん、野島さん(＋他会場お手伝い２名）
でした。

野島さん主催のDWN Quizは今回は数が少ないが難問でいい感じした。

事前課題の紹介は２０１５年の予想と２０１３年にやりたいことの提案でした。
いろいろと妄想しているのがわかりました。

全員でグループワークとして、２０１５年の予想、２０１３年の計画を行いまし
た。過去に予想した未来の確認と、あらためて今後３年間の妄想をぶつけあいま
した。

{% \tiny
\footnotesize
\begin{tabular}[t]{|p{8em}|p{14em}|p{10em}|p{8em}|p{10em}|}
%\begin{tabular}[t]{|p{8.5em}|p{12em}|p{8em}|p{6em}|p{8em}|}
\hline
2011 &2012 & 2013 & 2014 & 2015 \\
\hline
 %2011

 デスクトップパソコン終了の潮流。

 cpuコア単体では高速化しないように。

 webos終了のお知らせ。

 adobe flash復活のお知らせ(キタ), silverlight終了のお知らせ(台湾を除く)(続いてる?)

 squeezeリリース(おめでとう)

 ipv4割り当ての終了のお知らせ(キタ)

 地上波デジタル移行延長。

 btrfsまだ頑張る(fedora乙)

 java終了(sun java終了)

 open officeがoracle officeに(ナイ)

 &
 %2012

 ノートパソコンよりタブレットのほうが売れている。
 ノートパソコンではmacbookairが常識に。

 ノートパソコンでintelじゃないもの(mips/arm)が主流にはまだならず。タブレッ
 トのほうが主流。

 デスクトップ:ゲーム以外の用途では終了している。

 サーバ:個人レベルではVPS常識。企業ユースでもcloud か、vpsかを自前と比較
     検討する時代。データセンターを置く国を選べる時代。

 携帯電話:
 ガラパゴスの終焉。日本での携帯電話販売でもスマートフォンが５０％を超えるように。
     ガラケー向けのネットバンクの提供が終了など、ガラケーからサービスが
     撤退し始める。
 LTE登場、普及しはじめたが、主流になっていない。
 softbankの二年契約はまだ続いている。sim freeへの道は耕されたがあたり前にならなかった。

 btrfsはまだ生き残っているがまだ使われてない？

     openstack で ceph 使う人もいる？

 mysqlからmariadbが派生。

 & 
 % 2013

コンシューマーはノートパソコンを買わなくなった。
ノートパソコンのかわりにスマートフォンを使っている。

スマートフォンが7インチくらいまで拡大、タブレットとは何だったのか。

自宅用のデスクトップパソコンのかわりに10インチくらいのタブレットを使うよ
	 うに。

サーバ：クラウドで処理するのが主流。python / ruby でコード書いていると
	 CPUが何かわからない。裏で動いているCPUは一般人は知らない。

ARMホストの仮想化技術が発達。

Oracle がメンテナンスする気がないのが明確になり、java リスクが顕著になる。

固定ゲーム機の終焉。

ゲームはARM。

 & 
 % 2014

Intel がまたARMに参入、もしくは省電力CPUを主力に切り替える。

気づいたら自作パソコン業界が終焉している。
セキュアブートが普及している。

AMD が ARM コアのCPUを出す。

Java が Oracle管理からはずれる。

スマートフォンの電池がガラケーなみに持つようになる。

電池消費が重要なアプリ選択の要素となる。
スポイトで充電できる、燃料電池が流行る。

ARメガネのプロトタイプが出てくる。

 & 
 % 2015

自作スマホの時代。
OpenHardwareがモバイルに移行する。
技適のパーツ認定基準というのができるようにがんばる。

自宅で回路が印刷できる機器が普及してCPUとかが印刷できるようになるといい
		 な。

タブレットが丸められるようになって巻物になっている。

AMD が x86 撤退。

ハードディスクを見たことがない人がいる。

データセンターを自前でもっているのは発電所を持っているところだけになる。

クラウドの法制度、免責事項、個人情報保護関連の問題が提起され、解決にむけ
		 てすすむ。
一種データセンタークラウド業者の要求規格が制定される。
ユーザ数何人以上は二種免許が必要とか。

データセンターヘイブンとよばれる国が存在する。

\\

\hline
\end{tabular}
}

そしてそのあと上川司会で２０１３年の各月のテーマ候補について語り合いまし
た。

最後に野島さんがDebhelperの話をして終了。
GDBの話は時間オーバーしてしまったので次回にもちこすことになりました。

\subsection{OSC Tokyo/Spring}

２０１３年２月のOSC東京は明星大学で開催されました。
セミナー担当は野島さん
展示担当はkoedoyoshidaさん
dictossさん、やまねさんが協力しました。
詳細は後ほど

\subsection{福岡Debian勉強会}


%-------------------------------------------------------------------------------
\dancersection{ldapvi \& python-ldap で stress-free life}{まえだこうへい}
%-------------------------------------------------------------------------------

\subsection{ストレス溜まってませんか？}

はじめに今回の記事は OpenLDAP で LDAP サーバの管理を行っている人がターゲットです。LDAP サーバを自分で管理している人はそんなに多くないだろうと思いますが、この記事が LDAP の運用で困っている人の一助になれば良いなと思います。そうでない人もLDAPアカウントやイエローページ(アドレス帳)などで知らぬ間に恩恵を受けているということは大いにあるので、明日は我が身と思ってお読み下さい。
また、自分で作ったツールのアカウント管理を LDAP で行いたい、という場合にも参考になることでしょう。

なお、 LDAP の基本的なお話や、Debian システムでの OpenLDAP の入門については、第 61 回 関西 Debian 勉強会( 2012 年 7 月)に佐々木さんが行われているので、そちらを参照下さい。\footnote{あんどきゅめんてっど Debian 2012 年冬号 8.「Debian で作る LDAP サーバ」 \url{http://tokyodebian.alioth.debian.org/pdf/debianmeetingresume2012-fuyu.pdf}}

\subsection{stress = LDIF}

LDAP の運用で何が面倒かというと、LDIF (LDAP Data Interchange Format) の作成です。LDAP のデータを作成・更新・削除するには通常、 LDIF を作成し、 ldapadd/ldapmodify/ldapdelete コマンドで実行します。一つのオブジェクトは dn(distiguised name, 識別名)から始まり、それに attribute が続きます。複数オブジェクトを記述するには空行で分割します。下記は RFC2849 の ``Example 1: An simple LDAP file with two entries'' からの引用です。\footnote{\url{http://www.ietf.org/rfc/rfc2849.txt}}

\begin{commandline}
version: 1
dn: cn=Barbara Jensen, ou=Product Development, dc=airius, dc=com
objectclass: top
objectclass: person
objectclass: organizationalPerson
cn: Barbara Jensen
cn: Barbara J Jensen
cn: Babs Jensen
sn: Jensen
uid: bjensen
telephonenumber: +1 408 555 1212

dn: cn=Bjorn Jensen, ou=Accounting, dc=airius, dc=com
objectclass: top
objectclass: person
objectclass: organizationalPerson
cn: Bjorn Jensen
sn: Jensen
telephonenumber: +1 408 555 1212
\end{commandline}

データフォーマット自体はさほど難しくありませんが、このデータを一から自分でスクラッチで作成するとなると、とても面倒だと思いませんか？例えば上記の引用例のようなユーザアカウントの場合、人間が読みやすいのは TSV 形式などでスプレッドシートソフトで管理するのが一番楽でしょう。ではそこから LDIF に変換したり、あるいはその逆はどうしますか？簡単に思いつくのは次の二つでしょう。

\begin{enumerate}
  \item 手でちまちま変換する
  \item なんらかのプログラムで一括変換する
\end{enumerate}

そもそも1は転記ミスなどの可能性から論外ですが、アカウント数が少数ならいっそのこと LDIF を手で作成すると割り切ってしまうのもありでしょう。面倒なのでちょっとストレスです。

しかしユーザ数が大量になるともうなんらかのプログラムで変換しないとやってられないでしょう。
例えば、以前私が Excel で管理されているユーザ情報を LDIF に変換し、それをもとに LDAP サーバを構築したときは xlhtml パッケージでまず TSV フォーマットのデータに変換し、 awk スクリプトで LDIF に変換しました。詳細はブログにありますのでそちらを参照ください。\footnote{Excel ファイルから LDIF を生成する。\url{http://d.palmtb.net/2011/08/13/194954.html}} この時は、一回だけ変換し、そのあとは phpLDAPadmin \footnote{\url{http://phpldapadmin.sourceforge.net/wiki/index.php/Main_Page}} を使うようにしました。が、残念ながら phpLDAPadmin は Web ブラウザで LDAP の管理を行えるだけで、お世辞にも使いやすいとは言えません。なので、当時は画面をキャプチャし、手順書を作って後任に引き継ぎました。しかし、ITリテラシの低い人によるユーザ情報の更新もあるので、　Excel での管理も継続され、データの二重管理になってしまいました。ストレス溜まって仕方ありません。 awk でインポート用の変換スクリプトを書くのはまだ良いですが、データのメンテナンス用のスクリプトを書くとなると大変です。 Excel の列と LDAP オブジェクトの attribute のマッチングは数を数えて、となるので非常に面倒です。やってられません。ストレスが溜まってしかたありません。

\subsubsection{そして slapd-config}
OpenLDAP 2.4 からは slapd 自体の管理も LDAP データベースになりました。これを slapd-config と言います。以前の OpenLDAP 2.3 までは、/etc/ldap/slapd.conf で管理していましたが、これが /etc/ldap/slapd.d 以下の LDAP データベース(実態は LDIF ファイル)になっています。これらのファイルは エディタでの直接編集はできません。直接編集するとハッシュが変わるので壊れます。現在は既存ユーザ向けにまだ slapd-config ではなく slapd.conf で管理する方法も残っています。しかし、 slapd.conf は将来的に廃止されることが決まっています。廃止されるものを使いつづけても仕方ありません。日本語で公開されている OpenLDAP の記事をみるとほとんどがそのやり方でしょう。嘆かわしいことです、と言いたいところですが、ユーザデータの管理ですら LDIF で悩んでいるのに、さらに slapd 自体の構成すら LDIF 作ってやらんとあかんと考えるともう気が狂ってしまいそうですね。

ストレッサーである LDIF をなんとかしないといけません。

\subsection{ldapvi で LDIF 地獄からの脱却}

そこで、ldapvi です。\footnote{\url{http://www.lichteblau.com/ldapvi/}} このツールはは、 vipw(8) コマンドや、 visudo(8) と同じように、 vi で LDAP のデータを変更できます。これで少数のデータを管理するときはもちろん、 slapd-config での slapd 管理の悩みも解決します。

使うには、 ldapvi パッケージをインストールします。

\begin{commandline}
$ sudo apt-get install ldapvi
\end{commandline}

使い方は、ldap-utils パッケージのコマンドのオプションとほぼ同じです。では最大のストレッサーを最初に取り除きましょう。 slapd-config での操作は下記のコマンドを実行します。

\begin{commandline}
$ sudo ldapvi -Y EXTERNAL -h ldapi:/// -b cn=config
\end{commandline}

これで slapd-config 管理下のすべてのオブジェクトツリーが ldapvi のフォーマットで表示されます。 ldapvi のフォーマットはほぼ LDIF に似ています。

\begin{commandline}
# -*- coding: utf-8 -*- vim:fileencoding=utf-8:
# http://www.lichteblau.com/ldapvi/manual#syntax

# SASL output:
# SASL/EXTERNAL authentication started
# SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
# SASL SSF: 0

0 cn=config
objectClass: olcGlobal
cn: config
olcArgsFile: /var/run/slapd/slapd.args
olcLogLevel: 512
olcPidFile: /var/run/slapd/slapd.pid
olcToolThreads: 1

1 cn=module{0},cn=config
objectClass: olcModuleList
cn: module{0}
olcModulePath: /usr/lib/ldap
olcModuleLoad: {0}back_hdb

2 cn=schema,cn=config
objectClass: olcSchemaConfig
cn: schema
(snip)
\end{commandline}

違いは、 LDIF なら ``dn: cn=config'' となっている部分が ``0 cn=config'' と表示されていることです。この数字は表示されているオブジェクトを 0 を基数とする序数となっています。例えば、新しいオブジェクトを追加する場合は、数字の代わりに ``add'' を使います。auditlog, ppolicy モジュールを新しくロードする場合は下記のように挿入します。

\begin{commandline}
(snip)

1 cn=module{0},cn=config
objectClass: olcModuleList
cn: module{0}
olcModulePath: /usr/lib/ldap
olcModuleLoad: {0}back_hdb

add cn=modile,cn=config
objectClass: olcModuleList
cn: module
olcModulePath: /usr/lib/ldap
olcModuleLoad: auditlog.la

add cn=modile,cn=config
objectClass: olcModuleList
cn: module
olcModulePath: /usr/lib/ldap
olcModuleLoad: ppollicy.la

2 cn=schema,cn=config
objectClass: olcSchemaConfig
cn: schema
(snip)
\end{commandline}

追記したら、 vi と同様に保存、終了してみましょう。(:wq コマンドを実行) すると次のメッセージが出力されます。

\begin{commandline}
SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0
     12 entries read                                                              
add: 2, rename: 0, modify: 0, delete: 0
Action? [yYqQvVebB*rsf+?] 
\end{commandline}

ここで、''y'' を入力すると、実際に slapd-config に反映されます。 slapd.conf とは違い、 slapd の再起動は不要です。''q'' を入力するとキャンセルして終了します。

上記での挿入時に、 cn=module{0} の ``{0}'' を残したまま保存してみてください。

\begin{commandline}
add cn=modile{0},cn=config
objectClass: olcModuleList
cn: module{0}
olcModulePath: /usr/lib/ldap
olcModuleLoad: ppollicy.la
\end{commandline}

すると次のようにエラーに修正を要求されます。
\begin{commandline}
ldap_add: Naming violation (64)
add: 1, rename: 0, modify: 0, delete: 0
Action? [yYqQvVebB*rsf+?] 
\end{commandline}

これはすでに cn=module{0}, cn=config が存在するためです。新規追加時に dn では親や先祖のノードに序数が指定されていれば必要ですが、自身のノードには自動的に付与されるので指定してはいけません。今回は ``e'' を押し編集モードに戻り、dn および attribute の cn の序数を取り除きましょう。

編集が終わったら、 ``y'' を押して保存する前に、 ``v'' を押してみてください。すると、 LDIF 形式で表示されます。これは後々役立ちます。

\begin{commandline}
version: 1

dn: cn=module,cn=config
changetype: add
objectClass: olcModuleList
cn: module
olcModulePath: /usr/lib/ldap
olcModuleLoad: auditlog.la

dn: cn=module,cn=config
changetype: add
objectClass: olcModuleList
cn: module
olcModulePath: /usr/lib/ldap
olcModuleLoad: ppolicy.la
\end{commandline}

既にあるオブジェクトの属性を変更する場合は、値を変更するだけです。オブジェクトを削除する場合は、対象のオブジェクトのすべての行を、特定の属性だけを削除する場合はその行を削除するだけです。自分で LDIF を作るのと違い、非常に簡単であることがわかるでしょう。
フォーマットが間違っている場合は前述のようにエラーになる上、変更時に slapd の再起動が不要なので、実は slapd.conf での管理よりもとても便利なものです。

ユーザデータを変更する場合も基本的に同じです。 ldapvi コマンドで指定するオプションが異なるだけです。

\begin{commandline}
$ ldapvi -h ldap://localhost -D cn=root,dc=example,dc=org -b dc=example,dc=org
\end{commandline}

ldapvi の詳細は、ユーザマニュアルが充実しているのでそちらを参照ください。\footnote{ldapvi User Manual \url{http://www.lichteblau.com/ldapvi/manual/}}

これで LDIF の作成での最大と最小のストレッサーが取り除けたでしょうか。

\subsection{debconf-utils と slapd-config で導入の自動化を進める}

OpenLDAP を使う場合、 slapd パッケージをインストールしますが、 debconf による対話形式の設定が必要になります。はじめてインストールする場合などには便利なのですが、ある程度なれてきて、 slapd の設定自体もあらかじめ決めてあると、これはかえって面倒なものになります。予め設定するパラメータは決めてあるのですから自動化してしまいたいでしょう。そういう場合、 debconf-utils パッケージと、 そして slapd-config を上手に使うことで自動化できるようになります。

\subsubsection{事前準備}

まず、テスト環境などを用意します。このテスト環境の目的は次の二つです。
\begin{enumerate}
  \item debconf の設定を抽出する
  \item slapd-config 用の LDIF を用意する
\end{enumerate}

前者は slapd パッケージをインストール際に今後設定設定したいパラメータを入力しておく必要があります。設定された状態で debconf-utils パッケージの debconf-get-selections コマンドで slapd のパラメータを抽出するためです。後者は slapd パッケージをインストールした直後の状態にしておく必要があります。この状態で ldapvi を使い、予め設定したい属性の値を変更し、前述の LDIF 形式の出力するためです。

\subsubsection{debconf-get-selections でパラメータを抽出する}

slapd をインストール状態で次のコマンドを実行します。

\begin{commandline}
$ LANG=C sudo debconf-get-selections | grep slapd
slapd   slapd/password2 password
slapd   slapd/internal/generated_adminpw        password
slapd   slapd/internal/adminpw  password
slapd   slapd/password1 password
slapd   slapd/password_mismatch note
slapd   slapd/invalid_config    boolean true
slapd   shared/organization     string  example.org
slapd   slapd/upgrade_slapcat_failure   error
slapd   slapd/backend   select  HDB
slapd   slapd/dump_database     select  when needed
slapd   slapd/allow_ldap_v2     boolean false
slapd   slapd/no_configuration  boolean false
slapd   slapd/move_old_database boolean true
slapd   slapd/dump_database_destdir     string  /var/backups/slapd-VERSION
# Do you want the database to be removed when slapd is purged?
slapd   slapd/purge_database    boolean false
slapd   slapd/domain    string  example.org
\end{commandline}

このうち、\texttt{slapd/upgrade\_slapcat\_failure} と''\#''から始まるコメント行は不要です。削除して slapd-debconf.txt などの任意のファイル名で保存します。
これを slapd パッケージをインストール時に反映させるには、パッケージインストール前に debconf-set-selections コマンドを使います。下記のコマンドを実行します。

\begin{commandline}
$ sudo bash -c ``cat slapd-debconf.txt | debconf-set-selections''
$ sudo DEBCONF_FRONTEND=noninteractive apt-get -y --force-yes install slapd
\end{commandline}


\subsection{python-ldap で データ管理も LDIF フリーに}

\subsection{おまけ: Ubnutu 12.04 でのハマりポイント}



%-------------------------------------------------------------------------------
\dancersection{月刊Debhelper}{吉田 俊輔}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\dancersection{gdb python拡張その1}{野島 貴英}
%-------------------------------------------------------------------------------
%$

\index{gdb-pythonかくちょう@gdb-python拡張}
\subsection{はじめに}

 Debianパッケージのバイナリのバグ潰しを行う時、gdbなどのデバッガを使ってデバッグを
する事も多いかと思います。しかしながら、プログラムの構造が大規模/複雑になってくると、
デバッグ作業も大変になっていきます。また、プログラムについても、
抽象化が激しく行われていると、デバッガ無しには解析が非常に困難かと思います。

 gdbはv7.0からpython拡張が搭載されており
\footnote{\url{http://ftp.gnu.org/gnu/gdb/}調べ}、gdbをpythonスクリプトで操る
事ができます。こちらを利用する事により、人手では、工数かかりすぎでなかなか
進まなかったデバッグも可能になっていくと思います。

 今回は、gdbのpython拡張の一部を説明し、最後はC言語で作られた
プログラムの実行トレースを実際にpython拡張機能を用いて、取得してみる
ところまでやってみます。

\subsection{Debian sidのgdb python拡張の基本情報}

 debian sidに含まれているgdbは最初からpython拡張が有効にしてあるようです。
表\ref{tab:gdb-python-basic-info}に基本情報を載せます。

\begin{table}[ht]
\begin{center}
\small
\begin{tabular}{|l|l|l|}
\hline
項番 & 項目 & 値 \\
\hline
1 & gdbバージョン & 7.4.1 \\
2 & pythonバージョン & 2.7.3 \\
3 & pythonサーチパス & /usr/share/gdb/python,/usr/lib/python2.7以下 \\
\hline
\end{tabular}
\caption{Debian sid環境に含まれるgdbとpythonの基本情報}
\label{tab:gdb-python-basic-info}
\end{center}
\end{table}

 今回はdebian sid amd64環境でテストした結果を元に説明を行います。

\subsection{python拡張を簡易的に動かしてみる}

 gdbよりpython言語を簡易的に呼び出す場合、gdbのコマンドラインから接頭辞として
pythonをつけて起動します。また、gdbコマンドラインから
pythonのみを指定すると、Ctrl+dを押下するまで、複数のpython構文を
指定できます。(なお、Ctrl+dを押下すると、gdbのコマンドラインに復帰する
と同時に入力した複数のpython構文が一度に評価されます）

 なお、pythonで一度定義した変数などはgdbを終了するまで何度でも
参照できます。

\begin{commandline}
$ gdb 
GNU gdb (GDB) 7.4.1-debian
Copyright (C) 2012 Free Software Foundation, Inc.
...中略...
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
(gdb) python print "hello world"
hello world
(gdb) python a=[1,2,3,4]
(gdb) python print a
[1, 2, 3, 4]
(gdb) python a.append(5)
(gdb) python print a
[1, 2, 3, 4, 5]
(gdb) python
>import sys
>print sys.path
>print sys.version_info
>ここでCtrl+d
['/usr/share/gdb/python', '/usr/lib/python2.7',
  '/usr/lib/python2.7/plat-linux2', '/usr/lib/python2.7/lib-tk',
  '/usr/lib/python2.7/lib-old', '/usr/lib/python2.7/lib-dynload',
  '/usr/local/lib/python2.7/dist-packages',
  '/usr/lib/python2.7/dist-packages',
  '/usr/lib/python2.7/dist-packages/PIL',
  '/usr/lib/python2.7/dist-packages/gst-0.10',
  '/usr/lib/python2.7/dist-packages/gtk-2.0',
  '/usr/lib/pymodules/python2.7']
sys.version_info(major=2, minor=7, micro=3, releaselevel='final', serial=0)
\end{commandline}
% $ 
\subsection{gdbのpython拡張の構造}

　gdbのpython拡張は図\ref{fig:python-internal-schema}のような構造となっています。

\begin{figure}[h]
\begin{center}
 \includegraphics[width=0.8\hsize]{image201301/gdb-python/gdb-python-internal-schema.eps}
 \caption{gdbとpython拡張の構造}
 \label{fig:python-internal-schema}
\end{center}
\end{figure}

\subsection{module gdbのマニュアル}

 gdb本体にmodule gdbが実装されているため、module gdbの
pythonドキュメントについては、gdb上でpythonからhelp(gdb)を呼び出す必要
があります。

 以下に読み方を示します。なお、以降、(gdb)はgdbのプロンプトを示します。

\begin{commandline}
(gdb) python help(gdb)
Help on package gdb:

NAME
    gdb

FILE
    (built-in)

PACKAGE CONTENTS
    command (package)
    printing
    prompt
    types

...中略...
\end{commandline}

 また、gdbのpython拡張についてのさらに詳しい説明は、info gdbにて
Extending GDB→pythonの項目から参照できます。

\subsection{module gdbに定義されているオブジェクト群}

 図\ref{fig:python-class-schema-1}〜図\ref{fig:python-class-schema-2}に、
module gdbに定義されているオブジェクト群のclass図を載せます。

 gdb拡張用のpythonスクリプトを記載する場合、これらオブジェクトを併用して
gdbとのデータのやりとり、あるいは、操作を行います。

\begin{figure}[h]
\begin{center}
 \includegraphics[width=0.8\hsize]{image201301/gdb-python/gdb-python-class-schema-1.eps}
 \caption{module gdbのclass図(その1)}
 \label{fig:python-class-schema-1}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
 \includegraphics[width=0.8\hsize]{image201301/gdb-python/gdb-python-class-schema-2.eps}
 \caption{module gdbのclass図(その2)}
 \label{fig:python-class-schema-2}
\end{center}
\end{figure}

\newpage

\subsection{gdbのコマンドを増やしてみる}

 gdbのpython拡張は柔軟な機能を持つため、いろいろな使い方ができます。
ここでは、試しにgdbのコマンドを増やしてみます。

　gdbのコマンドをpythonから増やすには、gdb.commandクラスを継承したクラスを
用意し、gdb.command.\_\_init\_\_()にてコマンド名と共に登録する事により行います。

　info gdbのExtending GDB→Python→Python API→Commands In Pythonに
記載されている方法を試して、hello-worldコマンドを登録してみます。

\begin{commandline}
-----hello.pyの中身ここから-----
# -*- coding: utf-8 -*-
# coding:utf-8
import gdb
class HelloWorld (gdb.Command):
  """ Greet the whole world """
  def __init__ (self):
     super(HelloWorld, self).__init__ ("hello-world",gdb.COMMAND_OBSCURE)

  def invoke (self,arg, from_tty):
     print "Hello, World! arg=["+str(arg)+"]"

HelloWorld()
-----hello.pyの中身ここまで-----
\end{commandline}

 追加したコマンドについていろいろ実行してみます。

\begin{commandline}
(gdb) source hello.py
(gdb) hello-[ここでTABを押すと補完される]
(gdb) hello-world foo,bar,com
Hello, World! arg=[foo,bar,com]
(gdb) help obscure
Obscure features.

List of commands:

...中略...
hello-world --  Greet the whole world 
...中略...
\end{commandline}

　コマンド hello-worldが追加されています。また、引数はinvoke()のargに文字列として
まとめて入ります。また、コマンドカテゴリのOBSCUREに登録されている事がhelp obscure
にて判ります。

\subsection{作ったpythonスクリプトを自動で読み込ませるには}

 ところで、gdbのpython拡張を理解するにつれ、高度なデバッグ用スクリプトを用意するように
なってくると思います。すると、作ったpythonスクリプトをいつもgdbに自動で読み込ませ
ておきたくなるかと思います。方法としては、以下の3つの方法があります。

\subsubsection{\$\{HOME\}/.gdbinitを使う方法}

 以下のようなファイルを\verb!${HOME}/.gdbinit!に記載しておきます。

\begin{commandline}
----${HOME}/.gdbinitここから-----
source /home/foo/bar/my-gdb-func.py
----${HOME}/.gdbinitここまで-----
\end{commandline}

こうすると、\verb!${HOME}!にホームディレクトリがあるようなユーザがgdbを起動した時に、
自動的に/home/foo/bar/my-gdb-func.pyがロードされて評価されるようになります。

\subsubsection{セクション名：.debug\_gdb\_scriptsを使う方法}

 バイナリ形式によりますが、任意のセクション名を持つ事が可能なバイナリ形式
（例：ELF,DWARF)にて、.gdb\_gdb\_scriptsセクションを作成し、ここにスクリプト名
を打ち込んでおく事ができる場合があります。この場合、カレントディレクトリにある、
同名のスクリプトをgdbが自動的にロードしてくれます。
なお、本機能は、gdb変数のauto-load-scriptがonの時に有効です（デフォルトはon。）

　以下に例を示します。ここでは先ほどのhello.pyを自動でロードするように
asm\{\}命令で.debug\_gdb\_scriptsセクションを直接指定しています。

\begin{commandline}
------hello.cの中身ここから------
#include <stdio.h>

asm(
".pushsection \".debug_gdb_scripts\",\"MS\",@progbits,1\n"
".byte 1\n"
".asciz \"hello.py\"\n"
".popsection \n"
);

int main(int argc,char **argv)
{
        printf("hi there!");
        return 0;
}
------hello.cの中身ここまで------

実行結果:
$ gcc -o hello hello.c
$ ls 
hello hello.py hello.c
$ gdb hello
GNU gdb (GDB) 7.4.1-debian
Copyright (C) 2012 Free Software Foundation, Inc.
...中略...
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /home/xxxx/hello...done.
(gdb) info auto-load-scripts
Loaded  Script                                                                 
Yes     hello.py                                                         
	full name: /home/xxxx/hello.py
(gdb) hello-world 
Hello, World! arg=[]
\end{commandline}
%$

\subsubsection{``バイナリ名''-gdb.pyをスクリプト名に使う方法}

 ファイル名として、``バイナリ名''-gdb.pyをファイル名に持つpythonスクリプトを
カレントディレクトリに置いておくと、gdbがバイナリ名のファイルをロードした時、
自動でロードしてくれます。なお、本機能は、gdb変数のauto-load-scriptがonの時に
有効です（デフォルトはon）

 以下の例では、gdb helloとすると、無事先ほどのhello.pyが読み込まれ、
hello-worldコマンドが登録されている事がわかります。

\begin{commandline}
------hello.cの中身ここから------
#include <stdio.h>

int main(int argc,char **argv)
{
        printf("hi there!");
        return 0;
}
------hello.cの中身ここまで------

コンパイル：
$ gcc -o hello hello.c
$ mv hello.py hello-gdb.py (←先ほどのhello.pyの名前を"バイナリ名"-gdb.pyへ変更）
$ ls 
hello hello-gdb.py hello.c
$ gdb hello
GNU gdb (GDB) 7.4.1-debian
Copyright (C) 2012 Free Software Foundation, Inc.
...中略...
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /home/xxxx/hello...done.
(gdb) info auto-load-scripts
Loaded  Script                                                                 
Yes     /home/xxxx/hello-gdb.py
(gdb) hello-world 
Hello, World! arg=[]
\end{commandline}
%$

\subsection{break/finishと応用例について}

 デバッガの基本機能にbreakpointがあります。こちらの機能を
pythonから利用するには gdb.Breakpoint class及び、
gdb.FinishBreakpoint classを継承する事により行います。
これらclassを用いれば、gdbのbreak/watch/finishコマンドを独自拡張できます。

 ここでは、応用としてバイナリ内部の関数呼び出しの記録を取るようなpythonスクリプト
を書いてみます。

\begin{commandline}
-------calltracer.pyここから---------
# -*- coding: utf-8 -*-
# coding:utf-8
import gdb
class _CallTracerFinishBreakpoint(gdb.FinishBreakpoint):
	def __init__(self, name, stack):
		super(_CallTracerFinishBreakpoint, self).__init__(internal=True)
		self._stack_ptr=stack
		self._name=name
		self.silent=True
	def stop(self):
		print (" " * (len(self._stack_ptr)))+"<="+self._name
		self._stack_ptr.pop()
		return False
	def out_of_scope(self):
		print "Abnormal jump out frame"
		print (" " * (len(self._stack_ptr)))+"<="+self._name
		self._stack_ptr.pop()
		return False

class _CallTracerBreakpoint(gdb.Breakpoint):
	def __init__(self, spec, name, stack):
		super(_CallTracerBreakpoint, self).__init__(spec, 
							    gdb.BP_BREAKPOINT,
							    internal = False)
		self._stack_ptr=stack
		self._name=name
		self.silent=True
	def stop(self):
		self._stack_ptr.append(self._name)
		print (" " * (len(self._stack_ptr)))+"=>"+self._name
		try:
			_CallTracerFinishBreakpoint(self._name, self._stack_ptr)
		except:
			print "uh? cant put finish break on "+self._name
		return False

class _ReAnalyzeCallTracer(gdb.Command):
	""" reanalyze symbol for calltracer """
	def __init__(self):
		super(_ReAnalyzeCallTracer, self).__init__('reanalyzecalltracer',
							gdb.COMMAND_OBSCURE)
		self._stack=[]
	def _retrive_ptrs(self):
		info=gdb.execute("info break",False, True)
		info_lines=info.splitlines()
		ptrs={}
		for idx in range(0,len(info_lines[1:])):
			tokens=info_lines[idx+1].split()
			if len(tokens) > 5:
				if ptrs.has_key(tokens[4]) == False:
					ptrs[tokens[4]]=" ".join(tokens[5:])
		return ptrs
	def invoke(self, arg, from_tty):
		break_info=self._retrive_ptrs()
		gdb.execute("delete",False, True)
		gdb.execute("set pagination off")
		for addr,name in break_info.iteritems():
			_CallTracerBreakpoint(r'*'+addr,
					      name,self._stack)
_ReAnalyzeCallTracer()

class _PrepareCallTracer(gdb.Command):
	""" prepare call tracer for c """
	def __init__(self):
		super(_PrepareCallTracer, self).__init__('prepcalltracer',
							 gdb.COMMAND_OBSCURE)
	def invoke(self, arg, from_tty):
		gdb.execute("rbreak",False, True)
		gdb.execute("reanalyzecalltracer",False, True)
		print "prepare done!"

_PrepareCallTracer()
-------calltracer.pyここまで---------
-------デバッグ対象：chkfunc.c ここから-------
#include<stdio.h>

void foo_a(const char *str)
{
	printf("%s\n",str);

}
void caller_bar(void)
{
	foo_a("caller is bar!");
}
int main(int argc,char **argv)
{
	foo_a("caller is main!");
	caller_bar();
	return(0);
}
-------デバッグ対象：chkfunc.c ここまで-------
\end{commandline}
\begin{commandline}
実行結果：
$ gcc -O0 -g -o chkfunc chkfunc
$ ls
chkfunc.c chfunc calltracer.py
$ gdb ./chkfunc
GNU gdb (GDB) 7.4.1-debian
Copyright (C) 2012 Free Software Foundation, Inc.
...中略...
Reading symbols from /home/foo/bar/chkfunc...done.
(gdb) source calltracer.py
(gdb) prepcalltracer 
prepare done!
(gdb) run
Starting program: /home/foo/bar/chkfunc 
 =><_start>
uh? cant put finish break on <_start>
  =><__libc_start_main@plt>
   =><__libc_csu_init>
    =><_init>
     =><call_gmon_start>
     <=<call_gmon_start>
    <=<_init>
    =><frame_dummy>
     =><register_tm_clones>
     <=<frame_dummy>
    <=<register_tm_clones>
   <=<__libc_csu_init>
   =>in main at chkfunc.c:21
uh? cant put finish break on in main at chkfunc.c:21
    =>in foo_a at chkfunc.c:12
     =><puts@plt>
caller is main!
     <=<puts@plt>
    <=in foo_a at chkfunc.c:12
    =>in caller_bar at chkfunc.c:17
     =>in foo_a at chkfunc.c:12
      =><puts@plt>
caller is bar!
      <=<puts@plt>
     <=in foo_a at chkfunc.c:12
    <=in caller_bar at chkfunc.c:17
    =><__do_global_dtors_aux>
     =><deregister_tm_clones>
     <=<deregister_tm_clones>
    <=<__do_global_dtors_aux>
    =><_fini>
    <=<_fini>
[Inferior 1 (process 6413) exited normally]
Abnormal jump out frame
   <=<__libc_start_main@plt>
warning: Error removing breakpoint -5
(gdb)
\end{commandline}
%$

無事、バイナリ内部の関数呼び出しの記録が取れているかと思います。

\subsection{終わりに}

 今回gdbのpython拡張のいくつかを紹介してみました。pythonを
用いる事で、いろいろなデバッグ手法が取れるかと思います。

　次回は、Frame class/Value class等の応用について紹介したいと思います。

\begin{thebibliography}{98}
\bibitem{infogdb} Free Software Foundation, ``info gdb''
\bibitem{gdbpytutor} ``PythonGdbTutorial'',\url{http://sourceware.org/gdb/wiki/PythonGdbTutorial}
\bibitem{gdbpytest} Free Software Foundation, \verb!$(GDBSRC)/gdb/testsuite/gdb.python!以下のテスト用ファイル群
\end{thebibliography}


%-------------------------------------------------------------------------------
\dancersection{OSC等でのDebian紹介方法検討(仮)}{未定}
%-------------------------------------------------------------------------------
\subsection{セミナー内容での紹介内容}
\subsection{展示方法での紹介内容}
\subsection{今後の紹介方法検討}
\subsection{演習}
\index{hoge}

\printindex

\cleartooddpage

\vspace*{15cm}
\hrule
\vspace{2mm}
\includegraphics[width=2cm]{image200502/openlogo-nd.eps}
\noindent \Large \bf Debian 勉強会資料\\
\noindent \normalfont \debmtgyear{}年\debmtgmonth{}月\debmtgdate{}日 \hspace{5mm}  初版第1刷発行\\
\noindent \normalfont 東京エリア Debian 勉強会 （編集・印刷・発行）\\
\hrule

\end{document}
