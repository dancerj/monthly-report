%; whizzy paragraph -pdf xpdf -latex ./whizzypdfptex.sh
%; whizzy-paragraph "^\\\\begin{frame}\\|\\\\emtext"
% latex beamer presentation.
% platex, latex-beamer でコンパイルすることを想定。 

%     Tokyo Debian Meeting resources
%     Copyright (C) 2012 Junichi Uekawa

%     This program is free software; you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation; either version 2 of the License, or
%     (at your option) any later version.

%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warreanty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.

%     You should have received a copy of the GNU General Public License
%     along with this program; if not, write to the Free Software
%     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

\documentclass[cjk,dvipdfm,12pt]{beamer}
\usetheme{Tokyo}
\usepackage{monthlypresentation}

%  preview (shell-command (concat "evince " (replace-regexp-in-string "tex$" "pdf"(buffer-file-name)) "&")) 
%  presentation (shell-command (concat "xpdf -fullscreen " (replace-regexp-in-string "tex$" "pdf"(buffer-file-name)) "&"))
%  presentation (shell-command (concat "evince " (replace-regexp-in-string "tex$" "pdf"(buffer-file-name)) "&"))

%http://www.naney.org/diki/dk/hyperref.html
%日本語EUC系環境の時
\AtBeginDvi{\special{pdf:tounicode EUC-UCS2}}
%シフトJIS系環境の時
%\AtBeginDvi{\special{pdf:tounicode 90ms-RKSJ-UCS2}}

\title{東京エリアDebian勉強会}
\subtitle{第98回 2013年3月度}
\author{吉田俊輔\\koedoyoshida@gmail.com}
\date{2013年3月16日}
\logo{\includegraphics[width=8cm]{image200607/openlogo-light.eps}}

\begin{document}

\frame{\titlepage{}}

\begin{frame}{設営準備にご協力ください。}
会場設営よろしくおねがいします。
\end{frame}

\begin{frame}{Agenda}
\begin{minipage}[t]{0.45\hsize}
  \begin{itemize}
  \item 注意事項
	\begin{itemize}
	 \item トイレはエレベーターホール反対側にあります。
	 \item 飲料は手動販売機があります。ゴミ箱はトイレの手前給湯室にあります。
	 \item 遅れてきた人は次に遅れてきた人を迎えに行ってください。
	\end{itemize}
 \end{itemize}
\end{minipage} 
\begin{minipage}[t]{0.45\hsize}
 \begin{itemize}
   \item 最近あったDebian関連のイベント報告
	\begin{itemize}
        \item 第96回 東京エリアDebian勉強会
        \item OSC 浜松
        \item OSC 東京
	\end{itemize}
  \item Debian Trivia Quiz
  \item 事前課題紹介
  \item ldapvi \& python-ldap で stress-free life
  \item 月刊Debhelper
  \item gdb python拡張その1
 \end{itemize}
\end{minipage}
\end{frame}


\section{イベント報告}
\emtext{イベント報告}
\begin{frame}{第96回 東京エリアDebian勉強会}
\begin{itemize}
\item 開催場所は新宿のスクエアエニックスさんでした。
\item Debian勉強会アンケート
\item 2013-2015年を妄想する
\item 月刊Debhelper
\end{itemize}
がありました。
\end{frame}
\begin{frame}{Open Source Conference 2013 Hamamatsu}
\begin{itemize}
\item 開催場所は浜松市市民協働センターさんでした。
\item 展示のみの出展で吉田、赤部さんで行いました。
\end{itemize}
\end{frame}
\begin{frame}{Open Source Conference 2013 Tokyo/Spring}
\begin{itemize}
\item 開催場所は明星大学さんでした。
\item セミナーは土曜日に「Debian Update」のタイトルで野島さんが行いました。
\item 展示は土曜のみ出展で吉田、やまねさん、杉本さんなどで行いました。
\end{itemize}
セミナー資料は下記で公開されています。
\url{http://www.ospn.jp/osc2013-spring/modules/article/article.php?articleid=5}
\url{http://tokyodebian.alioth.debian.org/2013-02.html}
やまねさんのリポートが下記にあります。
\url{http://henrich-on-debian.blogspot.jp/2013/02/open-source-conference-2013-tokyospring.html}

\end{frame}

\section{DWN quiz}
\emtext{DWN quiz}
\begin{frame}{Debian 常識クイズ}

Debian の常識、もちろん知ってますよね?
知らないなんて恥ずかしくて、知らないとは言えないあんなことやこんなこと、
みんなで確認してみましょう。

今回の出題範囲は\url{debian-devel-announce@lists.debian.org},
\url{debian-devel@lists.debian.org} に投稿された
内容とDebian Project Newsなどからです。

\end{frame}

\subsection{問題}
\input{image201303/quiz.tex}

\section{事前課題}
\emtext{事前課題}
{\footnotesize
% \input{image201301/prework.tex}
}

\section{ldapvi & python-ldap で stress-free life}
\emtext{ldapvi \& python-ldap で stress-free life}


\section{月刊Debhelper}
\emtext{月刊Debhelper}

\begin{frame}{今月のコマンド}
\Large
\begin{itemize}
\item dh\_auto\_install
\item dh\_install
\end{itemize}

\end{frame}

\begin{frame}{dh\_auto\_install動作概要}

dh\_auto\_installはdebhelperのプログラムで、自動的に
ファイルをパッケージ作成用のディレクトリにインストールします。
dh\_auto\_installは(たとえばupstearmの)Makefileのinstallターゲット,setup.py,
Build.PLを使用します。
インストール先はシングルバイナリ(only one binary package)であれば、
debian/package/以下です。
multiple binary packageの場合はdebian/tmp/以下になり、
その後dh\_installで適切なディレクトリに移動されます。
\end{frame}

\begin{frame}{dh\_install動作概要}

dh\_installはパッケージ構造ディレクトリーへインストールするファイルを扱うdebhelperプログラムです。
多くのdh\_install*コマンドが存在します。説明書(documentation),サンプル(examples),マニュアルページ(man pages)のような特定のタイプのファイルをインストールするにはそれらの方がより適切な知識(extra intelligence)をもっていますので、そちらを使うべきです。
dh\_installはその他のものすべてをインストールするのに役立ちます。そのために特別の知識は必要ではありません(no particular intelligence)。
dh\_installは古いdh\_movefilesコマンドの置換です。
このプログラムは二つの使用方法があります。
一つ目はupstearmのMakefileがインストールを行ってくれないとき、適所へそれらを移動させるためにdh\_installを実行することができます。
二つ目は、複数のバイナリパッケージを構築するラージ・パッケージを使用するときです。
あなたは、(たとえばdh\_auto\_installを使用して)debian/tmpへそれをすべてインストールし次に、そこから適切なパッケージディレクトリーを構築するためにディレクトリーやファイルをdh\_installを使用してコピーすることができます。
debhelper7から、それがカレント・ディレクトリ(あるいは--sourcedirオプションで指定したディレクトリ)にそれらを見つけなければ、dh\_installはdebian/tmpの中を見るでしょう。
\end{frame}

\begin{frame}{次回発表者は？}

\Large

\center{〜さんですー}

\end{frame}

\section{gdb python拡張その1}
\emtext{gdb python拡張その1}
\begin{frame}{デバッガの使い道}
\Large
\begin{itemize}
 \item デバッグのお供に
 \item リバースエンジニアリングのお供に
\end{itemize}
\end{frame}

\begin{frame}{参考：OSSのリバースエンジニアリング}

OSSをリバースエンジニアリングしたくなる状況：

\begin{itemize}
 \item とにかく抽象化を使いこなしてるコード
 \item データドリブンなコード
 \item そもそも俺の理解を越えたコード
\end{itemize}

と戦う時。

\center{\Large ...ソースコード読んだだけでは動作がわからん... }\\

 で、デバッガで実行して動作を追いかけると、いろいろな発見があったり、動作が良くわかったり、アーキテクチャが見えたりする。
\end{frame}

\begin{frame}{gdb}

\Large
\begin{itemize}
 \item  gdbとは \\
幅広いプラットフォームで利用でき、多数のバイナリ形式に対応でき、組み込み用途にリモートデバッグまで出来る、非常に強力なデバッガ。
\end{itemize}

\end{frame}

\begin{frame}{gdb+python}
\Large
\begin{itemize}
\item gdb v7.0からgdbにpythonが合体！
\item Debian sid梱包のgdbもpythonが有効!
\end{itemize}

\center{\Large 強力なデバッガがさらに強力に!\\
gdbもこれでbattelies included!}

\end{frame}

\begin{frame}{Debian sidのgdbのpython具合}

\begin{table}[ht]
\begin{center}
\small
\begin{tabular}{|l|l|l|}
\hline
項番 & 項目 & 値 \\
\hline
1 & gdbバージョン & 7.4.1 \\
2 & pythonバージョン & 2.7.3 \\
3 & pythonサーチパス & /usr/share/gdb/python,\\
 & &/usr/lib/python2.7以下 \\
\hline
\end{tabular}
\end{center}
\end{table}

\end{frame}

\begin{frame}{ちと困る事}

\Large

 とにかく、文献が少ない!

\begin{itemize}
\item info gdb →Extending GDB→pythonの項目か、
\item \small \url{http://sourceware.org/gdb/wiki/PythonGdbTutorial}
\end{itemize}

ぐらい。
\center{他にあったら教えてーっ}

\end{frame}

\begin{frame}{補足：さらに困った事}

\Large
\center{「しまった、俺はpythonの書き方も知らなかったな。そういえば。」}\\

(即席で、文法も覚える必要がががが...)

\end{frame}

\begin{frame}[containsverbatim]{とりあえず動かしてみる}

とりあえず、動かしてみる。
(gdb)はgdbのプロンプトです。

\begin{commandline}
$gdb
(gdb) python print "hello world"
hello world
(gdb) python a=[1,2,3,4]
(gdb) python print a
[1, 2, 3, 4]
(gdb) python a.append(5)
(gdb) python print a
[1, 2, 3, 4, 5]
(gdb) python
>import sys
>print sys.path
>print sys.version_info
>ここでCtrl+d
['/usr/share/gdb/python', '/usr/lib/python2.7',
  '/usr/lib/python2.7/plat-linux2', ...中略...
\end{commandline}
% $

\end{frame}

\begin{frame}{gdb+python構造}

バックグラウンドでpython動かしてるんだろうと思ったら大間違い。
実際にはgdbにpython処理系を結合してた。

\begin{figure}[h]
\begin{center}
 \includegraphics[width=0.8\hsize]{image201301/gdb-python/gdb-python-internal-schema.eps}
\end{center}

\end{figure}

\end{frame}

\begin{frame}[containsverbatim]{module gdbの定義はどこ}

pythonでmoduleの定義を知るには、pydocがある。でも、
gdbの中に実装されたmodule gdbの定義を読むには...

\center{\Large pythonのhelp()関数を呼べばいい}

\begin{commandline}
(gdb) python help(gdb)
Help on package gdb:

NAME
    gdb

FILE
    (built-in)

PACKAGE CONTENTS
    command (package)
    printing
...中略...
\end{commandline}

\end{frame}

\begin{frame}{module gdbのclass図が見たい}
\Large

先程のmodule gdbの定義から、地道にclass図を起こしてみた。

参照：第96回東京エリアDebian勉強会資料7.6章の図参照。

\end{frame}

\begin{frame}[containsverbatim]{基本的使い方：gdbコマンドを増やす(その1)}

gdbに新規のコマンドを増やし、pythonと結合するにはgdb.Commandクラス
を継承したオブジェクトを生成して増やす。gdb側に増やすコマンド名は
gdb.Commandオブジェクトのコンストラクタ経由で登録する。

hello.pyの中身：
\begin{commandline}
import gdb                      
class HelloWorld (gdb.Command): 
  """ Greet the whole world """ 
  def __init__ (self):
     super(HelloWorld, self).__init__ ("hello-world",
　　　　　　　　　　　　　　　　　gdb.COMMAND_OBSCURE)

  def invoke (self,arg, from_tty): 
     print "Hello, World! arg=["+str(arg)+"]"

HelloWorld()　
\end{commandline}

\end{frame}

\begin{frame}[containsverbatim]{基本的使い方：gdbコマンドを増やす(その2)}

実行してみた。

\begin{commandline}
(gdb) source hello.py
(gdb) hello-[ここでTABを押すと補完される]
(gdb) hello-world foo,bar,com
Hello, World! arg=[foo,bar,com]
(gdb) help obscure
Obscure features.

List of commands:

...中略...
hello-world --  Greet the whole world 
...中略...
\end{commandline}

\end{frame}

\begin{frame}[containsverbatim]{作ったスクリプトの自動読み込み}

いつもいつも''source スクリプト名''は面倒なので、自動で読み込ませたい時は：

\begin{itemize}
\item \verb!$(HOME)/.gdbinit!で読ませる
\item バイナリ側\verb!.gdb_gdb_scripts!セクションに埋め込む
\item ``バイナリ名''-gdb.pyという名前でスクリプトを用意する
\end{itemize}

の方法があります。

\end{frame}

\begin{frame}[containsverbatim]{.gdbinitで読ませる}

以下のファイルをHOMEディレクトリ配下に用意：
\begin{commandline}
----${HOME}/.gdbinitここから-----
source /home/foo/bar/my-gdb-func.py
----${HOME}/.gdbinitここまで-----
\end{commandline}
\end{frame}

\begin{frame}[containsverbatim]{.gdb\_gdb\_scriptsで読ませる}

以下のasm命令を打ち込んでおく。
\begin{commandline}
asm(
".pushsection \".debug_gdb_scripts\",\"MS\",@progbits,1\n"
".byte 1\n"
".asciz \"hello.py\"\n"
".popsection \n"
);
\end{commandline}

\center{\Large ちと脆弱性の香りが...}

\end{frame}

\begin{frame}[containsverbatim]{``バイナリ名''-gdb.pyで読ませる}

\begin{commandline}
$ ls 
hello hello-gdb.py hello.c
\end{commandline}
%$

gdb helloとすると、hello-gdb.pyが自動で読み込まれる。

\end{frame}

\begin{frame}[containsverbatim]{基本的使い方：breakpointを操る}

gdb.Breakpoint クラスを継承したオブジェトを用意すると、
指定したbreakpointで特定の処理をさせる事が可能。

mainでbreakしてhi!と表示する例：
\begin{commandline}
class _ExampleBreakpoint(gdb.Breakpoint):
   def __init__(self, spec):
       super(_ExampleBreakpoint, 
            self).__init__(spec,gdb.BP_BREAKPOINT,
                          internal = False)
   def stop(self):
        print "hi!"

_ExampleBreakpoint("main")
\end{commandline}

gdb.BP\_BREAKPOINTを指定すると、breakpointになり、
gdb.BP\_WATCHPOINTを指定すると、watchpointとなる。
\end{frame}

\begin{frame}[containsverbatim]{基本的使い方：finishを操る}

gdb.FinishBreakpoint クラスを継承したオブジェトを用意すると、
現在のスタックフレームから飛び出ようとするとbreakする。

スタックフレームから出るとhi!と表示する例：
\begin{commandline}
class _ExFinishBreakpoint(gdb.FinishBreakpoint):
   def __init__(self):
        super(_ ExFinishBreakpoint, 
              self).__init__(internal=False)
   def stop(self):
        print "hi!"

   def out_of_scope(self):
        print "hi!"
\end{commandline}

stop()は、returnによりスタックフレームから出る場合、out\_of\_scope()はlongjumpとか
で一機に飛び出す場合にbreakする。

\end{frame}

\begin{frame}[containsverbatim]{基本的使い方：コマンドの結果を得る}

gdbのコマンドの実行結果を得る事ができると便利な場合があります。

\begin{commandline}
result=gdb.execute('info break',False,True)
\end{commandline}

resultにgdbのコマンド''info break''の結果が文字列クラスで格納されます。

\end{frame}

\begin{frame}{以上を活用してみた例}

 解析用途で、プログラムのコールツリーを取ってみたかった。

 具体的なスクリプトのソースと使い方は、\\
第96回東京エリアDebian勉強会資料7.9章参照。

\end{frame}

\begin{frame}{calltracer.py動作説明}

\begin{description}
\item [Step 1.] rbreakを実行して、デバッグ情報にある全関数に一旦breakpointを仕掛ける
\item [Step 2.] info breakの結果をパースして、関数のアドレスと、名前の両方を得る。
\item [Step 3.] カスタマイズしたbreakpointと入れ替える。
\item [Step 4.] breakしたら、スタック追跡変数(self.stack)を+1して関数名を表示。同時にカスタマイズしたfinishを仕掛ける。
\item [Step 5.] finishでbreakしたら、関数名を表示してスタック追跡変数を-1する。
\item [Step 6.] Step 4.〜Step 5.を繰り返す。
\end{description}

\end{frame}

\begin{frame}{終わりに}

\center{\Large pythonのおかげで、\\なんかもう夢ひろがりんぐ\\
まだまだ機能満載なので、\\次回も発表続けるよどこまでも!}

\end{frame}

\section{今後のイベント}
\emtext{今後のイベント}
\begin{frame}{今後のイベント}
\begin{itemize}
 \item 2013年4月 Debian勉強会
\end{itemize}
\end{frame}

\section{今日の宴会場所}
\emtext{今日の宴会場所}
\begin{frame}{今日の宴会場所}
未定
\end{frame}

\end{document}

;;; Local Variables: ***
;;; outline-regexp: "\\([ 	]*\\\\\\(documentstyle\\|documentclass\\|emtext\\|section\\|begin{frame}\\)\\*?[ 	]*[[{]\\|[]+\\)" ***
;;; End: ***
