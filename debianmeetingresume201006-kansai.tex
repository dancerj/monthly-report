%; whizzy chapter
% -initex iniptex -latex platex -format platex -bibtex jbibtex -fmt fmt
% 以上 whizzytex を使用する場合の設定。

%     Kansai Debian Meeting resources
%     Copyright (C) 2007 Takaya Yamashita
%     Thank you for Tokyo Debian Meeting resources

%     This program is free software; you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation; either version 2 of the License, or
%     (at your option) any later version.

%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.

%     You should have received a copy of the GNU General Public License
%     along with this program; if not, write to the Free Software
%     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

%  preview (shell-command (concat "evince " (replace-regexp-in-string "tex$" "pdf"(buffer-file-name)) "&"))
% 画像ファイルを処理するためにはebbを利用してboundingboxを作成。
%(shell-command "cd image200708; ebb *.png")

%%ここからヘッダ開始。

\documentclass[mingoth,a4paper]{jsarticle}
\usepackage{kansaimonthlyreport}
\usepackage[dvips]{xy}
\usepackage{ascmac}

% 日付を定義する、毎月変わります。
\newcommand{\debmtgyear}{2010}
\newcommand{\debmtgdate}{27}
\newcommand{\debmtgmonth}{06}
\newcommand{\debmtgnumber}{35}

\begin{document}

\begin{titlepage}

% 毎月変更する部分、本文の末尾も修正することをわすれずに

 第\debmtgnumber{}回 関西 Debian 勉強会資料

\vspace{2cm}

\begin{center}
\includegraphics{image200802/kansaidebianlogo.png}
\end{center}

\begin{flushright}
\hfill{}関西 Debian 勉強会担当者 佐々木・倉敷・のがた \\
\hfill{}\debmtgyear{}年\debmtgmonth{}月\debmtgdate{}日
\end{flushright}

\thispagestyle{empty}
\end{titlepage}

\dancersection{Introduction}{Debian JP}

\subsection*{}%ロゴ用のスペース稼ぎ
 
関西 Debian 勉強会はDebian GNU/Linux のさまざまなトピック(新しいパッケー
ジ、Debian 特有の機能の仕組、Debian 界隈で起こった出来事、などなど）に
ついて話し合う会です。

目的として次の三つを考えています。
\begin{itemize}
      \item MLや掲示板ではなく、直接顔を合わせる事での情報交換の促進
      \item 定期的に集まれる場所
      \item 資料の作成
\end{itemize}

それでは、楽しい一時をお楽しみ下さい。

\clearpage

\begin{minipage}[b]{0.2\hsize}
 {\rotatebox{90}{\fontsize{80}{80}
{\gt 関西 Debian 勉強会}}}
\end{minipage}
\begin{minipage}[b]{0.8\hsize}
\hrule
\vspace{2mm}
\hrule
\setcounter{tocdepth}{1}
\tableofcontents
\vspace{2mm}
\hrule
\end{minipage}

\dancersection{最近のDebian関係のイベント報告}{Debian JP}

\subsection{前回の関西Debian勉強会}

前回の関西Debian勉強会は, 5 月 23 日に大阪港区民センターで行なわれました。
Ubuntu Japanese Team のあわしろいくやさんによる「Debian ユーザのための Ubuntu 入門」とのがたじゅんさんによる「次期リリースの Squeeze を見てみよう」でした。
%
リリースされたばかりの Lucid Lynx 入門が目玉でした。いくやさんのトークも
好調で、オフレコ話あり、Debian との差異ネタありでいい感じの盛り上がりを
見せていたと思います。

続いて、お約束通りにフリーズの遅れている squeeze について、のがたさんに
現状をまとめてもらいました。特に日本語まわりで課題が残っている squeeze、
リリースまで目が離せませんね。

\subsection{第 {\bf XX}  回東京 Debian 勉強会}

{\bf Fixme: 内容を書いて下さい}


\dancersection{事前課題}{佐々木洋平}

今回はパッケージ作成にまつわる以下の事前課題を設定しました
\footnote{%
これまでと比べて思いっきりハードルを上げてしまったためか、
参加登録者が少ない気がしますが...}。
\begin{quote}
    \begin{screen}
        \begin{description}
              \item [deb パッケージ(野良含む)を作成している方]　\\
            お手元のパッケージのどれか 1 つを source format 3.0、cdbs
            or debhelper 7 に移行して下さい。 提出事前課題としては、その
            感想をお願いします。 また、発表者宛に *debian.tar.gz を添付
            して下されば幸いです(その際には勉強会登録システムでの参加者
            名を明記して下さい)。
              \item [deb パッケージを作成していない方]　\\
            パッケージ作成環境を一通り用意して来て欲しいので、お手元で
            適当なパッケージ(例えば GNU Hello)などを作成してきて下さ
            い。 提出事前課題としては、その感想をお願いします。
        \end{description}
    \end{screen}
\end{quote}

参加者の皆さんによる回答は以下の通りです。

\begin{prework}{ 佐々木洋平 }

    unstable の howm、rail パッケージの作成には debhelper
    7.0、rttools、rabbit パッケージの作成には CDBS + ruby-pkg-tools を
    使って rules を書きました。  ruby 関連について
    は setup.rb、install.rb、extconf.rb と install に使用するscript が
    分かれているので debhelper より CDBS + ruby-pkg-tools の方が楽です
    ね。 gem だと Rakefile になるので、debhelper
    7.0 用にdh\_rubygems(仮) を作成するなら Rake を探すようにすれば良い
    かな、と妄想しました。

\end{prework}

\begin{prework}{ 山田 洋平 }

    deb パッケージを作成していないほうです。
    Squeeze の hello および hello-debhelper と、
    「佐々木流」の資料を参考にしたら何とか作成できました。
    ですがもう少し中身を理解して作業したいです。
    
\end{prework}



\begin{prework}{ 西山和広 }

    cdbs を使ったパッケージはいくつか作ったことがあったので、source
    format 3.0 (quilt)で chkbuild の deb を作ってみまし
    た。\url{http://chkbuild.deb.n-z.jp/} で公開しています。cdbs と違っ
    て debian/rules に include がないので、DEB\_UPDATE\_RCD\_PARAMSなど
    を指定したくなった場合どうするのかが気になりましたが、今回は必要な
    かったのでそこまでは調べませんでした
    \footnote{%
      DEB\_UPDATE\_RCD\_PARAMS の場合は dh\_installinit を override
      します(佐々木)}。

\end{prework}



\begin{prework}{ かわだてつたろう }

GNU Hello でパッケージを作成。
単一のソースから単一のパッケージを作成するなら debhelper と debuild ですんなりとできるんだなぁと。

手間取ったところ:
\begin{itemize}
      \item lintian のエラー(package-contains-info-dir-file)
      \item pbuilder で basetgz 作成が何度も失敗
      \item piuparts での Broken symlinks で失敗
\end{itemize}

\end{prework}



\begin{prework}{ 古川竜雄 }

    私はdebパッケージを作成していないので、課題どおりGNU Helloをパッケー
    ジ化してみました。参考書はmaint-guide-jaです。記述が古かったこ
    と、dh-makeが作るテンプレートのStandards-Versionが3.7.3なのに対し
    てLintianが3.8.0を要求(?)したことなどの問題を除けば、参考書の通りす
    んなりとできました。感想ですが、私はよくできていると思います。作業
    はめんどくさかったのですが、その原因は「ちゃんとしたパッケージを作
    る」ことにあり、これは必須のことです。そのめんどくささをツールでで
    きるだけ軽減するよう工夫されています。特に問題は感じませんでした。
    どう「進化」しているのか楽しみです!!

\end{prework}



\begin{prework}{ 榎真治 }

(無回答)

\end{prework}



\begin{prework}{ lurdan }

    \begin{description}
          \item[source format 3.0]　\\
        debian/ への変更が patches に入るのはまだしっくりきません%
        \footnote{%
          パッケージ作成の時に upstream へのソース変更が入ってい
          て、clean で変更が元に戻ってないのでは?(佐々木) }。
          \item[debhelper7]　\\
        upstream がまともな Makefile を用意してくれてる場合は幸せになれ
        そうです。
    \end{description}
\end{prework}

\dancersection{debhelper と CDBS のお話　{\normalsize $\sim$source format 3.0, the magic debhelper rules$\sim$}}{佐々木洋平}

次期安定版 6.0(squeeze)での RELEASE GOALS の一つに「new source package format support」があります\footnote{\url{http://release.debian.org/squeeze/goals.txt}}。
ここでの「new source package format」が {\bf source format 3.0} です。
\vspace{1em}

{\tt debhelper} は deb パッケージの構築を補助する様々なツール群です%
\footnote{%
deb パッケージそのものは {\tt debhelper} 無しでも作成できますが、
普通は {\tt debhelper} を使います。}。
多くのパッケージでは {\tt debhelper} の呼び出しはテンプレ化されているので
共通している {\tt debhelper} の呼び出しを隠蔽し
パッケージ作成のルール(debian/rules)を簡単にするのが
{\tt dh} と {\tt CDBS}です。
\vspace{1em}

ここでは source format 3.0, dh, CDBS についてお話しします。
ちなみに、
告知タイトルに「深追い」とか「CDBS 2.0」とかいう文字列があった気がしますが
気にしないで下さい。

\subsection{source format 1.0 $\to$ 3.0 }

source format 3.0 の前に、
これまでの source format 1.0 について簡単に復習しましょう。debian のソースパッケージは主に以下の構成物からなります:
\begin{quote}
    \begin{screen}
        \begin{description}
              \item[.orig.tar.gz] 　\\
            オリジナルのソース一式
              \item[.dsc]　\\
            パッケージの情報(パッケージの説明、メンテナ、ファイルのハッシュなど)
              \item[.diff.gz]　\\
            バイナリパッケージをビルドするための変更点。
            Debian 固有のパッケージの場合には存在しない。
        \end{description}
    \end{screen}
\end{quote}

さて, このソースフォーマットの構成には, 以下の問題点があります:
\begin{enumerate}
      \item アーカイブの圧縮形式として{\tt gzip} しか使えない。
      \item upstream のソースが複数のアーカイブから構成される場合が面倒。
      \item パッケージメンテナの作成したパッチが全部単一の patch に。
      \item diff で表現されるので(画像などの)バイナリが置きにくい。
\end{enumerate}

source format 1.0 の場合、これらの問題点は, だいたい以下の様に解決していました:
\begin{quote}
    \begin{description}
          \item[1. アーカイブの圧縮形式として{\tt gzip} しか使えない。] 　\\
        % 
        例えば upstream が bzip2 で配布されている場合でも gzip で圧縮しなお
        す、 もしくは tarball in tarball \footnote{%
          .orig.tar.gz を展開するとディレクトリ内にupstream の bzip2 が配置
          される。ビルドする際に tar を展開してからビルドする} などの形式に
        する, などです。
        % 
        後述の CDBS を使用する場合には tarball in tarball 用のルールが
        用意されています。
        % 
          \item[2. upstream のソースが複数のアーカイブから構成される場合が面倒。]　\\
        % 
        前述の tarball in tarball で対応しています。
        % 
          \item[3. パッケージメンテナの作成したパッチが全部単一の patch に。]　\\
        % 
        {\tt diff.gz} は {\tt debian} 以下のファイルが{\bf 全て}単一のファイ
        ルになっています。{\tt debian/control} や {\tt debian/rules} だけではなく、
        upstream のソースへのパッチも全て一つのファイルになっています。
        % 
        そこで、upstream のソースへのパッチは {\tt debian/patches} 以下に
        意味のある単位で分割して配置し、パッケージ作成の際に
        パッチの apply/unapply を行なうことにしています。
        % 
        このためのツールとしては{\tt dpatch} や
        {\tt quilt}
        \footnote{%
          こう書くと語弊があるかもしれませんが、
          {\tt quilt}は Debian 固有のツール{\bf ではありません}。念の為。}
        があります。
        % 
        また、cdbs にはパッチの apply/unapply をするためのルールが用意されていますし、
        dh には{\tt --with quilt} というオプションが用意されています。
        % 
        ちなみに、
        各パッチの先頭にその意図を記述するタグを追加しておくことが推奨されています
        \footnote{\url{http://dep.debian.net/deps/dep3/}\\
          面倒なので佐々木はサボリがちです。}。
        % 
          \item[4. diff で表現されるので(画像などの)バイナリが置きにくい。]　\\
        uuencode/uudecode で diff が取れる形式にしておく、などの工夫がされています。
    \end{description}
\end{quote}

というわけで、これまでの source format でも問題点について対応はできます。
しかしながら、
こういった特殊な操作を行なうことなく
問題点を解決するための新たなフォーマットとして、新たに
{\tt 3.0 (quilt)} と {\tt 3.0 (native)} が制定されました%
\footnote{\url{http://wiki.debian.org/Projects/DebSrc3.0}}。

{\tt 3.0 (quilt)} は以下のファイル群で構成されます:
\begin{quote}
    \begin{screen}
        \begin{description}
              \item[{\tt .orig.tar}.{\it ext}] 　\\
            upstream のソース。複数のソースからなる場合には基本となるソースに
            この名前をつける。{\it ext} は圧縮の拡張子であり、
            {\tt gz, bz2, lzma, xz}が使用可能。
            % 
              \item[{\tt .orig}{\it -component1}{\tt .tar.}{\it ext}]　\\
            upstream が複数のソースから構成される場合に作成する。
            % 
            {\it -componet} はソースの名前に対応して適宜名付ける.
              \item[{\tt .debian.tar.}{\it ext}]　\\
            {\tt debian} ディレクトリの中身。1.0 の {\tt diff.gz} から
            {\tt .tar.}{\it ext} になり、全てが混在した単一の patch では
            なくなった
            % 
              \item[{\tt .dsc}] 　\\
            これは変更無し. 
        \end{description}
    \end{screen}
\end{quote}
また {\tt 3.0 (native)} は 1.0 での Debian 固有パッケージに対応しており、
{\tt.orig.}{\it -component}{\tt .tar}{\it ext} と
{\tt debian.tar.}{\it ext} が存在しません。
%

これらの変更により
\begin{enumerate}
      \item アーカイブの圧縮形式として{\tt gzip} しか使えない。\\
    $\to$ {\tt .gzip, bzip2, lzma, xz} を使用できるようになりました。
    特に {\tt .gz} に比べて {\tt .xz} は圧縮率が高く、高速に伸長できるので
    現在では {\tt .xz} の使用が推奨されています。
    %
      \item upstream のソースが複数のアーカイブから構成される場合が面倒。\\
    $\to$ {\tt .orig}{\it -component}{\tt .tar}{\it .ext} により
    複数のソースを使用できるようになりました。
    これら{\tt .orig}{\it -component}{\tt .tar}{\it .ext} は
    ソースの展開時に {\tt compnent} というサブディレクトリに展開されます。
      \item パッケージメンテナの作成したパッチが全部単一の patch に。    
      \item diff で表現されるので(画像などの)バイナリが置きにくい。\\
    $to$ {\tt debian.tar.}{\it ext} になったので全てが混然となった
    状態は解消され、バイナリも含めることができます。
\end{enumerate}




\dancersection{puppetに \tt{ \textdollar HOME} を管理させてみよう}{倉敷悟}

今回は、皆さんの道具箱に入っていると便利な puppet というツールを
ご紹介します。

\subsection{はじめての糸繰り}

早速ですが、まずは動かしてみてもらおうと思います。lv をネタに使うので、
lv の設定を \textasciitilde /.lv に書いている人は、一旦適当に退避してください。

念の為、進む前に \textasciitilde /.lv が存在しないことを確認しておきましょう。

\subsubsection{実行サンプル}

なにはともあれ、puppet をインストールします。

puppet-el は、emacs でシンタックスハイライトさせるためのものなので、
emacs を使わない人はなくても OK ですが、なしでは割とやってられません。

\begin{commandline}
$ sudo aptitude install puppet puppet-el
$ emacs site.pp 
\end{commandline}

エディタが起動したら、site.pp には次のように入力してください。site.pp は
糸繰りの譜面、つまり設定ファイルです。なお、{\tt \#} はコメントなので無視して頂いて構いません。

\begin{commandline}
  # sudo が必要
  package { "lv":
    ensure => installed,
  }

  file { "/home/yourname/.lv":
    content => "-c",
  }
\end{commandline}

入力が終わったら、保存してコマンドに戻ります。では、いよいよ puppet に踊っ
てもらうことにします。
ネットに接続できるなら、aptitude purge lv してからでもいいでしょう。

\begin{commandline}
$ puppet site.pp
\end{commandline}

何が起きたか確認してみてください。予想通りすぎて、ちょっと拍子抜けかも知
れませんが……。

\newpage
\subsection{概要}

\subsubsection{用語の整理}

先に進む前に、用語の紹介だけしておきます。

site.pp に入力してもらった設定のことをマニフェストと呼び、ここに、必要な
リソースを宣言することで、puppet を操っていきます。

先ほど書いてもらったマニフェストでは、package と file がそれぞれ
リソースの宣言になります。
puppet が理解できるリソースはあらかじめ決まっていますが、自分で新しく
リソースを作ることもできます。

リソースの構成要素と、基本的な書式は次のようになります。区切りの記号に注意してください。

\begin{itemize}
 \item タイプ : リソースの種類
 \item タイトル : 「その」リソースの名前
 \item 属性 : 様々なパラメータ
\end{itemize}

\begin{commandline}
タイプ {
  "タイトル":
    属性 => 値,
    属性 => 値,
    ...
    属性 => 値;
  "タイトル":
    ...
}
\end{commandline}

\subsection{puppet の概要}

ここで一旦手を休めて、puppet そのものについて、もう少し説明しておきます。

puppet が何か、を一言でいえば、システム構成の管理ツールということになります。
普段、sudo を使ってやるような「パッケージ操作」「/etc 配下の設定変更」
「プロセスの起動停止」といった作業内容を、事前にレシピを書いておくことで、
puppet に任せることができます。

\subsubsection{構成}

puppet は、だいたい次のような構成で動きます。

\begin{itemize}
\item puppet : マニフェストを実行するコマンド
\item puppetd : puppetmasterd にマニフェストをリクエストして、それを実行するデーモン
\item puppetmasterd : マニフェストの束をもっていて、puppetd のリクエスト
      にあわせて適切に配布するデーモン
\end{itemize}

実は、puppet を使う場合は、puppetmasterd と puppetd の組み合わせで多数の
ホストを集中管理するのが普通だったりします。

ですが、今回はそれは一旦おいておいて、puppet コマンドを使ったお手軽な方
法をベースに進めていきますのでご承知置きください。

最後でもご紹介しますが、普通の構成についても既に山ほど記事や資料はあるので、
興味がある方はそちらをご参照頂ければと思います。

\newpage
\subsubsection{ディレクトリ配置}

puppet が使用するディレクトリですが、典型的にはこんな感じです。設定でど
うとでも変えられるので、配置されるものの種類がこんな感じなのだと思ってく
ださい。

実際のところ、puppet コマンドを使う場合は、/etc/puppet ではなくて
\textasciitilde /.puppet が主な作業場所として想定されます。

\begin{itemize}
 \item /etc/puppet/ : puppet 自体の動作設定ファイルが配置されます
 \item /etc/puppet/manifests : マニフェストが配置されます
 \item /etc/puppet/templates : テンプレートファイルが配置されます
 \item /etc/puppet/modules : puppet module が配置されます
 \item /var/lib/puppet : マニフェストのキャッシュや、SSL 証明書が配置さ
       れます
\end{itemize}

ここで、最初に作ったマニフェストを、\textasciitilde /.puppet/manifests に移動させておい
てください。puppet を実行した時点で、\textasciitilde /.puppet は作成されているはずです。


\subsection{設定を増やす}

では、実践に戻ります。lv だけでは寂しいので、他にもレシピを追加して
みることにします。ちょっと時間をとるので、自分的に必須なツールなど、
適当に書いてみてください。emacs でも screen でも何でも OK です。


\subsection{リソースの整理}

設定をどんどん追加していくと、site.pp にずらずらとリソースが並んで、
大変見通しが悪くなってきます。そこで、リソースをグルーピングすることにしましょう。

puppet で用意されているリソースのグルーピング方法には、ノード、クラス、
デファイン、モジュール、といったものがあります。

\subsubsection{ノード}

ノードは、ホストの fqdn と関連づけられるリソースのグループです。「この
fqdn のホストに、このリソースをまとめて反映しといて！」というイメージです。

実際の定義はこんな感じになります。

\begin{commandline}
node myhost01.localdomain {
  file {.....}
  service {.....}
}
\end{commandline}

node の中に書いた定義は、ホスト名が指定されたものと一致しているホストで
のみ有効になります。

emacs はマシン全部に入れるけど、wicd はデスクトップには要らないや、
みたいな使い分けが考えられます。

\subsubsection{クラス}

クラスは、ノード程具体的ではないのですが、「何となく関係しているリソースを
まとめて名前つけとこ！」というイメージのものです。
実際に使うときは、事前に定義した class をマニフェスト中で include する
必要があります。

実際の定義はこんな感じになります。

\begin{commandline}
class myconfig {
  file {.....}
  package {.....}
}

include myconfig
\end{commandline}

\subsubsection{デファイン}

デファインは、クラスと似ているのですが、引数を取れるところと、デファイン
で定義したリソースは複数回設定できるところが違っています。

実際の定義はこんな感じになります。

\begin{commandline}
define emacs::config ( $content, ){
  file { $name.el:
    content => $content,
  }
}

emacs::config { "howm":
  content => ”(require 'howm)"
}
\end{commandline}

個人的には、クラスを補完する目的で使うことが多いでしょうか。クラスとの比
較例でもよく使われますが、apache クラス (1回だけ登場) の補助で、デファイン
しておいた apache::vhost (複数回登場) を使う、などです。


\subsubsection{モジュール}

モジュールは、前述したノードやクラスとはちょっと位置付けが異なっていて、
マニフェストの書き方というよりは、ファイルの配置の仕方でグルーピングを
するものです。

基本的には、先に触れた puppetdir/modules の下に、ミニ puppet
設定ディレクトリを作ります。
よく使うので一応 fles と templates も書いていますが、モジュールと
しては少なくとも init.ppがあれば機能します。

\begin{commandline}
modules/
 モジュールの名前/
   manifests/
     init.pp
   files/
   templates/
\end{commandline}

一まとまりの大きな機能をモジュールとして構成しておいて、必要な場合だけ
読み込む、といったことができます。

また、自分が書いているマニフェストの中でも、独立性を高くして切り離すこと
ができるので、他の人とマニフェストを交換する場合に便利です。
github などで、モジュール個別のリポジトリが公開している人などもいて、
お手本としても役立ちます。

\subsection{モジュールの切り出し}

書いたマニフェストが充実してきたら、モジュールとして切り出すようにしたい
のですが、今回は時間もないので、充実していないながら一度切り出しを試して
みようと思います。

\subsubsection{lv モジュール}

では、一度 .puppet/modules に移動して、モジュールのためのディレクトリを
用意して、モジュールを作ってみましょう。

\begin{commandline}
mkdir -p ~/.puppet/modules/lv/manifests
emacs ~/.puppet/modules/lv/manifests/init.pp
\end{commandline}
 
\begin{commandline}
class lv {

ここに最初に書いた内容をコピー

}
\end{commandline}

site.pp に書いていた、同じ内容は消しておいてください。puppet では、同じ
名前をもったリソース宣言は重複としてエラーになります。

\subsubsection{モジュールの読み込み}

さて、設定を切り出したのはいいですが、さっきと同じように puppet コマンド
を実行しても、切り出した部分は動いてくれません。init.pp を直接引数にすれ
ば動かなくもないですが、設定が複雑になったり、複数のモジュールを使いたく
なったら破綻します。

puppet にモジュールを認識させるには、次のステップが必要です。

\begin{enumerate}
 \item puppet の設定 (modulepath) でモジュールの配置場所を教える
 \item site.pp からそのモジュールで定義したクラスを include する
\end{enumerate}

これを実現するため、site.pp に、include lv という一文を追加して、
こういうコマンドラインでもう一度実行してみましょう。

\begin{commandline}
puppet --modulepath ~/.puppet/modules ~/.puppet/manifests/site.pp
\end{commandline}

さて、無事に動いたでしょうか。

\subsubsection{切り出しで迷ったら}

愛情こめて育てた site.pp からモジュールを切り出そう、と思ったときに、
どういう名前でどの範囲を切り取るか、迷うことがあるかも知れません。

そんな時は、使おうとしている機能を提供するパッケージとモジュールを
対応づけるのがおすすめです。

すでに作った lv モジュールや、emacs モジュール、apache モジュール、
xmonad モジュール、platex モジュール……などと考えるわけです。

切り分けの単位としてわかりやすいことと、puppet が OS のパッケージ
システムとうまく連携してくれるために、後で複数のモジュールを組み合わせ
たくなった時にやりやすい、のがポイントです。

また、後で別の用途にそのモジュールを使い回すには……と考えながら作ると、
機能面でもいい具合に切り分けできるのではないかと思います。

\subsubsection{puppet-module ツールの紹介}

puppet を作っている puppetlabs という企業が、最近モジュール用の
リポジトリとして alioth のようなサイトをオープンしました。

\url{http://forge.puppetlabs.com/}

ブラウザでジャンル毎に公開されているモジュールを探したりできる
ようになっています。今はまだ登録されているモジュールの数が少ないですが、
そのうち充実してくれば、モジュールのカタログとして便利に使えるようになる
のではと思います。

このサイトと連動して、検索や取得 (その気があれば公開も) をするための
コマンドラインツールもあります。それが puppet-module です。

今のところ github からの取得になりますが、そのうち ruby 関連のメンテナ
がパッケージにするでしょう。

実際に使うとこんな感じです。

\begin{commandline}
puppet-module search [keyword]
\end{commandline}
で欲しいモジュールを探して、

\begin{commandline}
puppet-module install xx-yyy
\end{commandline}

でダウンロードしてきます。指定している xx-yyy ですが、forge での
名前空間は、xx (作者名)/yyy (モジュール名) となっていて、それを
指定します。自分の名前が頭につくので、モジュール名は他の人とかぶっても
大丈夫、ということですね。

注意が必要なのは、install とはいいながら、コマンドを実行したカレント
ディレクトリに展開するだけで、puppetdir/modules に自動で配置して
くれるわけではないところです。ダウンロードした後で、自分で移動させてください。

puppet-module には generate という機能もあり、モジュールの雛形を
作ってくれます。この場合も、forge の名前空間を指定する必要があるので、
使用例は次のようになります。

\begin{commandline}
$ bin/puppet-module generate lurdan-homedir
$ mv lurdan-homedir ~/.puppet/modules
$ cd lurdan-homedir
$ emacs manifests/init.pp
\end{commandline}

generate で作成されるディレクトリ構造はこんな感じになります。モジュール
としてフル機能が実装できるように、あれこれ気を利かせてくれている感じがし
ますね。

\begin{commandline} 
Modulefile
README
manifests/
files/
templates/
tests/
lib/
spec/
metadata.json
\end{commandline}

モジュールを作るのに慣れてきたら、これを使っていくのもいいと思います。
逆に、慣れないうちは余分なものが多くて邪魔かも。

\subsection{ {\tt \$HOME} の管理に使う}

さて。長い長ぁい前置きが終わり、ようやくここからが本題です。

puppet はその目的 (システムの構成管理) を考えても、root で
実行するのがほぼ前提です。

でも、そんな大げさにシステムあっちゃこっちゃいじらないし、自分の
home ディレクトリで設定ファイルを適当に管理してくれたらいいから、
というのが今回のお題だったりするわけです。

package 操作などもあるので、やっぱり実行は root でやって
もらう必要がどうしてもあります。でも、そのままファイルを作られたら、
パーミッションが root:root になってしまいますし、そもそも
puppet はマニフェストの中で実行ユーザのホームディレクトリを認識
するようには作られていません。

\subsubsection{環境変数の受け渡し}

では、どうしましょう。半ば無理矢理ではありますが、{\tt \$HOME}
と {\tt \$USER} を puppet に渡して、それをマニフェスト側で
受けとればいいわけです。

渡す方は、「FACTER 環境変数」というものを使って実現します。
FACTER 環境変数についての詳細は省きますが、ひとまず一種の
おまじないとして、渡したい環境変数の頭に、「FACTER\textunderscore」を
つけるのだと思っておいてください。

具体的には、こういう感じで使います。

\begin{commandline}
sudo FACTER_HOME=$HOME puppet /path/to/site.pp
\end{commandline}

こうして渡した環境変数は、マニフェストの中でこのように
受けとることができます。

\begin{commandline}
  ...
  file { "$home/.lv":
  }
  ...
\end{commandline}

最初に作ってもらったマニフェストを見直してみてください。この仕掛けを使え
ば、ユーザ名を直接書かずに、使い回せる形で書き直すことができます。
モジュールにすることを考えても、こちらの方がより融通がきくようになりますね。
ユーザ名埋め込みとか、ゾッとしませんよね。

当面必要になるのは、{\tt \$HOME} と {\tt \$USER}、後は {\tt group} くらいなので、このあたり
を埋めこんでシェルスクリプトにしておきます。

\begin{commandline}
#!/bin/sh
 
FACTERENV="FACTER_HOME=$HOME FACTER_USER=$USER FACTER_GROUP=`id -gn`"
sudo $FACTERENV puppet ~/.puppet/manifests/site.pp --modulepath ~/.puppet/modules --debug --verbose
\end{commandline}

これを適当に \textasciitilde/.puppet/puppet.sh あたりに保存しておいて、実行する時は

\begin{commandline}
$ ~/.puppet/puppet.sh
\end{commandline}

とすれば、マニフェストのどこでも、\$home と \$user、\$group にアクセスすることができます。実行ユーザの環境変数を拾っているので、シェルスクリプト自体には sudo は不要です。

これで下準備も整いましたので、どんどんマニフェストやモジュールを書いていってみてください。

%http://arika.org/diary/2009/04/24/sudo-and-env
%http://d.hatena.ne.jp/kakurasan/20070723/p1

\subsection{もっと深みに}

入門セッションということで、今日扱った内容からは、いろいろと重要なポイン
トが抜けています。一応キーワードだけ列挙しておきますので、後述の資料と
あわせて、参考にしてみてください。

\begin{itemize}
 \item facter : 実行環境のデータを集めて変数として提供。puppet の裏方
 \item ファイルサーバ : 事前に準備したファイルを各ノードに配布
 \item テンプレート : eruby で配布ファイルに変数埋め込み
 \item 仮想リソース : 定義の依存が被ってしまう場合に共用可能とする
 \item puppet 拡張 : ruby であれこれいじれるらしいです
 \item 環境 : 本番と検証と開発を分けたりできる
\end{itemize}

個人的に面白いなーと思っているトピックとして、

\begin{itemize}
 \item puppetdoc : モジュールにマニュアルを埋め込む
 \item puppet のテスト
\end{itemize}

というのもあります。興味がある方はまた宴会ででも。

%マニフェストを書く上での注意
%「状態」を定義する (「変化」「遷移」ではなく)

% \setbeamertemplate{background}{\includegraphics[width=\paperwidth]{filename}}

\subsubsection{資料は英語}

puppet の公式な資料は、puppetlabs のサイトでメンテナンスされています。
使うために必要な文書は比較的よく整備されていると思いますが、基本的には英
語です。

私は下記をよく参照しています。

\begin{itemize}
 \item language tutorial : \url{http://docs.reductivelabs.com/guides/language_tutorial.html}
 \item type reference : \url{http://docs.puppetlabs.com/references/stable/type.html}
 \item meta parameter reference : \url{http://docs.puppetlabs.com/references/0.25.5/metaparameter.html}
\end{itemize}

\subsubsection{日本語の資料}

puppet は国内でも素晴しい先達によってすでに語り尽くされていたりします
ので、もうちょっと慣れるまで英語は……という方は、下記の資料などに
あたってみてください。

今回のセッションで扱った内容は、ほぼこれらの資料でカバーされてる範囲を
出ていなかったりしますが、とっかかりにはなるのではと思います。

\begin{itemize}
 \item オープンソースなシステム自動管理ツール Puppet : \url{http://gihyo.jp/admin/serial/01/puppet}
 \item Puppet によるインフラ管理入門 : \url{http://www.sssg.org/~naoya/puppet/project.html}
 \item puppet のススメ : \url{http://www.slideshare.net/mizzy/puppet-3258268}
\end{itemize}

\dancersection{今後の予定}{Debian JP}

\subsection{次回の関西Debian勉強会}
次回、2010年7月の関西Debian勉強会は
オープンソースカンファレンス 2010 Kansai @ Kyoto において
「第37回関西Debian勉強会@OSC2010 Kyoto」を行ないます.

ブースではのがたさんの最新 Debian T シャツや LiveDVD の展示、
セッションでは佐々木さんの「野良ビルドから始めるDebianパッケージ作成」
を予定していますので、是非ご来場くださいです。

\subsection{次々回の関西Debian勉強会}
次々回、2010年8月の関西Debian勉強会は、8月22日(日)に実施する予定です。

% 冊子にするために、4の倍数にする必要がある。
% そのための調整
\dancersection{メモ}{}
\mbox{}\newpage

\printindex
 \cleartooddpage

 \begin{minipage}[b]{0.2\hsize}
  \rotatebox{90}{\fontsize{80}{80} {\gt 関西 Debian 勉強会} }
 \end{minipage}
 \begin{minipage}[b]{0.8\hsize}

 \vspace*{15cm}
 \rule{\hsize}{1mm}
 \vspace{2mm}
 \includegraphics[width=2cm]{image200502/openlogo-nd.eps}
 \noindent \Large \bf Debian 勉強会資料\\ \\
 \noindent \normalfont \debmtgyear{}年\debmtgmonth{}月\debmtgdate{}日 \hspace{5mm}  初版第1刷発行\\
 \noindent \normalfont 関西 Debian 勉強会 （編集・印刷・発行）\\
 \rule{\hsize}{1mm}
 \end{minipage}

\end{document}
